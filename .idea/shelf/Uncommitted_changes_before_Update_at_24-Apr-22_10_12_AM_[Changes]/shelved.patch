Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import json\r\nimport logging\r\nimport threading\r\nfrom pickle import dumps, loads\r\nfrom flask import Flask, render_template, request, redirect\r\n\r\nimport Blockchain\r\nimport Compress\r\nfrom Networking import receiver, sendRequest, JoinRequest, SearchBundleRequest, receiveBundle, GetBundleRequest\r\nfrom Groups import GroupManager, Invite, Group\r\nfrom Client import Client\r\nimport easygui\r\nfrom Bundles import BundleManager\r\nfrom Downloads import DownloadManager\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = False\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    progress = downloadManager.getDownloadProgress()\r\n    return render_template(\"index.html\", groups=groupManager.groups, client=client, progress=progress)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    group = groupManager.getGroupWithName(group)\r\n    # Check if user should see admin panels.\r\n    peers, bans, admins, owner = group.blockchain.parseBlockchain()\r\n    print(peers,admins,bans)\r\n    # Check privs what to show on group page.\r\n    adminPriv = False\r\n    for admin in group.admins:\r\n        if admin[0] == client.publicIP:\r\n            adminPriv = True\r\n\r\n    ownerPriv = False\r\n    if group.blockchain.getOwner() == client.publicIP:\r\n        ownerPriv = True\r\n\r\n\r\n\r\n\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group, client=client, adminPriv=adminPriv,\r\n                           ownerPriv=ownerPriv, peers=peers, bans=bans, admins=admins)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    if downloadManager.STATUS:\r\n        downloadManager.STATUS = False\r\n        # downloadManager Off\r\n        print(\"Download Manager Not Active\")\r\n        return \"0\"\r\n    else:\r\n        downloadManager.STATUS = True\r\n        # downloadManager On\r\n        print(\"Download Manager Active\")\r\n        return \"1\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n        # TODO KEY SPECIFIC BLOCKCHAIN\r\n        ip = data[\"ip\"]  # This is string\r\n        transaction = Blockchain.InviteTransaction(ip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        # print(\"Generate Invite for :\", group)\r\n        # print(group)\r\n        invite = group.generateInvite()\r\n        return Compress.compress(invite.toJSON())\r\n\r\n\r\n\r\n@app.route('/deleteBundle', methods=['POST'])\r\ndef deleteBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupId = data[\"groupId\"]\r\n        bundleId = data[\"bundleId\"]\r\n        if groupManager.deleteBundle(groupId, bundleId):\r\n            return \"1\"\r\n        else:\r\n            return \"0\"\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        inviteDecomp = Compress.decompress(invite)\r\n        inviteLoad = json.loads(inviteDecomp)\r\n        invite = Invite(inviteLoad[\"id\"], inviteLoad[\"name\"], inviteLoad[\"timestamp\"], inviteLoad[\"peers\"])\r\n        joinReq = JoinRequest(invite.name, invite.timestamp)\r\n        print(invite.peers)\r\n        for peer in invite.peers:\r\n            print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq))\r\n            if res is not False:\r\n                # Response from user with group data.\r\n                group = res.group\r\n                group = Group(group.name, group.admins, group.peers, group.timestamp,\r\n                              blockchainPath=groupManager.DIR_PATH_GROUPS + group.name + \"\\\\Blockchain\", client=client)\r\n                groupManager.addGroup(group)\r\n                # Make Join Transaction.\r\n                transaction = Blockchain.JoinTransaction(client.publicIP,\r\n                                                         client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n                transactionStr = json.dumps(transaction.__dict__)\r\n                group.blockchain.addNewTransaction(transactionStr)\r\n                # transactionStr = json.dumps(transaction.__dict__)\r\n                # this is string json format\r\n                # print(transactionStr)\r\n                # print(transactionStr.__class__)\r\n                # Genereate signature for Transaction\r\n                # signature = rsa.sign(transactionStr.encode(), client.privateKey, 'SHA-1')\r\n                # genesis_block = Block(0, transactionStr, str(time.time()), \"0\", [str(signature)])\r\n                # genesis_block.hash = genesis_block.computeHash()\r\n                # self.saveBlock(genesis_block)\r\n                # self.chain.append(genesis_block)\r\n                return \"1\"\r\n        # No responses.\r\n        return \"0\"\r\n\r\n\r\n@app.route('/shareBundle', methods=['POST'])\r\ndef shareBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"bundleName\"]\r\n        desc = data[\"bundleDescription\"]\r\n        groupName = data[\"groupName\"]\r\n        print(name)\r\n        print(desc)\r\n        print(groupName)\r\n        path = easygui.diropenbox(msg=\"Select folder to share as bundle\", title=\"Share Bundle\")\r\n        bundle = bundleManager.createBundle(name, desc, path=path)\r\n        groupManager.addBundle(bundle, groupName)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/selectDownloadLocation', methods=['POST'])\r\ndef selectDownloadLocation():\r\n    if request.method == 'POST':\r\n        path = easygui.diropenbox(msg=\"Select folder to download bundles\", title=\"Select Bundle Download Location\")\r\n        print(path)\r\n        # Update Download Path in Config\r\n        client.DIR_PATH_DOWNLOADS = path\r\n        client.saveConfig()\r\n        # Return path to browser and update it in modal\r\n        return path\r\n\r\n\r\n@app.route('/searchBundles', methods=['POST'])\r\ndef searchBundles():\r\n    # print(\"Search Bundles Route\")\r\n    if request.method == 'POST':\r\n        data = request.form\r\n\r\n        # Get Keywords from search\r\n        keywords = data[\"searchKeyWords\"].split()\r\n        # print(\"Search for :\",keywords)\r\n\r\n        # Get Group\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n\r\n        searchReq = SearchBundleRequest(group.id, keywords)\r\n        responses = []\r\n        # SEND TO ALL PEERS COLLECT RESPONSES AND PRESENT\r\n        for peer in group.peers:\r\n            res = sendRequest(peer[0], 6700, dumps(searchReq))\r\n            # if other peer is responded.\r\n            if res is not False:\r\n                # print(res)\r\n                responses.append([peer[0], res])\r\n            else:\r\n                print(\"No Response from\", peer[0])\r\n        # Merge all responses to single list\r\n        # for x in responses:\r\n        #     print(\"Response:\",x[0],x[1],x[1].responseBundles)\r\n        # WITH RESPONSES DO STUFF.\r\n        # Respond\r\n        return render_template(\"search.html\", groups=groupManager.groups, group=group, responses=responses)\r\n\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n    if groupManager.createGroup(name, [client.publicIP]):\r\n        # Make First Block In Blockchain Append Admin\r\n        # Type 0 First Created\r\n        group = groupManager.getGroupWithName(name)\r\n        group.blockchain.createGenesisBlock(client)\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n\r\n@app.route('/getBundle', methods=['POST'])\r\ndef getBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        bundleId = data[\"bundleId\"]\r\n        groupId = data[\"groupId\"]\r\n        userIp = data[\"userIp\"]\r\n        # TODO dynamic port on receiver for bundle\r\n        portForBundleReceiver = 6701\r\n        bundleReceiver = threading.Thread(target=receiveBundle,\r\n                                          args=[portForBundleReceiver, client, groupManager, groupId, downloadManager])\r\n        bundleReceiver.start()\r\n        getBundleReq = GetBundleRequest(bundleId, groupId, portForBundleReceiver)\r\n        res = sendRequest(userIp, 6700, dumps(getBundleReq))\r\n        # if other peer is responded.\r\n        if res is not False:\r\n            # Responded decide what to do\r\n            pass\r\n        else:\r\n            # print(\"No Response from\", userIp)\r\n            pass\r\n    return \"1\"\r\n\r\n\r\n@app.route('/quitGroup', methods=['POST'])\r\ndef quitGroup():\r\n    # print('QUIT GROUP REQ')\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        if groupManager.quitGroup(group):\r\n            # True\r\n            return \"0\"\r\n        else:\r\n            # False\r\n            return \"1\"\r\n\r\n\r\n@app.route('/banUser', methods=['POST'])\r\ndef banUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.BanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/unbanUser', methods=['POST'])\r\ndef unbanUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.UnbanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/addAdmin', methods=['POST'])\r\ndef addAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.AddAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/removeAdmin', methods=['POST'])\r\ndef removeAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.RemoveAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    groupManager = GroupManager(client)\r\n    bundleManager = BundleManager()\r\n    downloadManager = DownloadManager(groupManager, client)\r\n    # TODO Networking Thread To Receive From Internet\r\n    receiver = threading.Thread(target=receiver, args=[groupManager])\r\n    receiver.start()\r\n    app.run(host='', port=6969)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 9bc0ced24672e1b7c197c25e5681de5191a1b7fc)
+++ b/main.py	(date 1650784310570)
@@ -34,7 +34,10 @@
     group = groupManager.getGroupWithName(group)
     # Check if user should see admin panels.
     peers, bans, admins, owner = group.blockchain.parseBlockchain()
+
     print(peers,admins,bans)
+    # print(group.admins)
+    # print(group.peers)
     # Check privs what to show on group page.
     adminPriv = False
     for admin in group.admins:
