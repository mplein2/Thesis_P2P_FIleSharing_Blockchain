Index: Blockchain.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import math\r\nimport os\r\nimport json\r\nfrom os import listdir\r\nimport rsa\r\nimport time\r\nfrom time import sleep\r\nimport threading\r\nfrom hashlib import sha256\r\nimport copy\r\nfrom pickle import dumps, loads\r\n\r\n\r\nclass Block:\r\n    def __init__(self, index, transaction, timestamp, previous_hash, signatures):\r\n        self.index = index\r\n\r\n        self.transaction = transaction\r\n\r\n        self.timestamp = timestamp\r\n\r\n        self.previous_hash = previous_hash\r\n\r\n        self.signatures = signatures\r\n\r\n    def computeHash(self):\r\n        mycopy = copy.copy(self)\r\n        del mycopy.signatures\r\n        # print(mycopy.__dict__)\r\n        if hasattr(mycopy, 'hash'):\r\n            del mycopy.hash\r\n        block_string = json.dumps(mycopy.__dict__, sort_keys=True)\r\n        return sha256(block_string.encode()).hexdigest()\r\n\r\n\r\nclass UnconfirmedTransaction:\r\n    def __init__(self, transaction, signatures=[]):\r\n        self.transaction = transaction\r\n        self.signatures = signatures\r\n\r\n\r\nclass GenesisTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 0\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass InviteTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 1\r\n        self.ip = ip\r\n\r\n\r\nclass JoinTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 2\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass BanTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 3\r\n        self.ip = ip\r\n\r\n\r\nclass UnbanTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 4\r\n        self.ip = ip\r\n\r\n\r\nclass AddAdminTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 5\r\n        self.ip = ip\r\n\r\n\r\nclass RemoveAdminTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 6\r\n        self.ip = ip\r\n\r\n\r\nclass Blockchain:\r\n    def __init__(self, path, groupPeers, groupAdmins, groupId, client):\r\n        self.BLOCKCHAIN_PATH = path\r\n        self.TRANSACTION_PATH = self.BLOCKCHAIN_PATH + \"\\\\Transactions\\\\\"\r\n        self.unconfirmed_transactions = []\r\n        self.chain = []\r\n        self.peers = groupPeers\r\n        self.groupId = groupId\r\n        self.groupAdmins = groupAdmins\r\n        self.client = client\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n            # Load Unconfirmed Transactions\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n\r\n        self.loadTransactions()\r\n\r\n        # print(self.unconfirmed_transactions)\r\n        # Load Blocks here\r\n        blockFiles = [f for f in listdir(self.BLOCKCHAIN_PATH) if os.path.isfile(os.path.join(self.BLOCKCHAIN_PATH, f))]\r\n        for blockFile in blockFiles:\r\n            self.loadBlock(blockFile)\r\n\r\n        # Start Casual Operations.\r\n        # Thread This.\r\n        miner = threading.Thread(target=self.mine, args=[client])\r\n        miner.start()\r\n        # print(self.unconfirmed_transactions)\r\n        # for block in self.chain:\r\n        #     print(block)\r\n\r\n    def getDifficulty(self):\r\n        # Diffuculty of blockchain will be dependent on the users participating\r\n        # TODO refactor this for join ban unban\r\n        if len(self.peers) == 0:\r\n            return 1\r\n        else:\r\n            peers, bans, admins, owner = self.parseBlockchain()\r\n            return math.floor(math.log2(len(peers)))\r\n\r\n    def createGenesisBlock(self, client):\r\n        transaction = GenesisTransaction(client.publicIP, client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        # this is string json format\r\n        # print(transactionStr)\r\n        # print(transactionStr.__class__)\r\n        # Genereate signature for Transaction\r\n        signature = rsa.sign(transactionStr.encode(), client.privateKey, 'SHA-1')\r\n        genesis_block = Block(0, transactionStr, str(time.time()), \"0\", [str(signature)])\r\n        genesis_block.hash = genesis_block.computeHash()\r\n        self.saveBlock(genesis_block)\r\n        self.chain.append(genesis_block)\r\n\r\n    def saveBlock(self, block):\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Creating Blockchain Folder\")\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n        blockFile = open(self.BLOCKCHAIN_PATH + \"\\\\Block\" + str(block.index) + \".json\", \"w\")\r\n        # print(block.__dict__)\r\n        blockFile.write(json.dumps(block.__dict__))\r\n        blockFile.close()\r\n\r\n    def loadTransactions(self):\r\n        filePath = self.TRANSACTION_PATH + \"Transactions.json\"\r\n        if os.path.exists(filePath):\r\n            try:\r\n                file = open(filePath)\r\n                # print(file)\r\n                json_load_group = json.load(file)\r\n                file.close()\r\n            except Exception as e:\r\n                print(\"Error Opening Transaction file :\", e)\r\n            for x in json_load_group:\r\n                transaction = UnconfirmedTransaction(x[\"transaction\"], x[\"signatures\"])\r\n                # print(transaction)\r\n                self.unconfirmed_transactions.append(transaction)\r\n            # print(self.unconfirmed_transactions)\r\n\r\n    def loadBlock(self, blockFiles):\r\n        # print(blockFiles)\r\n        filePath = self.BLOCKCHAIN_PATH + \"\\\\\" + blockFiles\r\n        file = open(filePath)\r\n        # print(file)\r\n        block = json.load(file)\r\n        file.close()\r\n        # # print(block)\r\n        # transaction = json.loads(block[\"transaction\"])\r\n        # # print(transaction)\r\n        # # print(transaction.__class__)\r\n        # # Make transaction here\r\n        # if transaction[\"type\"] == 0:\r\n        #     # print(\"Genesis block\")\r\n        #     transactionObj = GenesisTransaction(transaction[\"ip\"], transaction[\"publicKey\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        blockObj = Block(block[\"index\"], block[\"transaction\"], block[\"timestamp\"], block[\"previous_hash\"],\r\n                         block[\"signatures\"])\r\n        blockObj.hash = block[\"hash\"]\r\n        # TODO Add all transactions here\r\n\r\n        # elif transaction[\"type\"] == 1:\r\n        #     # print(\"Genesis block\")\r\n        #     # print(transaction)\r\n        #     transactionObj = InviteTransaction(transaction[\"ip\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        #     blockObj = Block(block[\"index\"], transactionStr, block[\"timestamp\"], block[\"previous_hash\"],\r\n        #                      block[\"signatures\"])\r\n        #     blockObj.hash = block[\"hash\"]\r\n\r\n        self.chain.append(blockObj)\r\n        # print(blockObj.__dict__)\r\n\r\n    def addNewTransaction(self, transaction: str):\r\n        newUnconfirmedTransaction = UnconfirmedTransaction(transaction)\r\n        self.unconfirmed_transactions.append(newUnconfirmedTransaction)\r\n        self.saveUnconfirmedTransactions()\r\n\r\n    def updateBlockchain(self, client):\r\n        for peer in self.peers:\r\n            # Dont send to self\r\n            if peer[0] != client.publicIP:\r\n                # For each peer ask their max index of blockchain\r\n                updateBlockchainReq = Networking.UpdateBlockchainRequest(self.groupId)\r\n                res = Networking.sendRequest(peer[0], 6700, dumps(updateBlockchainReq))\r\n                if res is not False:\r\n                    # if the response is bigger than me ask him for his block until we are at the same.\r\n                    if res.answer > self.getLastBlockIndex():\r\n                        print(self.getLastBlockIndex().__class__, res.answer.__class__)\r\n                        while self.getLastBlockIndex() < res.answer:\r\n                            # Get block\r\n                            getBlockReq = Networking.GetBlockRequest(self.groupId, self.getLastBlockIndex() + 1)\r\n                            blockRes = Networking.sendRequest(peer[0], 6700, dumps(getBlockReq))\r\n                            if blockRes is not False:\r\n                                print(f\"Update BC Response:{blockRes}\")\r\n                                # print(blockRes.answer)\r\n                                block = blockRes.answer\r\n                                block: Block\r\n                                print(block.index, block.transaction, block.signatures, block.timestamp,\r\n                                      block.previous_hash, block.hash)\r\n                                newBlock = Block(block.index, block.transaction, block.timestamp, block.previous_hash,\r\n                                                 block.signatures)\r\n                                newBlock.hash = block.hash\r\n                                if self.validateNewBlock(newBlock):\r\n                                    self.saveBlock(newBlock)\r\n                                    self.chain.append(newBlock)\r\n                            else:\r\n                                break\r\n                    else:\r\n                        # print(\"Up-to-date.\")\r\n                        pass\r\n\r\n    def getBlockWithIndex(self, index):\r\n        for block in self.chain:\r\n            block: Block\r\n            if block.index == index:\r\n                return block\r\n        return False\r\n\r\n    def validateNewBlock(self, newBlock):\r\n        \"\"\"This function is for new blocks that come from peers returns true if blocks checks out.\"\"\"\r\n        newBlock: Block\r\n\r\n        # If hash ok.\r\n        if newBlock.computeHash() == newBlock.hash:\r\n            # Validation for genesis block\r\n            if newBlock.index == 0:\r\n                if self.getLastBlockIndex() == -1:\r\n                    # No other blocks accept it.\r\n                    return True\r\n                else:\r\n                    return False\r\n            else:\r\n                # Check if new block is made with the same previous block.\r\n                # TODO if not resolve ?\r\n                if newBlock.previous_hash == self.getLastBlock().computeHash():\r\n                    # TODO check if signatures okay.\r\n                    # TODO check timestamp.\r\n                    # TODO check difficulty based on blockchain etc.\r\n                    return True\r\n\r\n    def mine(self, client):\r\n        # Load my public key.\r\n        # keyLoc = self.BLOCKCHAIN_PATH + \"\\\\..\\\\..\\\\..\\\\PRIVATEKEY.json\"\r\n        # # print(f\"key location = {keyLoc}\")\r\n        # f = open(keyLoc, \"rb\")\r\n        # data = f.read()\r\n        # privateKey = rsa.PrivateKey.load_pkcs1(data)\r\n        # # print(publicKey)\r\n        # f.close()\r\n        while True:\r\n            # Update Blockchain.\r\n            self.updateBlockchain(client)\r\n            if not self.unconfirmed_transactions:\r\n                # If No Transaction sleep and check again soon.\r\n                sleep(30)\r\n            else:\r\n                diff = self.getDifficulty()\r\n                print(f\"Blockchain Difficulty :{diff}\")\r\n                print(f\"Unconfirmed Transactions:{len(self.unconfirmed_transactions)}\")\r\n                for transaction in self.unconfirmed_transactions:\r\n                    transaction: UnconfirmedTransaction\r\n                    # For Each Transaction if signatures < difficulty collect transactions\r\n                    if diff > len(transaction.signatures):\r\n                        if not len(transaction.signatures):\r\n                            # No Signatures add my signature\r\n                            signature = rsa.sign(transaction.transaction.encode(), client.privateKey, 'SHA-1')\r\n                            transaction.signatures.append(str(signature))\r\n                            self.saveUnconfirmedTransactions()\r\n                        else:\r\n                            # Get Signatures from other persons.\r\n                            pass\r\n                    else:\r\n                        # We have the signatures number procede to make block and share.\r\n                        print(f\"Signature {transaction} ready to be made block.\")\r\n                        # Bytes\r\n                        lastBlock = self.getLastBlock()\r\n                        print(lastBlock)\r\n                        lastBlock: Block\r\n                        print(f\"Last Block Index :{lastBlock.index}\")\r\n                        newBlock = Block(lastBlock.index + 1, transaction.transaction, str(time.time()),\r\n                                         lastBlock.computeHash(), transaction.signatures)\r\n                        newBlock.hash = newBlock.computeHash()\r\n                        self.unconfirmed_transactions.remove(transaction)\r\n                        self.saveUnconfirmedTransactions()\r\n                        self.saveBlock(newBlock)\r\n                        self.chain.append(newBlock)\r\n                sleep(30)\r\n\r\n    def getLastBlock(self) -> Block:\r\n        lastBlockIndex = self.chain[0].index\r\n        # Find last Block and return it\r\n        lastBlock = self.chain[0]\r\n        for block in self.chain:\r\n            # print(block.index)\r\n            if block.index > lastBlockIndex:\r\n                lastBlock = block\r\n                lastBlockIndex = block.index\r\n        return lastBlock\r\n\r\n    def getLastBlockIndex(self):\r\n        if len(self.chain) == 0:\r\n            return -1\r\n        else:\r\n            lastBlockIndex = self.chain[0].index\r\n            # Find last Block and return it\r\n            lastBlock = self.chain[0]\r\n            for block in self.chain:\r\n                # print(block.index)\r\n                if block.index > lastBlockIndex:\r\n                    lastBlock = block\r\n                    lastBlockIndex = block.index\r\n            return lastBlock.index\r\n\r\n    def saveUnconfirmedTransactions(self):\r\n        # print(self.TRANSACTION_PATH)\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Blockchain Folder\")\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n        json_file = open(self.TRANSACTION_PATH + \"Transactions\" + \".json\", \"w\")\r\n        json_file.write((json.dumps([ob.__dict__ for ob in self.unconfirmed_transactions])))\r\n        json_file.close()\r\n\r\n    def isUserAllowed(self, ip):\r\n        for block in self.chain:\r\n            block: Block\r\n            transaction = json.loads(block.transaction)\r\n            # From Create Genesis Block\r\n            if transaction[\"type\"] == 0:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n            # From Invite\r\n            if transaction[\"type\"] == 1:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n        # Didndt find user\r\n        return False\r\n\r\n    def getOwner(self):\r\n        for block in self.chain:\r\n            transaction = json.loads(block.transaction)\r\n            if transaction[\"type\"] == 0:\r\n                return transaction[\"ip\"]\r\n\r\n    def parseBlockchain(self):\r\n        \"\"\"\r\n        Parses Blockchain and returns 5 list of user types.\r\n        Peers that are in the blockchain and allowed.\r\n        Banned peers, Invites ,Admins and, Owner . All are lists.\r\n        \"\"\"\r\n        peers = []\r\n        bans = []\r\n        admins = []\r\n        invites = []\r\n        owner = []\r\n\r\n        for block in self.chain:\r\n            transaction = json.loads(block.transaction)\r\n            #GenesisTransactio\r\n            if transaction[\"type\"] == 0:\r\n                owner.append(transaction[\"ip\"])\r\n                admins.append(transaction[\"ip\"])\r\n                peers.append(transaction[\"ip\"])\r\n\r\n            #InviteTransaction\r\n            elif transaction[\"type\"] == 1:\r\n                invites.append(transaction[\"ip\"])\r\n\r\n            #JoinTransaction\r\n            elif transaction[\"type\"] == 2:\r\n                peers.append(transaction[\"ip\"])\r\n                invites.remove(transaction[\"ip\"])\r\n\r\n            #BanTransaction\r\n            elif transaction[\"type\"] == 3:\r\n                peers.remove(transaction[\"ip\"])\r\n                bans.append(transaction[\"ip\"])\r\n\r\n            # UnbanTransaction\r\n            elif transaction[\"type\"] == 4:\r\n                bans.remove(transaction[\"ip\"])\r\n\r\n                # AddAdminTransaction\r\n            elif transaction[\"type\"] == 5:\r\n                admins.append(transaction[\"ip\"])\r\n\r\n            # RemoveAdminTransaction\r\n            elif transaction[\"type\"] == 6:\r\n                admins.remove(transaction[\"ip\"])\r\n\r\n        # print(f\"Peers:{peers},Bans:{bans},Admins:{admins},Owners:{owner}\")\r\n        return peers, bans, admins, owner\r\n\r\n\r\nimport Networking\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Blockchain.py b/Blockchain.py
--- a/Blockchain.py	(revision 397da46c4b816e67fbbc1f8b78f311f5a70ab115)
+++ b/Blockchain.py	(date 1650889080313)
@@ -386,8 +386,12 @@
 
         for block in self.chain:
             transaction = json.loads(block.transaction)
+            print(peers,invites)
+            print(transaction)
+
             #GenesisTransactio
             if transaction["type"] == 0:
+
                 owner.append(transaction["ip"])
                 admins.append(transaction["ip"])
                 peers.append(transaction["ip"])
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import json\r\nimport logging\r\nimport threading\r\nfrom pickle import dumps, loads\r\nfrom flask import Flask, render_template, request, redirect\r\n\r\nimport Blockchain\r\nimport Compress\r\nfrom Networking import receiver, sendRequest, JoinRequest, SearchBundleRequest, receiveBundle, GetBundleRequest\r\nfrom Groups import GroupManager, Invite, Group\r\nfrom Client import Client\r\nimport easygui\r\nfrom Bundles import BundleManager\r\nfrom Downloads import DownloadManager\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = False\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    progress = downloadManager.getDownloadProgress()\r\n    return render_template(\"index.html\", groups=groupManager.groups, client=client, progress=progress)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    group = groupManager.getGroupWithName(group)\r\n    # Check if user should see admin panels.\r\n    peers, bans, admins, owner = group.blockchain.parseBlockchain()\r\n    print(peers,admins,bans)\r\n    # Check privs what to show on group page.\r\n    adminPriv = False\r\n    for admin in group.admins:\r\n        if admin[0] == client.publicIP:\r\n            adminPriv = True\r\n\r\n    ownerPriv = False\r\n    if group.blockchain.getOwner() == client.publicIP:\r\n        ownerPriv = True\r\n\r\n    if client.publicIP in admins:\r\n        admins.remove(client.publicIP)\r\n    if client.publicIP in peers:\r\n        peers.remove(client.publicIP)\r\n\r\n\r\n\r\n\r\n\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group, client=client, adminPriv=adminPriv,\r\n                           ownerPriv=ownerPriv, peers=peers, bans=bans, admins=admins)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    if downloadManager.STATUS:\r\n        downloadManager.STATUS = False\r\n        # downloadManager Off\r\n        print(\"Download Manager Not Active\")\r\n        return \"0\"\r\n    else:\r\n        downloadManager.STATUS = True\r\n        # downloadManager On\r\n        print(\"Download Manager Active\")\r\n        return \"1\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n        # TODO KEY SPECIFIC BLOCKCHAIN\r\n        ip = data[\"ip\"]  # This is string\r\n        transaction = Blockchain.InviteTransaction(ip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        # print(\"Generate Invite for :\", group)\r\n        # print(group)\r\n        invite = group.generateInvite()\r\n        return Compress.compress(invite.toJSON())\r\n\r\n\r\n\r\n@app.route('/deleteBundle', methods=['POST'])\r\ndef deleteBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupId = data[\"groupId\"]\r\n        bundleId = data[\"bundleId\"]\r\n        if groupManager.deleteBundle(groupId, bundleId):\r\n            return \"1\"\r\n        else:\r\n            return \"0\"\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        inviteDecomp = Compress.decompress(invite)\r\n        inviteLoad = json.loads(inviteDecomp)\r\n        invite = Invite(inviteLoad[\"id\"], inviteLoad[\"name\"], inviteLoad[\"timestamp\"], inviteLoad[\"peers\"])\r\n        joinReq = JoinRequest(invite.name, invite.timestamp)\r\n        print(invite.peers)\r\n        for peer in invite.peers:\r\n            print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq))\r\n            if res is not False:\r\n                # Response from user with group data.\r\n                group = res.group\r\n                group = Group(group.name, group.admins, group.peers, group.timestamp,\r\n                              blockchainPath=groupManager.DIR_PATH_GROUPS + group.name + \"\\\\Blockchain\", client=client)\r\n                groupManager.addGroup(group)\r\n                # Make Join Transaction.\r\n                transaction = Blockchain.JoinTransaction(client.publicIP,\r\n                                                         client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n                transactionStr = json.dumps(transaction.__dict__)\r\n                group.blockchain.addNewTransaction(transactionStr)\r\n                return \"1\"\r\n        # No responses.\r\n        return \"0\"\r\n\r\n\r\n@app.route('/shareBundle', methods=['POST'])\r\ndef shareBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"bundleName\"]\r\n        desc = data[\"bundleDescription\"]\r\n        groupName = data[\"groupName\"]\r\n        print(name)\r\n        print(desc)\r\n        print(groupName)\r\n        path = easygui.diropenbox(msg=\"Select folder to share as bundle\", title=\"Share Bundle\")\r\n        bundle = bundleManager.createBundle(name, desc, path=path)\r\n        groupManager.addBundle(bundle, groupName)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/selectDownloadLocation', methods=['POST'])\r\ndef selectDownloadLocation():\r\n    if request.method == 'POST':\r\n        path = easygui.diropenbox(msg=\"Select folder to download bundles\", title=\"Select Bundle Download Location\")\r\n        print(path)\r\n        # Update Download Path in Config\r\n        client.DIR_PATH_DOWNLOADS = path\r\n        client.saveConfig()\r\n        # Return path to browser and update it in modal\r\n        return path\r\n\r\n\r\n@app.route('/searchBundles', methods=['POST'])\r\ndef searchBundles():\r\n    # print(\"Search Bundles Route\")\r\n    if request.method == 'POST':\r\n        data = request.form\r\n\r\n        # Get Keywords from search\r\n        keywords = data[\"searchKeyWords\"].split()\r\n        # print(\"Search for :\",keywords)\r\n\r\n        # Get Group\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n\r\n        searchReq = SearchBundleRequest(group.id, keywords)\r\n        responses = []\r\n        # SEND TO ALL PEERS COLLECT RESPONSES AND PRESENT\r\n        for peer in group.peers:\r\n            res = sendRequest(peer[0], 6700, dumps(searchReq))\r\n            # if other peer is responded.\r\n            if res is not False:\r\n                # print(res)\r\n                responses.append([peer[0], res])\r\n            else:\r\n                print(\"No Response from\", peer[0])\r\n        # Merge all responses to single list\r\n        # for x in responses:\r\n        #     print(\"Response:\",x[0],x[1],x[1].responseBundles)\r\n        # WITH RESPONSES DO STUFF.\r\n        # Respond\r\n        return render_template(\"search.html\", groups=groupManager.groups, group=group, responses=responses)\r\n\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n    if groupManager.createGroup(name, [client.publicIP]):\r\n        # Make First Block In Blockchain Append Admin\r\n        # Type 0 First Created\r\n        group = groupManager.getGroupWithName(name)\r\n        group.blockchain.createGenesisBlock(client)\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n\r\n@app.route('/getBundle', methods=['POST'])\r\ndef getBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        bundleId = data[\"bundleId\"]\r\n        groupId = data[\"groupId\"]\r\n        userIp = data[\"userIp\"]\r\n        # TODO dynamic port on receiver for bundle\r\n        portForBundleReceiver = 6701\r\n        bundleReceiver = threading.Thread(target=receiveBundle,\r\n                                          args=[portForBundleReceiver, client, groupManager, groupId, downloadManager])\r\n        bundleReceiver.start()\r\n        getBundleReq = GetBundleRequest(bundleId, groupId, portForBundleReceiver)\r\n        res = sendRequest(userIp, 6700, dumps(getBundleReq))\r\n        # if other peer is responded.\r\n        if res is not False:\r\n            # Responded decide what to do\r\n            pass\r\n        else:\r\n            # print(\"No Response from\", userIp)\r\n            pass\r\n    return \"1\"\r\n\r\n\r\n@app.route('/quitGroup', methods=['POST'])\r\ndef quitGroup():\r\n    # print('QUIT GROUP REQ')\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        if groupManager.quitGroup(group):\r\n            # True\r\n            return \"0\"\r\n        else:\r\n            # False\r\n            return \"1\"\r\n\r\n\r\n@app.route('/banUser', methods=['POST'])\r\ndef banUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.BanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/unbanUser', methods=['POST'])\r\ndef unbanUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.UnbanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/addAdmin', methods=['POST'])\r\ndef addAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.AddAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/removeAdmin', methods=['POST'])\r\ndef removeAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.RemoveAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    groupManager = GroupManager(client)\r\n    bundleManager = BundleManager()\r\n    downloadManager = DownloadManager(groupManager, client)\r\n    # TODO Networking Thread To Receive From Internet\r\n    receiver = threading.Thread(target=receiver, args=[groupManager])\r\n    receiver.start()\r\n    app.run(host='', port=6969)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 397da46c4b816e67fbbc1f8b78f311f5a70ab115)
+++ b/main.py	(date 1650888313838)
@@ -34,7 +34,7 @@
     group = groupManager.getGroupWithName(group)
     # Check if user should see admin panels.
     peers, bans, admins, owner = group.blockchain.parseBlockchain()
-    print(peers,admins,bans)
+    print(peers, admins, bans)
     # Check privs what to show on group page.
     adminPriv = False
     for admin in group.admins:
@@ -50,10 +50,6 @@
     if client.publicIP in peers:
         peers.remove(client.publicIP)
 
-
-
-
-
     return render_template("groups.html", groups=groupManager.groups, group=group, client=client, adminPriv=adminPriv,
                            ownerPriv=ownerPriv, peers=peers, bans=bans, admins=admins)
 
@@ -90,7 +86,6 @@
         return Compress.compress(invite.toJSON())
 
 
-
 @app.route('/deleteBundle', methods=['POST'])
 def deleteBundle():
     if request.method == 'POST':
Index: .idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM_[Changes]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM_[Changes]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM_[Changes]/shelved.patch	(revision 397da46c4b816e67fbbc1f8b78f311f5a70ab115)
+++ /dev/null	(revision 397da46c4b816e67fbbc1f8b78f311f5a70ab115)
@@ -1,650 +0,0 @@
-Index: .idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM_[Changes]/shelved.patch
-===================================================================
-diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM_[Changes]/shelved.patch
-deleted file mode 100644
---- a/.idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM_[Changes]/shelved.patch	(revision e93e724ace85a4e7a5d706e587d82e895584bb85)
-+++ /dev/null	(revision e93e724ace85a4e7a5d706e587d82e895584bb85)
-@@ -1,631 +0,0 @@
--Index: .idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM_[Changes]/shelved.patch
--===================================================================
--diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM_[Changes]/shelved.patch
--deleted file mode 100644
----- a/.idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM_[Changes]/shelved.patch	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--@@ -1,253 +0,0 @@
---Index: .idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM_[Changes]/shelved.patch
---===================================================================
---diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM_[Changes]/shelved.patch
---deleted file mode 100644
------ a/.idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM_[Changes]/shelved.patch	(revision b2a6e34799d5eb81b092421737b71d713c796f3a)
---+++ /dev/null	(revision b2a6e34799d5eb81b092421737b71d713c796f3a)
---@@ -1,234 +0,0 @@
----Index: .idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM__Changes_1.xml
----===================================================================
----diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM__Changes_1.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM__Changes_1.xml
----deleted file mode 100644
------- a/.idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM__Changes_1.xml	(revision af1ab55a3550b7c7081ff28c3debc5801fd1458b)
----+++ /dev/null	(revision af1ab55a3550b7c7081ff28c3debc5801fd1458b)
----@@ -1,4 +0,0 @@
-----<changelist name="Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM_[Changes]1" date="1644986804180" recycled="true" deleted="true">
-----  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM_[Changes]1/shelved.patch" />
-----  <option name="DESCRIPTION" value="Uncommitted changes before Update at 16-Feb-22 6:46 AM [Changes]" />
-----</changelist>
----\ No newline at end of file
----Index: .idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM_[Changes]1/shelved.patch
----===================================================================
----diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM_[Changes]1/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM_[Changes]1/shelved.patch
----deleted file mode 100644
------- a/.idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM_[Changes]1/shelved.patch	(revision af1ab55a3550b7c7081ff28c3debc5801fd1458b)
----+++ /dev/null	(revision af1ab55a3550b7c7081ff28c3debc5801fd1458b)
----@@ -1,215 +0,0 @@
-----Index: p2p.py
-----===================================================================
-----diff --git a/p2p.py b/p2p.py
-----deleted file mode 100644
-------- a/p2p.py	
-----+++ /dev/null	
-----@@ -1,27 +0,0 @@
------from socket import socket, AF_INET, SOCK_DGRAM
------
------
------def server():
------    UDP_PORT = 56700
------    sock = socket(AF_INET, SOCK_DGRAM)
------    sock.bind(("0.0.0.0", UDP_PORT))
------    print(sock.getsockname())
------
------    while True:
------        print("Ready to receive")
------        data, addr = sock.recvfrom(1024)  # buffer size is 1024 bytes
------        print("Received", data, "from", addr)
------
------
------def send():
------
------
------
------if __name__ == "__main__":
------    server()
------
------if __name__ == "__main__":
------    listen()
------
------if __name__ == "__main__":
------    listen()
-----Index: .idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM__Changes_.xml
-----===================================================================
-----diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM__Changes_.xml
-----deleted file mode 100644
-------- a/.idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM__Changes_.xml	
-----+++ /dev/null	
-----@@ -1,4 +0,0 @@
------<changelist name="Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM_[Changes]" date="1644302304744" recycled="true" deleted="true">
------  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM_[Changes]/shelved.patch" />
------  <option name="DESCRIPTION" value="Uncommitted changes before Update at 08-Feb-22 8:38 AM [Changes]" />
------</changelist>
-----\ No newline at end of file
-----Index: .idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM_[Changes]/shelved.patch
-----===================================================================
-----diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM_[Changes]/shelved.patch
-----deleted file mode 100644
-------- a/.idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM_[Changes]/shelved.patch	
-----+++ /dev/null	
-----@@ -1,144 +0,0 @@
------Index: .idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM_[Changes]/shelved.patch
------===================================================================
------diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM_[Changes]/shelved.patch
------deleted file mode 100644
--------- a/.idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM_[Changes]/shelved.patch	(revision 204d08569dda605f981bf96b435bdf1dcd148dab)
------+++ /dev/null	(revision 204d08569dda605f981bf96b435bdf1dcd148dab)
------@@ -1,125 +0,0 @@
-------Index: static/index.css
-------IDEA additional info:
-------Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-------<+>html, body{height: 100%;overflow: hidden;}\r\nbody{\r\n  margin: 0;\r\n  background-image: linear-gradient(to right, #141e30, #243b55);\r\n}
-------Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-------<+>UTF-8
-------===================================================================
-------diff --git a/static/index.css b/static/index.css
---------- a/static/index.css	(revision 4a4d56f622e247ef187bdf310782755e8ce34f5b)
-------+++ b/static/index.css	(date 1643194007877)
-------@@ -1,5 +1,76 @@
------- html, body{height: 100%;overflow: hidden;}
------- body{
--------  margin: 0;
-------+  overflow: hidden;
-------   background-image: linear-gradient(to right, #141e30, #243b55);
-------+}
-------+* {
-------+  margin: 0;
-------+  padding: 0;
-------+  list-style: none;
-------+  font-family: "Lato", sans-serif;
-------+  line-height: 1;
-------+}
-------+
-------+body {
-------+  background-color: #f5f6f8;
-------+  overflow: hidden;
-------+}
-------+
-------+.sidebar-navigation {
-------+  display: inline-block;
-------+  min-height: 100vh;
-------+  width: 80px;
-------+  background-color: #313443;
-------+  float: left;
-------+}
-------+.sidebar-navigation ul {
-------+  text-align: center;
-------+  color: white;
-------+}
-------+.sidebar-navigation ul li {
-------+  padding: 28px 0;
-------+  cursor: pointer;
-------+  transition: all ease-out 120ms;
-------+}
-------+.sidebar-navigation ul li i {
-------+  display: block;
-------+  font-size: 24px;
-------+  transition: all ease 450ms;
-------+}
-------+.sidebar-navigation ul li .tooltip {
-------+  display: inline-block;
-------+  position: absolute;
-------+  background-color: #313443;
-------+  padding: 8px 15px;
-------+  border-radius: 3px;
-------+  margin-top: -26px;
-------+  left: 90px;
-------+  opacity: 0;
-------+  visibility: hidden;
-------+  font-size: 13px;
-------+  letter-spacing: 0.5px;
-------+}
-------+.sidebar-navigation ul li .tooltip:before {
-------+  content: "";
-------+  display: block;
-------+  position: absolute;
-------+  left: -4px;
-------+  top: 10px;
-------+  transform: rotate(45deg);
-------+  width: 10px;
-------+  height: 10px;
-------+  background-color: inherit;
-------+}
-------+.sidebar-navigation ul li:hover {
-------+  background-color: #22252e;
-------+}
-------+.sidebar-navigation ul li:hover .tooltip {
-------+  visibility: visible;
-------+  opacity: 1;
-------+}
-------+.sidebar-navigation ul li.active {
-------+  background-color: #22252e;
-------+}
-------+.sidebar-navigation ul li.active i {
-------+  color: #98d7ec;
------- }
-------\ No newline at end of file
-------Index: templates/index.html
-------IDEA additional info:
-------Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-------<+><!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <!--TODO-->\r\n    <title>p2p toreent app title</title>\r\n    <!--CSS FOR INDEX PAGE-->\r\n    <link rel=\"stylesheet\" href=\"../static/index.css\">\r\n</head>\r\n\r\n<body>\r\n\r\n</body>\r\n\r\n</html>
-------Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-------<+>UTF-8
-------===================================================================
-------diff --git a/templates/index.html b/templates/index.html
---------- a/templates/index.html	(revision 4a4d56f622e247ef187bdf310782755e8ce34f5b)
-------+++ b/templates/index.html	(date 1643192853872)
-------@@ -7,10 +7,23 @@
-------     <title>p2p toreent app title</title>
-------     <!--CSS FOR INDEX PAGE-->
-------     <link rel="stylesheet" href="../static/index.css">
-------+	<!--ICONS-->
-------+	<script src="https://kit.fontawesome.com/c5cd512f5f.js" crossorigin="anonymous"></script>
------- </head>
------- 
------- <body>
--------
-------+	<nav class="sidebar-navigation">
-------+		<ul>
-------+			<li class="active">
-------+				<i class="fa fa-share-alt"></i>
-------+				<span class="tooltip">Connections</span>
-------+			</li>
-------+			<li>
-------+				<i class="fa fa-sliders"></i>
-------+				<span class="tooltip">Settings</span>
-------+			</li>
-------+		</ul>
-------+	</nav>
------- </body>
------- 
------- </html>
-------\ No newline at end of file
------Index: .idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM__Changes_.xml
------===================================================================
------diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM__Changes_.xml
------deleted file mode 100644
--------- a/.idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM__Changes_.xml	(revision 204d08569dda605f981bf96b435bdf1dcd148dab)
------+++ /dev/null	(revision 204d08569dda605f981bf96b435bdf1dcd148dab)
------@@ -1,4 +0,0 @@
-------<changelist name="Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM_[Changes]" date="1643261345007" recycled="true" deleted="true">
-------  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM_[Changes]/shelved.patch" />
-------  <option name="DESCRIPTION" value="Uncommitted changes before Update at 27-Jan-22 7:28 AM [Changes]" />
-------</changelist>
------\ No newline at end of file
-----Index: main.py
-----IDEA additional info:
-----Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-----<+>import json\r\nimport logging\r\nimport threading\r\n\r\nfrom flask import Flask, render_template, request, redirect\r\nimport compress\r\n\r\nfrom Receiver import receiver\r\nfrom Groups import GroupManager\r\nfrom Client import Client\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = False\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    return render_template(\"index.html\", groups=groupManager.groups)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    print(\"Group page request :\", group)\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    return \"fuck\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        print(\"Generate Invite for :\", group)\r\n        # TODO generate group invite\r\n        group = groupManager.getGroup(group)\r\n        jsonPeers = json.dumps(group.peers)\r\n        return compress.compress(jsonPeers)\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        print(\"Join group with Invite:\", invite)\r\n        inviteDecomp = compress.decompress(invite)\r\n        print(\"Peers to try:\", inviteDecomp)\r\n\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n        if data[\"private\"]:\r\n            private = 1\r\n        else:\r\n            private = 0\r\n    if groupManager.createGroup(name, private, [client.publicIP]):\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    # x = threading.Thread(target=receiver)\r\n    # x.start()\r\n    groupManager = GroupManager()\r\n    app.run(host='127.0.0.1', port=6969)\r\n
-----Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-----<+>UTF-8
-----===================================================================
-----diff --git a/main.py b/main.py
-------- a/main.py	
-----+++ b/main.py	
-----@@ -5,7 +5,6 @@
----- from flask import Flask, render_template, request, redirect
----- import compress
----- 
------from Receiver import receiver
----- from Groups import GroupManager
----- from Client import Client
----- 
---Index: .idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM__Changes_.xml
---===================================================================
---diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM__Changes_.xml
---deleted file mode 100644
------ a/.idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM__Changes_.xml	(revision b2a6e34799d5eb81b092421737b71d713c796f3a)
---+++ /dev/null	(revision b2a6e34799d5eb81b092421737b71d713c796f3a)
---@@ -1,4 +0,0 @@
----<changelist name="Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM_[Changes]" date="1646725875130" recycled="true" deleted="true">
----  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM_[Changes]/shelved.patch" />
----  <option name="DESCRIPTION" value="Uncommitted changes before Update at 08-Mar-22 9:51 AM [Changes]" />
----</changelist>
---\ No newline at end of file
--Index: .idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM__Changes_.xml
--===================================================================
--diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM__Changes_.xml
--deleted file mode 100644
----- a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM__Changes_.xml	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--@@ -1,4 +0,0 @@
---<changelist name="Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM_[Changes]" date="1648480562716" recycled="true" deleted="true">
---  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM_[Changes]/shelved.patch" />
---  <option name="DESCRIPTION" value="Uncommitted changes before Update at 28-Mar-22 6:15 PM [Changes]" />
---</changelist>
--\ No newline at end of file
--Index: .idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM__Changes_.xml
--===================================================================
--diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM__Changes_.xml
--deleted file mode 100644
----- a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM__Changes_.xml	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--@@ -1,4 +0,0 @@
---<changelist name="Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM_[Changes]" date="1648484286020" recycled="true" deleted="true">
---  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM_[Changes]/shelved.patch" />
---  <option name="DESCRIPTION" value="Uncommitted changes before Update at 28-Mar-22 7:18 PM [Changes]" />
---</changelist>
--\ No newline at end of file
--Index: .idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM_[Changes]/shelved.patch
--===================================================================
--diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM_[Changes]/shelved.patch
--deleted file mode 100644
----- a/.idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM_[Changes]/shelved.patch	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--@@ -1,58 +0,0 @@
---Index: Networking.py
---IDEA additional info:
---Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
---<+>import socket\r\nfrom socket import *\r\nimport pickle\r\nimport copy\r\nimport Groups\r\nfrom threading import Thread\r\nfrom Groups import Group\r\nimport threading\r\n\r\n\r\nclass Request:\r\n    def __init__(self, type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self, name, timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self, group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\n\r\nclass SearchBundleRequest(Request):\r\n    def __init__(self, groupId, keyword):\r\n        super().__init__(2)\r\n        self.groupID = groupId\r\n        self.keywords = keyword\r\n\r\n\r\nclass SearchBundleResponse(Request):\r\n    def __init__(self, responseBundles):\r\n        super().__init__(2)\r\n        self.responseBundles = responseBundles\r\n\r\nclass GetBundleRequest(Request):\r\n    def __init__(self, bundleId,groupId,portForBundleReceiver):\r\n        super().__init__(3)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.portForBundleReceiver = portForBundleReceiver\r\n\r\n\r\nclass GetBundleResponse(Request):\r\n    def __init__(self,answer):\r\n        super().__init__(3)\r\n        self.answer = answer\r\n\r\n\r\n\r\ndef requestHandler(data, addr, groupManager: Groups.GroupManager):\r\n    req = pickle.loads(data)\r\n    # Response to JoinRequest\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name, req.timestamp)\r\n        # TODO If this is allowed add peer and respond\r\n        # TODO Peer Port\r\n        groupManager.addPeerGroup(req.name, [addr[0]])\r\n        group = groupManager.getGroup(req.name)\r\n        groupCpy = copy.copy(group)\r\n        del groupCpy.bundles\r\n        joinResponse = JoinResponse(groupCpy)\r\n        return pickle.dumps(joinResponse)\r\n\r\n    #Response to search req\r\n    elif req.type == 2:\r\n        # Create The Request again for local use\r\n        req = SearchBundleRequest(req.groupID, req.keywords)\r\n        # Get All Bundles User has\r\n        bundlesOfGroup = groupManager.getGroupWithID(req.groupID).bundles\r\n        # Bundles to reply\r\n        responseBundles = []\r\n        print(responseBundles)\r\n        for bundle in bundlesOfGroup:\r\n            # For each bundle make a single list (bundleKeywords) and search if any of the keywords other user send are in there then send back\r\n            name = bundle.name.split()\r\n            desc = bundle.description.split()\r\n            bundleKeywords = name + desc\r\n            # print(\"Bundle Keywords : \",bundleKeywords)\r\n            # print(\"Request Keywords : \",req.keywords)\r\n            if any(keyword in req.keywords for keyword in bundleKeywords):\r\n                # print(\"HIT\")\r\n                responseBundles.append({\"id\": bundle.id, \"name\": bundle.name, \"description\": bundle.description})\r\n        # Create Response and return it to be used as answer\r\n        # print(responseBundles)\r\n        searchResponse = SearchBundleResponse(responseBundles)\r\n        # print(\"Search Response :\",searchResponse)\r\n        return pickle.dumps(searchResponse)\r\n\r\n    elif req.type == 3:\r\n        req = GetBundleRequest(req.bundleId,req.groupId,req.portForBundleReceiver)\r\n        bundle = groupManager.getGroupWithID(req.groupId).getBundleWithId(req.bundleId)\r\n        bundleReceiver = threading.Thread(target=sendBundle, args=[addr,req.portForBundleReceiver,bundle])\r\n        bundleReceiver.start()\r\n        #TODO refactor use it to determine if user ok to send bundle\r\n        return GetBundleResponse(1)\r\n\r\ndef responseHandler(data, groupManager):\r\n    res = pickle.loads(data)\r\n\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        return res\r\n\r\n    elif res.type == 2:\r\n        res = SearchBundleResponse(res.responseBundles)\r\n        return res\r\n\r\n    elif res.type == 3:\r\n        res = SearchBundleResponse(res.answer)\r\n        return res\r\n\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        # RECEIVE AND RESPOND.\r\n        data, addr = sock.recvfrom(65537)\r\n        # data, addr = sock.recvfrom(65507)\r\n        print(\"Received from :\",addr, \" data:\",data)\r\n        response = requestHandler(data, addr, groupManager)\r\n        sock.sendto(response, addr)\r\n\r\n\r\ndef sendRequest(address, port, request, groupManager):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.settimeout(1)\r\n    try:\r\n        clientSocket.sendto(request, (address, port))\r\n        data, addr = clientSocket.recvfrom(65537)\r\n        # data, addr = clientSocket.recvfrom(65507)\r\n        res = responseHandler(data, groupManager)\r\n        return res\r\n    # TODO except socket.timeout\r\n    # TODO for better exception handling fix later.\r\n    except Exception as exception:\r\n        print(\"Exception on SendRequest:\",exception)\r\n        return False\r\n\r\ndef receiveBundle(port):\r\n    print(\"RECEIVING BUNDLE THREAD\")\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.bind((\"0.0.0.0\", port))\r\n        print(\"Bundle Receiver Ready\")\r\n        s.listen()\r\n        conn, addr = s.accept()\r\n        with conn:\r\n            print(f\"Connected by {addr}\")\r\n            while True:\r\n                data = conn.recv(1024)\r\n                if not data:\r\n                    break\r\n                conn.sendall(data)\r\n\r\ndef sendBundle(addr,port,bundle):\r\n    print(\"SENDING BUNDLE THREAD\")\r\n    with socket(AF_INET,SOCK_STREAM) as s:\r\n        s.bind((addr, port))\r\n        print(\"Bundle Receiver Ready\")\r\n        s.listen()\r\n        conn, addr = s.accept()\r\n        with conn:\r\n            print(f\"Connected by {addr}\")\r\n            while True:\r\n                data = conn.recv(1024)\r\n                if not data:\r\n                    break\r\n                conn.sendall(data)
---Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
---<+>UTF-8
---===================================================================
---diff --git a/Networking.py b/Networking.py
------ a/Networking.py	(revision ae247badae8c55d3e507e1fa37f4599871c48816)
---+++ b/Networking.py	(date 1648747293775)
---@@ -101,7 +101,7 @@
---         bundleReceiver = threading.Thread(target=sendBundle, args=[addr,req.portForBundleReceiver,bundle])
---         bundleReceiver.start()
---         #TODO refactor use it to determine if user ok to send bundle
----        return GetBundleResponse(1)
---+        return pickle.dumps(GetBundleResponse(1))
--- 
--- def responseHandler(data, groupManager):
---     res = pickle.loads(data)
---@@ -115,7 +115,7 @@
---         return res
--- 
---     elif res.type == 3:
----        res = SearchBundleResponse(res.answer)
---+        res = GetBundleResponse(res.answer)
---         return res
--- 
--- 
---@@ -167,15 +167,15 @@
--- 
--- def sendBundle(addr,port,bundle):
---     print("SENDING BUNDLE THREAD")
----    with socket(AF_INET,SOCK_STREAM) as s:
----        s.bind((addr, port))
----        print("Bundle Receiver Ready")
----        s.listen()
----        conn, addr = s.accept()
----        with conn:
----            print(f"Connected by {addr}")
----            while True:
----                data = conn.recv(1024)
----                if not data:
----                    break
----                conn.sendall(data)
---\ No newline at end of file
---+    # with socket(AF_INET,SOCK_STREAM) as s:
---+    #     s.bind(addr, port)
---+    #     print("Bundle Receiver Ready")
---+    #     s.listen()
---+    #     conn, addr = s.accept()
---+    #     with conn:
---+    #         print(f"Connected by {addr}")
---+    #         while True:
---+    #             data = conn.recv(1024)
---+    #             if not data:
---+    #                 break
---+    #             conn.sendall(data)
---\ No newline at end of file
--Index: .idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM__Changes_.xml
--===================================================================
--diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM__Changes_.xml
--deleted file mode 100644
----- a/.idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM__Changes_.xml	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--@@ -1,4 +0,0 @@
---<changelist name="Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM_[Changes]" date="1648290013718" recycled="true" deleted="true">
---  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM_[Changes]/shelved.patch" />
---  <option name="DESCRIPTION" value="Uncommitted changes before Update at 26-Mar-22 12:20 PM [Changes]" />
---</changelist>
--\ No newline at end of file
--Index: .idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM__Changes_.xml
--===================================================================
--diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM__Changes_.xml
--deleted file mode 100644
----- a/.idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM__Changes_.xml	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--@@ -1,4 +0,0 @@
---<changelist name="Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM_[Changes]" date="1648817514293" recycled="true" deleted="true">
---  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM_[Changes]/shelved.patch" />
---  <option name="DESCRIPTION" value="Uncommitted changes before Update at 01-Apr-22 3:51 PM [Changes]" />
---</changelist>
--\ No newline at end of file
--Index: .idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM_[Changes]/shelved.patch
--===================================================================
--diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM_[Changes]/shelved.patch
--deleted file mode 100644
----- a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM_[Changes]/shelved.patch	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--@@ -1,20 +0,0 @@
---Index: Networking.py
---IDEA additional info:
---Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
---<+>import socket\r\nfrom socket import *\r\nimport pickle\r\nimport copy\r\nimport Groups\r\nfrom Groups import Group\r\n\r\n\r\nclass Request:\r\n    def __init__(self,type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self,name,timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self,group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\nclass SearchBundleRequest(Request):\r\n    def __init__(self, groupId, keyword):\r\n        super().__init__(2)\r\n        self.groupID = groupId\r\n        self.keywords = keyword\r\n\r\nclass SearchBundleResponse(Request):\r\n    def __init__(self,groups):\r\n        super().__init__(2)\r\n        self.responseBundles = groups\r\n\r\ndef requestHandler(data, addr, groupManager: Groups.GroupManager):\r\n    req = pickle.loads(data)\r\n    # Response to JoinRequest\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name,req.timestamp)\r\n        #TODO If this is allowed add peer and respond\r\n        #TODO Peer Port\r\n        groupManager.addPeerGroup(req.name,[addr[0]])\r\n        group = groupManager.getGroup(req.name)\r\n        groupCpy = copy.copy(group)\r\n        del groupCpy.bundles\r\n        joinResponse = JoinResponse(groupCpy)\r\n        return pickle.dumps(joinResponse)\r\n\r\n    elif req.type == 2:\r\n        #Create The Request again for local use\r\n        req = SearchBundleRequest(req.groupID,req.keywords)\r\n        #Get All Bundles User has\r\n        bundlesOfGroup = groupManager.getGroupWithID(req.groupID).bundles\r\n        #Bundles to reply\r\n        responseBundles = []\r\n        for bundle in bundlesOfGroup:\r\n            #For each bundle make a single list (bundleKeywords) and search if any of the keywords other user send are in there then send back\r\n            name = bundle.name.split()\r\n            desc = bundle.description.split()\r\n            bundleKeywords = name + desc\r\n            if any(keyword in req.keywords for keyword in bundleKeywords):\r\n                responseBundles.append({\"id\":bundle.id,\"name\":bundle.name,\"description\":bundle.description})\r\n        #Create Response and return it to be used as answer\r\n        searchResponse = SearchBundleResponse(responseBundles)\r\n        return addr,pickle.dumps(searchResponse)\r\n\r\ndef responseHandler(data, groupManager):\r\n    res = pickle.loads(data)\r\n\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        return res\r\n\r\n    elif res.type == 2:\r\n        res = SearchBundleResponse(res.responseBundles)\r\n        return res\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        #RECEIVE AND RESPOND.\r\n        data, addr = sock.recvfrom(65507)\r\n        print(addr,data)\r\n        response = requestHandler(data,addr,groupManager)\r\n        sock.sendto(response,addr)\r\n\r\ndef sendRequest(address, port, request,groupManager):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.settimeout(1)\r\n    try:\r\n        clientSocket.sendto(request, (address, port))\r\n        data, addr = clientSocket.recvfrom(65507)\r\n        res =  responseHandler(data, addr, groupManager)\r\n    #TODO except socket.timeout\r\n    #TODO for better exception handling fix later.\r\n    except:\r\n        return False\r\n\r\n\r\n\r\n\r\n\r\n\r\n
---Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
---<+>UTF-8
---===================================================================
---diff --git a/Networking.py b/Networking.py
------ a/Networking.py	(revision eb1af266a92df274ea941fc2d7650a768d83cbcb)
---+++ b/Networking.py	(date 1648483944905)
---@@ -101,7 +101,8 @@
---         res =  responseHandler(data, addr, groupManager)
---     #TODO except socket.timeout
---     #TODO for better exception handling fix later.
----    except:
---+    except Exception as e:
---+        print(e)
---         return False
--- 
--- 
--Index: .idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM_[Changes]/shelved.patch
--===================================================================
--diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM_[Changes]/shelved.patch
--deleted file mode 100644
----- a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM_[Changes]/shelved.patch	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--@@ -1,119 +0,0 @@
---Index: main.py
---IDEA additional info:
---Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
---<+>import json\r\nfrom json import *\r\nimport logging\r\nimport threading\r\nfrom pickle import dumps, loads\r\nfrom flask import Flask, render_template, request, redirect\r\nimport compress\r\nfrom Networking import receiver, sendRequest, JoinRequest\r\nfrom Groups import GroupManager, Invite\r\nfrom Client import Client\r\nimport easygui\r\nfrom bundles import BundleManager\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = False\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    return render_template(\"index.html\", groups=groupManager.groups)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    print(\"Group page request :\", group)\r\n    group = groupManager.getGroup(group)\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    # TODO Start downloading\r\n    return \"alright\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        print(str(group))\r\n        # TODO IP SPECIFIC BLOCKCHAIN\r\n        ip = data[\"ip\"]\r\n        print(\"Generate Invite for :\", group)\r\n        group = groupManager.getGroup(group)\r\n        print(group)\r\n        invite = group.generateInvite()\r\n        return compress.compress(invite.toJSON())\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        inviteDecomp = compress.decompress(invite)\r\n        inviteLoad = json.loads(inviteDecomp)\r\n        invite = Invite(inviteLoad[\"id\"],inviteLoad[\"name\"], inviteLoad[\"timestamp\"], inviteLoad[\"peers\"])\r\n        joinReq = JoinRequest(invite.name, invite.timestamp)\r\n        # TODO PORTS\r\n        print(invite.peers)\r\n        for peer in invite.peers:\r\n            print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq), groupManager)\r\n            group = res.group\r\n            group = Groups.Group(group.name,group.private,group.admins,group.peers,group.timestamp)\r\n            groupManager.addGroup(group)\r\n        return \"1\"\r\n\r\n\r\n@app.route('/shareBundle', methods=['POST'])\r\ndef shareBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"bundleName\"]\r\n        desc = data[\"bundleDescription\"]\r\n        groupName = data[\"groupName\"]\r\n        print(name)\r\n        print(desc)\r\n        print(groupName)\r\n        path = easygui.diropenbox(msg=\"Select folder to share as bundle\", title=\"Share Bundle\")\r\n        bundle = bundleManager.createBundle(name,desc,path=path)\r\n        groupManager.addBundle(bundle,groupName)\r\n        return \"0\"\r\n\r\n@app.route('/searchBundles', methods=['POST'])\r\ndef searchBundles():\r\n    print(\"Search Bundles Route\")\r\n    if request.method == 'POST':\r\n        data = request.form\r\n\r\n        #Get Keywords from search\r\n        keywords = data[\"searchKeyWords\"].split()\r\n        print(keywords)\r\n\r\n        #Get Group\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroup(group)\r\n        print(group)\r\n\r\n        joinReq = SearchBundleRequest(group.id,keywords)\r\n        responses = []\r\n        for peer in group.peers:\r\n            print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq), groupManager)\r\n            responses.append(res)\r\n        #WITH RESPONSES DO STUFF.\r\n        for x in responses:\r\n            print(x)\r\n\r\n\r\n\r\n\r\n        #Respond\r\n        return render_template(\"search.html\", groups=groupManager.groups, group=group)\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n        if data[\"private\"]:\r\n            private = 1\r\n        else:\r\n            private = 0\r\n    if groupManager.createGroup(name, private, [client.publicIP]):\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n\r\n@app.route('/quitGroup', methods=['POST'])\r\ndef quitGroup():\r\n    print('QUIT GROUP REQ')\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        if groupManager.quitGroup(group):\r\n            # True\r\n            return \"0\"\r\n        else:\r\n            # False\r\n            return \"1\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    groupManager = GroupManager()\r\n    bundleManager = BundleManager()\r\n    receiver = threading.Thread(target=receiver, args=[groupManager])\r\n    receiver.start()\r\n    app.run(host='', port=6969)\r\n
---Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
---<+>UTF-8
---===================================================================
---diff --git a/main.py b/main.py
------ a/main.py	(revision f0294b2ecb648f959712af555b1864294106d67c)
---+++ b/main.py	(date 1648481256246)
---@@ -5,8 +5,8 @@
--- from pickle import dumps, loads
--- from flask import Flask, render_template, request, redirect
--- import compress
----from Networking import receiver, sendRequest, JoinRequest
----from Groups import GroupManager, Invite
---+from Networking import receiver, sendRequest, JoinRequest, SearchBundleRequest
---+from Groups import GroupManager, Invite, Group
--- from Client import Client
--- import easygui
--- from bundles import BundleManager
---@@ -62,7 +62,7 @@
---         invite = data["invite"]
---         inviteDecomp = compress.decompress(invite)
---         inviteLoad = json.loads(inviteDecomp)
----        invite = Invite(inviteLoad["id"],inviteLoad["name"], inviteLoad["timestamp"], inviteLoad["peers"])
---+        invite = Invite(inviteLoad["id"], inviteLoad["name"], inviteLoad["timestamp"], inviteLoad["peers"])
---         joinReq = JoinRequest(invite.name, invite.timestamp)
---         # TODO PORTS
---         print(invite.peers)
---@@ -70,7 +70,7 @@
---             print(peer[0])
---             res = sendRequest(peer[0], 6700, dumps(joinReq), groupManager)
---             group = res.group
----            group = Groups.Group(group.name,group.private,group.admins,group.peers,group.timestamp)
---+            group = Group(group.name, group.private, group.admins, group.peers, group.timestamp)
---             groupManager.addGroup(group)
---         return "1"
--- 
---@@ -86,41 +86,40 @@
---         print(desc)
---         print(groupName)
---         path = easygui.diropenbox(msg="Select folder to share as bundle", title="Share Bundle")
----        bundle = bundleManager.createBundle(name,desc,path=path)
----        groupManager.addBundle(bundle,groupName)
---+        bundle = bundleManager.createBundle(name, desc, path=path)
---+        groupManager.addBundle(bundle, groupName)
---         return "0"
--- 
---+
--- @app.route('/searchBundles', methods=['POST'])
--- def searchBundles():
---     print("Search Bundles Route")
---     if request.method == 'POST':
---         data = request.form
--- 
----        #Get Keywords from search
---+        # Get Keywords from search
---         keywords = data["searchKeyWords"].split()
---         print(keywords)
--- 
----        #Get Group
---+        # Get Group
---         group = data["group"]
---         group = groupManager.getGroup(group)
---         print(group)
--- 
----        joinReq = SearchBundleRequest(group.id,keywords)
---+        joinReq = SearchBundleRequest(group.id, keywords)
---         responses = []
---         for peer in group.peers:
---             print(peer[0])
---             res = sendRequest(peer[0], 6700, dumps(joinReq), groupManager)
---             responses.append(res)
----        #WITH RESPONSES DO STUFF.
---+        # WITH RESPONSES DO STUFF.
---         for x in responses:
----            print(x)
----
----
----
---+            print("Response:",x)
--- 
----        #Respond
---+        # Respond
---         return render_template("search.html", groups=groupManager.groups, group=group)
--- 
---+
--- @app.route('/createGroup', methods=['POST'])
--- def createGroup():
---     if request.method == 'POST':
---Index: Networking.py
---IDEA additional info:
---Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
---<+>import socket\r\nfrom socket import *\r\nimport pickle\r\nimport copy\r\nimport Groups\r\nfrom Groups import Group\r\n\r\n\r\nclass Request:\r\n    def __init__(self,type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self,name,timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self,group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\nclass SearchBundleRequest(Request):\r\n    def __init__(self, groupId, keyword):\r\n        super().__init__(2)\r\n        self.groupID = groupId\r\n        self.keywords = keyword\r\n\r\nclass SearchBundleResponse(Request):\r\n    def __init__(self,groups):\r\n        super().__init__(2)\r\n        self.responseBundles = responseBundles\r\n\r\ndef requestHandler(data, addr, groupManager: Groups.GroupManager):\r\n    req = pickle.loads(data)\r\n    # Response to JoinRequest\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name,req.timestamp)\r\n        #TODO If this is allowed add peer and respond\r\n        #TODO Peer Port\r\n        groupManager.addPeerGroup(req.name,[addr[0]])\r\n        group = groupManager.getGroup(req.name)\r\n        groupCpy = copy.copy(group)\r\n        del groupCpy.bundles\r\n        joinResponse = JoinResponse(groupCpy)\r\n        return pickle.dumps(joinResponse)\r\n\r\n    elif req.type == 2:\r\n        #Create The Request again for local use\r\n        req = SearchBundleRequest(req.groupID,req.keywords)\r\n        #Get All Bundles User has\r\n        bundlesOfGroup = groupManager.getGroupWithID(req.groupID).bundles\r\n        #Bundles to reply\r\n        responseBundles = []\r\n        for bundle in bundlesOfGroup:\r\n            #For each bundle make a single list (bundleKeywords) and search if any of the keywords other user send are in there then send back\r\n            name = bundle.name.split()\r\n            desc = bundle.description.split()\r\n            bundleKeywords = name + desc\r\n            if any(keyword in req.keywords for keyword in bundleKeywords):\r\n                responseBundles.append({\"id\":bundle.id,\"name\":bundle.name,\"description\":bundle.description})\r\n        #Create Response and return it to be used as answer\r\n        searchResponse = SearchBundleResponse(responseBundles)\r\n        return pickle.dumps(joinResponse)\r\n\r\ndef responseHandler(data, groupManager):\r\n    res = pickle.loads(data)\r\n\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        # group = res.group\r\n        # group = Groups.Group(group.name,group.private,group.admins,group.peers,group.timestamp)\r\n        # groupManager.addGroup(group)\r\n        return res\r\n\r\n    elif res.type == 2:\r\n        res = SearchBundleResponse(res.responseBundles)\r\n        return res\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        #RECEIVE AND RESPOND.\r\n        data, addr = sock.recvfrom(65507)\r\n        print(addr,data)\r\n        response = requestHandler(data,addr,groupManager)\r\n        sock.sendto(response,addr)\r\n\r\ndef sendRequest(address, port, request,groupManager):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.sendto(request, (address, port))\r\n    data, addr = clientSocket.recvfrom(65507)\r\n    return responseHandler(data, groupManager)\r\n\r\n\r\n\r\n
---Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
---<+>UTF-8
---===================================================================
---diff --git a/Networking.py b/Networking.py
------ a/Networking.py	(revision f0294b2ecb648f959712af555b1864294106d67c)
---+++ b/Networking.py	(date 1648481013611)
---@@ -31,7 +31,7 @@
---         self.keywords = keyword
--- 
--- class SearchBundleResponse(Request):
----    def __init__(self,groups):
---+    def __init__(self,responseBundles):
---         super().__init__(2)
---         self.responseBundles = responseBundles
--- 
---@@ -65,7 +65,7 @@
---                 responseBundles.append({"id":bundle.id,"name":bundle.name,"description":bundle.description})
---         #Create Response and return it to be used as answer
---         searchResponse = SearchBundleResponse(responseBundles)
----        return pickle.dumps(joinResponse)
---+        return pickle.dumps(searchResponse)
--- 
--- def responseHandler(data, groupManager):
---     res = pickle.loads(data)
--Index: .idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM__Changes_.xml
--===================================================================
--diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM__Changes_.xml
--deleted file mode 100644
----- a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM__Changes_.xml	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--@@ -1,4 +0,0 @@
---<changelist name="Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM_[Changes]" date="1648483827008" recycled="true" deleted="true">
---  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM_[Changes]/shelved.patch" />
---  <option name="DESCRIPTION" value="Uncommitted changes before Update at 28-Mar-22 7:10 PM [Changes]" />
---</changelist>
--\ No newline at end of file
--Index: .idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM_[Changes]/shelved.patch
--===================================================================
--diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM_[Changes]/shelved.patch
--deleted file mode 100644
----- a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM_[Changes]/shelved.patch	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
--@@ -1,86 +0,0 @@
---Index: Networking.py
---IDEA additional info:
---Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
---<+>import socket\r\nfrom socket import *\r\nimport pickle\r\n\r\nimport Groups\r\n\r\n\r\nclass Request:\r\n    def __init__(self,type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self,name,timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self,group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\ndef requestHandler(data,addr,groupManager):\r\n    req = pickle.loads(data)\r\n    # Response to JoinRequest\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name,req.timestamp)\r\n        #TODO If this is allowed add peer and respond\r\n        #TODO Peer Port\r\n        groupManager.addPeerGroup(req.name,[addr[0]])\r\n        group = groupManager.getGroup(req.name)\r\n        return pickle.dumps(JoinResponse(group))\r\n\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        #RECEIVE AND RESPOND.\r\n        data, addr = sock.recvfrom(65507)\r\n        print(addr,data)\r\n        response = requestHandler(data,addr,groupManager)\r\n        sock.sendto(response,addr)\r\n\r\ndef sendRequest(address, port, request,groupManager):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.sendto(request, (address, port))\r\n    data, addr = clientSocket.recvfrom(65507)\r\n    responseHandler(data, groupManager)\r\n\r\ndef responseHandler(data, groupManager):\r\n    res = pickle.loads(data)\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        group = res.group\r\n        group = Groups.Group(group.name,group.private,group.admins,group.peers,group.timestamp)\r\n        groupManager.addGroup(group)\r\n\r\n
---Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
---<+>UTF-8
---===================================================================
---diff --git a/Networking.py b/Networking.py
------ a/Networking.py	(revision ab00bc1ff0d34c4135e74773e70cb04511a4b41c)
---+++ b/Networking.py	(date 1648291091876)
---@@ -6,31 +6,34 @@
--- 
--- 
--- class Request:
----    def __init__(self,type):
---+    def __init__(self, type):
---         self.type = type
--- 
---     def toJSON(self):
---         return json.dumps(self.__dict__)
--- 
---+
--- class JoinRequest(Request):
----    def __init__(self,name,timestamp):
---+    def __init__(self, name, timestamp):
---         super().__init__(1)
---         self.name = name
---         self.timestamp = timestamp
--- 
---+
--- class JoinResponse(Request):
----    def __init__(self,group):
---+    def __init__(self, group):
---         super().__init__(1)
---         self.group = group
--- 
----def requestHandler(data,addr,groupManager):
---+
---+def requestHandler(data, addr, groupManager):
---     req = pickle.loads(data)
---     # Response to JoinRequest
---     if req.type == 1:
----        req = JoinRequest(req.name,req.timestamp)
----        #TODO If this is allowed add peer and respond
----        #TODO Peer Port
----        groupManager.addPeerGroup(req.name,[addr[0]])
---+        req = JoinRequest(req.name, req.timestamp)
---+        # TODO If this is allowed add peer and respond
---+        # TODO Peer Port
---+        groupManager.addPeerGroup(req.name, [addr[0]])
---         group = groupManager.getGroup(req.name)
---         return pickle.dumps(JoinResponse(group))
--- 
---@@ -42,24 +45,25 @@
---     sock.bind((UDP_IP, UDP_PORT))
---     print("Listening on ", UDP_IP, ":", UDP_PORT)
---     while True:
----        #RECEIVE AND RESPOND.
---+        # RECEIVE AND RESPOND.
---         data, addr = sock.recvfrom(65507)
----        print(addr,data)
----        response = requestHandler(data,addr,groupManager)
----        sock.sendto(response,addr)
---+        print(addr, data)
---+        response = requestHandler(data, addr, groupManager)
---+        sock.sendto(response, addr)
--- 
----def sendRequest(address, port, request,groupManager):
---+
---+def sendRequest(address, port, request, groupManager):
---     # Create a socket for sending files
---     clientSocket = socket(AF_INET, SOCK_DGRAM)
---     clientSocket.sendto(request, (address, port))
---     data, addr = clientSocket.recvfrom(65507)
---     responseHandler(data, groupManager)
--- 
---+
--- def responseHandler(data, groupManager):
---     res = pickle.loads(data)
---     if res.type == 1:
---         res = JoinResponse(res.group)
---         group = res.group
----        group = Groups.Group(group.name,group.private,group.admins,group.peers,group.timestamp)
---+        group = Groups.Group(group.name, group.private, group.admins, group.peers, group.timestamp)
---         groupManager.addGroup(group)
----
-Index: .idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM__Changes_.xml
-===================================================================
-diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM__Changes_.xml
-deleted file mode 100644
---- a/.idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM__Changes_.xml	(revision e93e724ace85a4e7a5d706e587d82e895584bb85)
-+++ /dev/null	(revision e93e724ace85a4e7a5d706e587d82e895584bb85)
-@@ -1,4 +0,0 @@
--<changelist name="Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM_[Changes]" date="1649508066242" recycled="true" deleted="true">
--  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM_[Changes]/shelved.patch" />
--  <option name="DESCRIPTION" value="Uncommitted changes before Update at 09-Apr-22 3:41 PM [Changes]" />
--</changelist>
-\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM__Changes_.xml	(revision 397da46c4b816e67fbbc1f8b78f311f5a70ab115)
+++ /dev/null	(revision 397da46c4b816e67fbbc1f8b78f311f5a70ab115)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM_[Changes]" date="1650197252334" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 17-Apr-22 3:07 PM [Changes]" />
-</changelist>
\ No newline at end of file
