Index: Blockchain.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import math\r\nimport os\r\nimport json\r\nfrom os import listdir\r\nimport rsa\r\nimport time\r\nfrom time import sleep\r\nimport threading\r\nfrom hashlib import sha256\r\nimport copy\r\nfrom pickle import dumps, loads\r\n\r\n\r\nclass Block:\r\n    def __init__(self, index, transaction, timestamp, previous_hash, signatures):\r\n        self.index = index\r\n\r\n        self.transaction = transaction\r\n\r\n        self.timestamp = timestamp\r\n\r\n        self.previous_hash = previous_hash\r\n\r\n        self.signatures = signatures\r\n\r\n    def computeHash(self):\r\n        mycopy = copy.copy(self)\r\n        del mycopy.signatures\r\n        # print(mycopy.__dict__)\r\n        if hasattr(mycopy, 'hash'):\r\n            del mycopy.hash\r\n        block_string = json.dumps(mycopy.__dict__, sort_keys=True)\r\n        return sha256(block_string.encode()).hexdigest()\r\n\r\n\r\nclass UnconfirmedTransaction:\r\n    def __init__(self, transaction, signatures=[]):\r\n        self.transaction = transaction\r\n        self.signatures = signatures\r\n\r\n\r\nclass GenesisTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 0\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass InviteTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 1\r\n        self.ip = ip\r\n\r\n\r\nclass JoinTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 2\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass BanTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 3\r\n        self.ip = ip\r\n\r\n\r\nclass UnbanTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 4\r\n        self.ip = ip\r\n\r\n\r\nclass AddAdminTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 5\r\n        self.ip = ip\r\n\r\n\r\nclass RemoveAdminTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 6\r\n        self.ip = ip\r\n\r\n\r\nclass Blockchain:\r\n    def __init__(self, path, groupPeers, groupAdmins, groupId, client):\r\n        self.BLOCKCHAIN_PATH = path\r\n        self.TRANSACTION_PATH = self.BLOCKCHAIN_PATH + \"\\\\Transactions\\\\\"\r\n        self.unconfirmed_transactions = []\r\n        self.chain = []\r\n        self.peers = groupPeers\r\n        self.groupId = groupId\r\n        self.groupAdmins = groupAdmins\r\n        self.client = client\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n            # Load Unconfirmed Transactions\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n\r\n        self.loadTransactions()\r\n\r\n        # print(self.unconfirmed_transactions)\r\n        # Load Blocks here\r\n        blockFiles = [f for f in listdir(self.BLOCKCHAIN_PATH) if os.path.isfile(os.path.join(self.BLOCKCHAIN_PATH, f))]\r\n        for blockFile in blockFiles:\r\n            self.loadBlock(blockFile)\r\n\r\n        # Start Casual Operations.\r\n        # Thread This.\r\n        miner = threading.Thread(target=self.mine, args=[client])\r\n        miner.start()\r\n        # print(self.unconfirmed_transactions)\r\n        # for block in self.chain:\r\n        #     print(block)\r\n\r\n    def getDifficulty(self):\r\n        # Diffuculty of blockchain will be dependent on the users participating in  --->log2(peers)\r\n        return 2\r\n        if len(self.peers) == 0:\r\n            return 1\r\n        else:\r\n            peers, bans, admins, owner = self.parseBlockchain()\r\n            return math.floor(math.log2(len(peers)))\r\n\r\n    def createGenesisBlock(self, client):\r\n        transaction = GenesisTransaction(client.publicIP, client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        # this is string json format\r\n        # print(transactionStr)\r\n        # print(transactionStr.__class__)\r\n        # Genereate signature for Transaction\r\n        signature = rsa.sign(transactionStr.encode(), client.privateKey, 'SHA-1')\r\n        genesis_block = Block(0, transactionStr, str(time.time()), \"0\", [client.publicIP,str(signature)])\r\n        genesis_block.hash = genesis_block.computeHash()\r\n        self.saveBlock(genesis_block)\r\n        self.chain.append(genesis_block)\r\n\r\n    def verifyTransaction(self,transaction):\r\n        #TODO verify transactions.\r\n        return True\r\n\r\n    def saveBlock(self, block):\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Creating Blockchain Folder\")\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n        blockFile = open(self.BLOCKCHAIN_PATH + \"\\\\Block\" + str(block.index) + \".json\", \"w\")\r\n        # print(block.__dict__)\r\n        blockFile.write(json.dumps(block.__dict__))\r\n        blockFile.close()\r\n\r\n    def loadTransactions(self):\r\n        filePath = self.TRANSACTION_PATH + \"Transactions.json\"\r\n        if os.path.exists(filePath):\r\n            try:\r\n                file = open(filePath)\r\n                # print(file)\r\n                json_load_group = json.load(file)\r\n                file.close()\r\n            except Exception as e:\r\n                print(\"Error Opening Transaction file :\", e)\r\n            for x in json_load_group:\r\n                transaction = UnconfirmedTransaction(x[\"transaction\"], x[\"signatures\"])\r\n                # print(transaction)\r\n                self.unconfirmed_transactions.append(transaction)\r\n            # print(self.unconfirmed_transactions)\r\n\r\n    def loadBlock(self, blockFiles):\r\n        # print(blockFiles)\r\n        filePath = self.BLOCKCHAIN_PATH + \"\\\\\" + blockFiles\r\n        file = open(filePath)\r\n        # print(file)\r\n        block = json.load(file)\r\n        file.close()\r\n        # # print(block)\r\n        # transaction = json.loads(block[\"transaction\"])\r\n        # # print(transaction)\r\n        # # print(transaction.__class__)\r\n        # # Make transaction here\r\n        # if transaction[\"type\"] == 0:\r\n        #     # print(\"Genesis block\")\r\n        #     transactionObj = GenesisTransaction(transaction[\"ip\"], transaction[\"publicKey\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        blockObj = Block(block[\"index\"], block[\"transaction\"], block[\"timestamp\"], block[\"previous_hash\"],\r\n                         block[\"signatures\"])\r\n        blockObj.hash = block[\"hash\"]\r\n        # elif transaction[\"type\"] == 1:\r\n        #     # print(\"Genesis block\")\r\n        #     # print(transaction)\r\n        #     transactionObj = InviteTransaction(transaction[\"ip\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        #     blockObj = Block(block[\"index\"], transactionStr, block[\"timestamp\"], block[\"previous_hash\"],\r\n        #                      block[\"signatures\"])\r\n        #     blockObj.hash = block[\"hash\"]\r\n\r\n        self.chain.append(blockObj)\r\n        # print(blockObj.__dict__)\r\n\r\n    def addNewTransaction(self, transaction: str):\r\n        newUnconfirmedTransaction = UnconfirmedTransaction(transaction)\r\n        self.unconfirmed_transactions.append(newUnconfirmedTransaction)\r\n        self.saveUnconfirmedTransactions()\r\n\r\n    def updateBlockchain(self, client):\r\n        for peer in self.peers:\r\n            # Dont send to self\r\n            if peer[0] != client.publicIP:\r\n                # For each peer ask their max index of blockchain\r\n                updateBlockchainReq = Networking.UpdateBlockchainRequest(self.groupId)\r\n                res = Networking.sendRequest(peer[0], 6700, dumps(updateBlockchainReq))\r\n                if res is not False:\r\n                    # if the response is bigger than me ask him for his block until we are at the same.\r\n                    if res.answer > self.getLastBlockIndex():\r\n                        print(self.getLastBlockIndex().__class__, res.answer.__class__)\r\n                        while self.getLastBlockIndex() < res.answer:\r\n                            # Get block\r\n                            getBlockReq = Networking.GetBlockRequest(self.groupId, self.getLastBlockIndex() + 1)\r\n                            blockRes = Networking.sendRequest(peer[0], 6700, dumps(getBlockReq))\r\n                            if blockRes is not False:\r\n                                print(f\"Update BC Response:{blockRes}\")\r\n                                # print(blockRes.answer)\r\n                                block = blockRes.answer\r\n                                block: Block\r\n                                print(block.index, block.transaction, block.signatures, block.timestamp,\r\n                                      block.previous_hash, block.hash)\r\n                                newBlock = Block(block.index, block.transaction, block.timestamp, block.previous_hash,\r\n                                                 block.signatures)\r\n                                newBlock.hash = block.hash\r\n                                if self.validateNewBlock(newBlock):\r\n                                    self.saveBlock(newBlock)\r\n                                    self.chain.append(newBlock)\r\n                            else:\r\n                                break\r\n                    else:\r\n                        # print(id(self.peers))\r\n                        peers, bans, admins, owner = self.parseBlockchain()\r\n                        # self.peers = peers\r\n                        # self.groupAdmins = admins\r\n                        # print(id(self.peers))\r\n                        # print(\"Blockchain Updated And Parsed\")\r\n                        # print(\"Up-to-date.\")\r\n                        pass\r\n\r\n        #Update Group Peers And Admins\r\n        peers, bans, admins, owner = self.parseBlockchain()\r\n        for ip in admins:\r\n            inside = False\r\n            for admin in self.groupAdmins:\r\n                if admin[0]==ip:\r\n                    inside = True\r\n            if not inside:\r\n                self.groupAdmins.append([ip])\r\n\r\n\r\n        for ip in peers:\r\n            inside = False\r\n            for peer in self.peers:\r\n                if peer[0]==ip:\r\n                    inside = True\r\n            if not inside:\r\n                self.peers.append([ip])\r\n\r\n\r\n    def getBlockWithIndex(self, index):\r\n        for block in self.chain:\r\n            block: Block\r\n            if block.index == index:\r\n                return block\r\n        return False\r\n\r\n    def validateNewBlock(self, newBlock):\r\n        \"\"\"This function is for new blocks that come from peers returns true if blocks checks out.\"\"\"\r\n        newBlock: Block\r\n\r\n        # If hash ok.\r\n        if newBlock.computeHash() == newBlock.hash:\r\n            # Validation for genesis block\r\n            if newBlock.index == 0:\r\n                if self.getLastBlockIndex() == -1:\r\n                    # No other blocks accept it.\r\n                    return True\r\n                else:\r\n                    return False\r\n            else:\r\n                # Check if new block is made with the same previous block.\r\n                # TODO if not resolve ?\r\n                if newBlock.previous_hash == self.getLastBlock().computeHash():\r\n                    # TODO check if signatures okay.\r\n                    # TODO check timestamp.\r\n                    # TODO check difficulty based on blockchain etc.\r\n                    return True\r\n\r\n    def mine(self, client):\r\n        while True:\r\n            # Update Blockchain.\r\n            self.updateBlockchain(client)\r\n            if not self.unconfirmed_transactions:\r\n                # If No Transaction sleep and check again soon.\r\n                sleep(30)\r\n            else:\r\n                diff = self.getDifficulty()\r\n                print(f\"Blockchain Difficulty :{diff}\")\r\n                print(f\"Unconfirmed Transactions:{len(self.unconfirmed_transactions)}\")\r\n                for transaction in self.unconfirmed_transactions:\r\n                    transaction: UnconfirmedTransaction\r\n                    # For Each Transaction if signatures < difficulty collect transactions\r\n                    if diff > len(transaction.signatures):\r\n                        if not len(transaction.signatures):\r\n                            # No Signatures add my signature\r\n                            signature = rsa.sign(transaction.transaction.encode(), client.privateKey, 'SHA-1')\r\n                            transaction.signatures.append([str(client.publicIP),str(signature)])\r\n                            self.saveUnconfirmedTransactions()\r\n                        else:\r\n                            print(\"TRYING TO MINE FROM PEERS\")\r\n                            for peer in self.peers:\r\n                                if peer[0]!=client.publicIP:\r\n                                    print(f\"Trying to get signatures from :{peer[0]}\")\r\n                                    print(transaction.transaction)\r\n                                    #Send Transaction get signature.\r\n                                    signReq = Networking.GetSignatureRequest(self.groupId,self.getLastBlockIndex(),transaction.transaction)\r\n                                    res = Networking.sendRequest(peer[0], 6700, dumps(signReq))\r\n                                    if res is not False:\r\n                                        if res.answer!=0 and res.answer!=1:\r\n                                            #Verified.\r\n                                            print(f\"Signature:{res.answer},SignBytes:{bytes(res.answer,'utf-8')}\")\r\n                                            # key = rsa.PublicKey.load_pkcs1(self.getRSAKey(peer[0]))\r\n                                            # print(rsa.verify(transaction.transaction, signature, key))\r\n\r\n                                    else:\r\n                                        #Peer Dead Try From Others.\r\n                                        print(\"No Response from\", peer[0])\r\n                                        pass\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                            pass\r\n                    else:\r\n                        # We have the signatures number procede to make block and share.\r\n                        print(f\"Signature {transaction} ready to be made block.\")\r\n                        # Bytes\r\n                        lastBlock = self.getLastBlock()\r\n                        # print(lastBlock)\r\n                        lastBlock: Block\r\n                        print(f\"Last Block Index :{lastBlock.index}\")\r\n                        newBlock = Block(lastBlock.index + 1, transaction.transaction, str(time.time()),\r\n                                         lastBlock.computeHash(), transaction.signatures)\r\n                        newBlock.hash = newBlock.computeHash()\r\n                        self.unconfirmed_transactions.remove(transaction)\r\n                        self.saveUnconfirmedTransactions()\r\n                        self.saveBlock(newBlock)\r\n                        self.chain.append(newBlock)\r\n                sleep(30)\r\n\r\n    def getLastBlock(self) -> Block:\r\n        lastBlockIndex = self.chain[0].index\r\n        # Find last Block and return it\r\n        lastBlock = self.chain[0]\r\n        for block in self.chain:\r\n            # print(block.index)\r\n            if block.index > lastBlockIndex:\r\n                lastBlock = block\r\n                lastBlockIndex = block.index\r\n        return lastBlock\r\n\r\n    def getRSAKey(self,ip):\r\n        \"\"\"Use only with peers in group so key always exists one way or another.\"\"\"\r\n        for block in self.chain:\r\n            block:Block\r\n            transaction = json.loads(block.transaction)\r\n            if transaction[\"type\"] == 0:\r\n                if transaction[\"ip\"]==ip:\r\n                    return transaction[\"publicKey\"]\r\n\r\n            # From Invite\r\n            elif transaction[\"type\"] == 2:\r\n                if transaction[\"ip\"]==ip:\r\n                    return transaction[\"publicKey\"]\r\n\r\n\r\n    def getLastBlockIndex(self):\r\n        if len(self.chain) == 0:\r\n            return -1\r\n        else:\r\n            lastBlockIndex = self.chain[0].index\r\n            # Find last Block and return it\r\n            lastBlock = self.chain[0]\r\n            for block in self.chain:\r\n                # print(block.index)\r\n                if block.index > lastBlockIndex:\r\n                    lastBlock = block\r\n                    lastBlockIndex = block.index\r\n            return lastBlock.index\r\n\r\n    def saveUnconfirmedTransactions(self):\r\n        # print(self.TRANSACTION_PATH)\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Blockchain Folder\")\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n        json_file = open(self.TRANSACTION_PATH + \"Transactions\" + \".json\", \"w\")\r\n        json_file.write((json.dumps([ob.__dict__ for ob in self.unconfirmed_transactions])))\r\n        json_file.close()\r\n\r\n    def isUserAllowed(self, ip):\r\n        for block in self.chain:\r\n            block: Block\r\n            transaction = json.loads(block.transaction)\r\n            # From Create Genesis Block\r\n            if transaction[\"type\"] == 0:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n            # From Invite\r\n            if transaction[\"type\"] == 1:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n        # Didndt find user\r\n        return False\r\n\r\n    def getOwner(self):\r\n        for block in self.chain:\r\n            transaction = json.loads(block.transaction)\r\n            if transaction[\"type\"] == 0:\r\n                return transaction[\"ip\"]\r\n\r\n    def parseBlockchain(self):\r\n        \"\"\"\r\n        Parses Blockchain and returns 5 list of user types.\r\n        Peers that are in the blockchain and allowed.\r\n        Banned peers, Invites ,Admins and, Owner . All are lists.\r\n        \"\"\"\r\n        peers = []\r\n        bans = []\r\n        admins = []\r\n        invites = []\r\n        owner = []\r\n\r\n        for block in self.chain:\r\n            transaction = json.loads(block.transaction)\r\n            #GenesisTransactio\r\n            if transaction[\"type\"] == 0:\r\n                owner.append(transaction[\"ip\"])\r\n                admins.append(transaction[\"ip\"])\r\n                peers.append(transaction[\"ip\"])\r\n\r\n            #InviteTransaction\r\n            elif transaction[\"type\"] == 1:\r\n                invites.append(transaction[\"ip\"])\r\n\r\n            #JoinTransaction\r\n            elif transaction[\"type\"] == 2:\r\n                peers.append(transaction[\"ip\"])\r\n                invites.remove(transaction[\"ip\"])\r\n\r\n            #BanTransaction\r\n            elif transaction[\"type\"] == 3:\r\n                peers.remove(transaction[\"ip\"])\r\n                bans.append(transaction[\"ip\"])\r\n\r\n            # UnbanTransaction\r\n            elif transaction[\"type\"] == 4:\r\n                bans.remove(transaction[\"ip\"])\r\n\r\n                # AddAdminTransaction\r\n            elif transaction[\"type\"] == 5:\r\n                admins.append(transaction[\"ip\"])\r\n\r\n            # RemoveAdminTransaction\r\n            elif transaction[\"type\"] == 6:\r\n                admins.remove(transaction[\"ip\"])\r\n\r\n        # print(f\"Peers:{peers},Bans:{bans},Admins:{admins},Owners:{owner}\")\r\n        return peers, bans, admins, owner\r\n\r\n\r\nimport Networking\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Blockchain.py b/Blockchain.py
--- a/Blockchain.py	(revision de59e92006cbb426c6bb20267c11c6488949315e)
+++ b/Blockchain.py	(date 1650894524522)
@@ -447,8 +447,12 @@
 
         for block in self.chain:
             transaction = json.loads(block.transaction)
+            print(peers,invites)
+            print(transaction)
+
             #GenesisTransactio
             if transaction["type"] == 0:
+
                 owner.append(transaction["ip"])
                 admins.append(transaction["ip"])
                 peers.append(transaction["ip"])
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import json\r\nimport logging\r\nimport threading\r\nfrom pickle import dumps, loads\r\nfrom flask import Flask, render_template, request, redirect\r\n\r\nimport Blockchain\r\nimport Compress\r\nfrom Networking import receiver, sendRequest, JoinRequest, SearchBundleRequest, receiveBundle, GetBundleRequest\r\nfrom Groups import GroupManager, Invite, Group\r\nfrom Client import Client\r\nimport easygui\r\nfrom Bundles import BundleManager\r\nfrom Downloads import DownloadManager\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = False\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    progress = downloadManager.getDownloadProgress()\r\n    return render_template(\"index.html\", groups=groupManager.groups, client=client, progress=progress)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    group = groupManager.getGroupWithName(group)\r\n    groupManager.saveGroup(group)\r\n    # Check if user should see admin panels.\r\n    peers, bans, admins, owner = group.blockchain.parseBlockchain()\r\n    if owner[0] in peers:\r\n        peers.remove(owner[0])\r\n\r\n    if owner[0] in admins:\r\n        admins.remove(owner[0])\r\n\r\n    # Check privs what to show on group page.\r\n    adminPriv = False\r\n    for admin in group.admins:\r\n        if admin[0] == client.publicIP:\r\n            adminPriv = True\r\n\r\n    ownerPriv = False\r\n    if group.blockchain.getOwner() == client.publicIP:\r\n        ownerPriv = True\r\n\r\n    if client.publicIP in admins:\r\n        admins.remove(client.publicIP)\r\n    if client.publicIP in peers:\r\n        peers.remove(client.publicIP)\r\n\r\n    dif = group.blockchain.getDifficulty()\r\n    print(dif)\r\n    groupManager.saveGroup(group)\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group, client=client, adminPriv=adminPriv,\r\n                           ownerPriv=ownerPriv, peers=peers, bans=bans, admins=admins)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    if downloadManager.STATUS:\r\n        downloadManager.STATUS = False\r\n        # downloadManager Off\r\n        print(\"Download Manager Not Active\")\r\n        return \"0\"\r\n    else:\r\n        downloadManager.STATUS = True\r\n        # downloadManager On\r\n        print(\"Download Manager Active\")\r\n        return \"1\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n        # TODO KEY SPECIFIC BLOCKCHAIN\r\n        ip = data[\"ip\"]  # This is string\r\n        transaction = Blockchain.InviteTransaction(ip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        # print(\"Generate Invite for :\", group)\r\n        # print(group)\r\n        invite = group.generateInvite()\r\n        return Compress.compress(invite.toJSON())\r\n\r\n\r\n\r\n@app.route('/deleteBundle', methods=['POST'])\r\ndef deleteBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupId = data[\"groupId\"]\r\n        bundleId = data[\"bundleId\"]\r\n        if groupManager.deleteBundle(groupId, bundleId):\r\n            return \"1\"\r\n        else:\r\n            return \"0\"\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        inviteDecomp = Compress.decompress(invite)\r\n        inviteLoad = json.loads(inviteDecomp)\r\n        invite = Invite(inviteLoad[\"id\"], inviteLoad[\"name\"], inviteLoad[\"timestamp\"], inviteLoad[\"peers\"])\r\n        joinReq = JoinRequest(invite.name, invite.timestamp)\r\n        # print(invite.peers)\r\n        for peer in invite.peers:\r\n            # print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq))\r\n            if res is not False:\r\n                # Response from user with group data.\r\n                group = res.group\r\n                group = Group(group.name, group.admins, group.peers, group.timestamp,\r\n                              blockchainPath=groupManager.DIR_PATH_GROUPS + group.name + \"\\\\Blockchain\", client=client)\r\n                groupManager.addGroup(group)\r\n                # Make Join Transaction.\r\n                transaction = Blockchain.JoinTransaction(client.publicIP,\r\n                                                         client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n                transactionStr = json.dumps(transaction.__dict__)\r\n                group.blockchain.addNewTransaction(transactionStr)\r\n                return \"1\"\r\n        # No responses.\r\n        return \"0\"\r\n\r\n\r\n@app.route('/shareBundle', methods=['POST'])\r\ndef shareBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"bundleName\"]\r\n        desc = data[\"bundleDescription\"]\r\n        groupName = data[\"groupName\"]\r\n        # print(name)\r\n        # print(desc)\r\n        # print(groupName)\r\n        path = easygui.diropenbox(msg=\"Select folder to share as bundle\", title=\"Share Bundle\")\r\n        bundle = bundleManager.createBundle(name, desc, path=path)\r\n        groupManager.addBundle(bundle, groupName)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/selectDownloadLocation', methods=['POST'])\r\ndef selectDownloadLocation():\r\n    if request.method == 'POST':\r\n        path = easygui.diropenbox(msg=\"Select folder to download bundles\", title=\"Select Bundle Download Location\")\r\n        # print(path)\r\n        # Update Download Path in Config\r\n        client.DIR_PATH_DOWNLOADS = path\r\n        client.saveConfig()\r\n        # Return path to browser and update it in modal\r\n        return path\r\n\r\n\r\n@app.route('/searchBundles', methods=['POST'])\r\ndef searchBundles():\r\n    # print(\"Search Bundles Route\")\r\n    if request.method == 'POST':\r\n        data = request.form\r\n\r\n        # Get Keywords from search\r\n        keywords = data[\"searchKeyWords\"].split()\r\n        # print(\"Search for :\",keywords)\r\n\r\n        # Get Group\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n\r\n        searchReq = SearchBundleRequest(group.id, keywords)\r\n        responses = []\r\n        # SEND TO ALL PEERS COLLECT RESPONSES AND PRESENT\r\n        for peer in group.peers:\r\n            res = sendRequest(peer[0], 6700, dumps(searchReq))\r\n            # if other peer is responded.\r\n            if res is not False:\r\n                # print(res)\r\n                responses.append([peer[0], res])\r\n            else:\r\n                print(\"No Response from\", peer[0])\r\n        # Merge all responses to single list\r\n        # for x in responses:\r\n        #     print(\"Response:\",x[0],x[1],x[1].responseBundles)\r\n        # WITH RESPONSES DO STUFF.\r\n        # Respond\r\n        return render_template(\"search.html\", groups=groupManager.groups, group=group, responses=responses)\r\n\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n    if groupManager.createGroup(name, [client.publicIP]):\r\n        # Make First Block In Blockchain Append Admin\r\n        # Type 0 First Created\r\n        group = groupManager.getGroupWithName(name)\r\n        group.blockchain.createGenesisBlock(client)\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n\r\n@app.route('/getBundle', methods=['POST'])\r\ndef getBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        bundleId = data[\"bundleId\"]\r\n        groupId = data[\"groupId\"]\r\n        userIp = data[\"userIp\"]\r\n        # TODO dynamic port on receiver for bundle\r\n        portForBundleReceiver = 6701\r\n        bundleReceiver = threading.Thread(target=receiveBundle,\r\n                                          args=[portForBundleReceiver, client, groupManager, groupId, downloadManager])\r\n        bundleReceiver.start()\r\n        getBundleReq = GetBundleRequest(bundleId, groupId, portForBundleReceiver)\r\n        res = sendRequest(userIp, 6700, dumps(getBundleReq))\r\n        # if other peer is responded.\r\n        if res is not False:\r\n            # Responded decide what to do\r\n            pass\r\n        else:\r\n            # print(\"No Response from\", userIp)\r\n            pass\r\n    return \"1\"\r\n\r\n\r\n@app.route('/quitGroup', methods=['POST'])\r\ndef quitGroup():\r\n    # print('QUIT GROUP REQ')\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        if groupManager.quitGroup(group):\r\n            # True\r\n            return \"0\"\r\n        else:\r\n            # False\r\n            return \"1\"\r\n\r\n\r\n@app.route('/banUser', methods=['POST'])\r\ndef banUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.BanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/unbanUser', methods=['POST'])\r\ndef unbanUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.UnbanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/addAdmin', methods=['POST'])\r\ndef addAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.AddAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/removeAdmin', methods=['POST'])\r\ndef removeAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.RemoveAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    groupManager = GroupManager(client)\r\n    bundleManager = BundleManager()\r\n    downloadManager = DownloadManager(groupManager, client)\r\n    # TODO Networking Thread To Receive From Internet\r\n    receiver = threading.Thread(target=receiver, args=[groupManager])\r\n    receiver.start()\r\n    app.run(host='', port=6969)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision de59e92006cbb426c6bb20267c11c6488949315e)
+++ b/main.py	(date 1650894524501)
@@ -57,7 +57,7 @@
         peers.remove(client.publicIP)
 
     dif = group.blockchain.getDifficulty()
-    print(dif)
+    # print(dif)
     groupManager.saveGroup(group)
     return render_template("groups.html", groups=groupManager.groups, group=group, client=client, adminPriv=adminPriv,
                            ownerPriv=ownerPriv, peers=peers, bans=bans, admins=admins)
Index: Networking.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import copy\r\nimport json\r\nimport pickle\r\nimport socket\r\nimport threading\r\nfrom socket import *\r\nfrom Bundles import Bundle\r\nimport Client\r\nfrom Groups import GroupManager, Group\r\nimport os\r\nimport hashlib\r\nimport Blockchain\r\n\r\n\r\nclass Request:\r\n    def __init__(self, type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\n\r\n# All Classes extended Request even Response Classes just for type and toJSON method.\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self, name, timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self, group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\n\r\nclass SearchBundleRequest(Request):\r\n    def __init__(self, groupId, keyword):\r\n        super().__init__(2)\r\n        self.groupID = groupId\r\n        self.keywords = keyword\r\n\r\n\r\nclass SearchBundleResponse(Request):\r\n    def __init__(self, responseBundles):\r\n        super().__init__(2)\r\n        self.responseBundles = responseBundles\r\n\r\n\r\nclass GetBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId, portForBundleReceiver):\r\n        super().__init__(3)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.portForBundleReceiver = portForBundleReceiver\r\n\r\n\r\nclass GetBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(3)\r\n        self.answer = answer\r\n\r\n\r\nclass CheckBundleAvailabilityRequest(Request):\r\n    def __init__(self, bundleId, groupId):\r\n        super().__init__(4)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n\r\n\r\nclass CheckBundleAvailabilityResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(4)\r\n        self.answer = answer\r\n\r\n\r\nclass DownloadBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId, file, port):\r\n        super().__init__(5)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.file = file\r\n        self.port = port\r\n\r\n\r\nclass DownloadBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(5)\r\n        self.answer = answer\r\n\r\n\r\nclass UpdateBlockchainRequest(Request):\r\n    def __init__(self, groupId):\r\n        super().__init__(6)\r\n        self.groupId = groupId\r\n\r\n\r\nclass UpdateBlockchainResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(6)\r\n        self.answer = answer\r\n\r\n\r\nclass GetBlockRequest(Request):\r\n    def __init__(self, groupId, blockIndex):\r\n        super().__init__(7)\r\n        self.groupId = groupId\r\n        self.blockIndex = blockIndex\r\n\r\n\r\nclass GetBlockResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(7)\r\n        self.answer = answer\r\n\r\nclass GetSignatureRequest(Request):\r\n    def __init__(self, groupId, lastIndex,transaction):\r\n        super().__init__(8)\r\n        self.groupId = groupId\r\n        self.lastIndex = lastIndex\r\n        self.transaction = transaction\r\n\r\nclass GetSignatureResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(8)\r\n        self.answer = answer\r\n\r\n\r\n\r\ndef requestHandler(data, addr, groupManager: GroupManager):\r\n    req = pickle.loads(data)\r\n    print(f\"Received From {addr[0]}:{addr[1]} {req.__class__.__name__}\")\r\n\r\n    # Response to JoinRequest\r\n    #TODO refactor this.\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name, req.timestamp)\r\n        group = groupManager.getGroupWithName(req.name)\r\n        if group.blockchain.isUserAllowed(addr[0]):\r\n            groupManager.addPeerGroup(req.name, [addr[0]])\r\n            groupCpy = copy.copy(group)\r\n            del groupCpy.bundles\r\n            joinResponse = JoinResponse(groupCpy)\r\n            return pickle.dumps(joinResponse)\r\n        else:\r\n            return False\r\n\r\n    # Response to search req\r\n    elif req.type == 2:\r\n        # Create The Request again for local use\r\n        req = SearchBundleRequest(req.groupID, req.keywords)\r\n        # Get All Bundles User has\r\n        bundlesOfGroup = groupManager.getGroupWithId(req.groupID).bundles\r\n        # Bundles to reply\r\n        responseBundles = []\r\n        # print(responseBundles)\r\n        for bundle in bundlesOfGroup:\r\n            # For each bundle make a single list (bundleKeywords) and search if any of the keywords other user send are in there then send back\r\n            name = bundle.name.split()\r\n            desc = bundle.description.split()\r\n            bundleKeywords = name + desc\r\n            # print(\"Bundle Keywords : \",bundleKeywords)\r\n            # print(\"Request Keywords : \",req.keywords)\r\n            if any(keyword in req.keywords for keyword in bundleKeywords):\r\n                # print(\"HIT\")\r\n                responseBundles.append({\"id\": bundle.id, \"name\": bundle.name, \"description\": bundle.description})\r\n        # Create Response and return it to be used as answer\r\n        # print(responseBundles)\r\n        searchResponse = SearchBundleResponse(responseBundles)\r\n        # print(\"Search Response :\",searchResponse)\r\n        return pickle.dumps(searchResponse)\r\n\r\n    elif req.type == 3:\r\n        req = GetBundleRequest(req.bundleId, req.groupId, req.portForBundleReceiver)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        bundle = group.getBundleWithId(req.bundleId)\r\n        bundleReceiver = threading.Thread(target=sendBundle,\r\n                                          args=[addr, req.portForBundleReceiver, groupManager, group, bundle])\r\n        bundleReceiver.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        # TODO 9/4 ????\r\n        return pickle.dumps(GetBundleResponse(1))\r\n\r\n    elif req.type == 4:\r\n        req = CheckBundleAvailabilityRequest(req.bundleId, req.groupId)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        bundle = group.getBundleWithId(req.bundleId)\r\n        if bundle is False:\r\n            # Not Found\r\n            return pickle.dumps(CheckBundleAvailabilityResponse(0))\r\n        else:\r\n            # Found\r\n            return pickle.dumps(CheckBundleAvailabilityResponse(1))\r\n\r\n    elif req.type == 5:\r\n        # print(\"Received Request To Send File\")\r\n        req = DownloadBundleRequest(req.bundleId, req.groupId, req.file, req.port)\r\n        uploadThread = threading.Thread(target=uploadBundle,\r\n                                        args=[addr, req.port, req.bundleId, req.groupId, req.file, groupManager])\r\n        uploadThread.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        # TODO 9/4 ????\r\n        return pickle.dumps(DownloadBundleResponse(1))\r\n\r\n    elif req.type == 6:\r\n        req = UpdateBlockchainRequest(req.groupId)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        # If i am in group for group that im not in.\r\n        if group is not False:\r\n            if group.blockchain.isUserAllowed(addr[0]):\r\n                # User is ok\r\n                lastBlock = group.blockchain.getLastBlock()\r\n                lastBlock: Blockchain.Block\r\n                lastBlockIndex = lastBlock.index\r\n                return pickle.dumps(UpdateBlockchainResponse(lastBlockIndex))\r\n            else:\r\n                # User not invited not joined, therefore don't answer.\r\n                return False\r\n\r\n    elif req.type == 7:\r\n        req = GetBlockRequest(req.groupId, req.blockIndex)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        block = group.blockchain.getBlockWithIndex(req.blockIndex)\r\n        if block is not False:\r\n            return pickle.dumps(GetBlockResponse(block))\r\n        else:\r\n            return False\r\n\r\n    elif req.type == 8:\r\n        req = GetSignatureRequest(req.groupId, req.lastIndex, req.transaction)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        lastIndex = group.blockchain.getLastBlockIndex()\r\n        #If up to date or more\r\n        if lastIndex==req.lastIndex:\r\n            #Up To date\r\n            if group.blockchain.verifyTransaction(req.transaction):\r\n                #Transaction Ok\r\n                signature = rsa.sign(transactionStr.encode(), group.client.privateKey, 'SHA-1')\r\n                return pickle.dumps(GetSignatureResponse(str(signature.hex())))\r\n            else:\r\n                #Transaction not ok.\r\n                return pickle.dumps(GetSignatureResponse(1))\r\n\r\n        else:\r\n            #Not up to date.\r\n            return pickle.dumps(GetSignatureResponse(0))\r\n\r\n\r\ndef responseHandler(data, addr):\r\n    res = pickle.loads(data)\r\n\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 2:\r\n        res = SearchBundleResponse(res.responseBundles)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 3:\r\n        res = SearchBundleResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 4:\r\n        res = CheckBundleAvailabilityResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 5:\r\n        res = DownloadBundleResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 6:\r\n        res = UpdateBlockchainResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 7:\r\n        res = GetBlockResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 8:\r\n        res = GetSignatureResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        try:\r\n            # RECEIVE AND RESPOND.\r\n            data, addr = sock.recvfrom(65537)\r\n            # data, addr = sock.recvfrom(65507)\r\n            # print(\"Received from :\", addr)\r\n            response = requestHandler(data, addr, groupManager)\r\n            # Request Handler if not want to answer returns False.\r\n            if response is not False:\r\n                sock.sendto(response, addr)\r\n        except Exception as e:\r\n            pass\r\n\r\n\r\ndef sendRequest(address, port, request):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.settimeout(1)\r\n    try:\r\n        clientSocket.sendto(request, (address, port))\r\n        data, addr = clientSocket.recvfrom(65537)\r\n        res = responseHandler(data, addr)\r\n        return res\r\n    # TODO except socket.timeout\r\n    except Exception as exception:\r\n        # print(\"Exception on SendRequest:\", exception)\r\n        return False\r\n\r\n\r\ndef receiveBundle(port, client, groupManager, groupId, downloadManager):\r\n    # print(\"RECEIVING BUNDLE THREAD\")\r\n    bundleBytes = b\"\"\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.bind((\"0.0.0.0\", port))\r\n        # print(\"Bundle Receiver Ready\")\r\n        s.listen()\r\n        conn, addr = s.accept()\r\n        with conn:\r\n            print(f\"Connection From {addr[0]}:{addr[1]} Accepted.\")\r\n            while True:\r\n                data = conn.recv(1024)\r\n                # print(data)\r\n                bundleBytes = bundleBytes + data\r\n                # TODO save Bytes to group and downloads also start downloading.\r\n                if not data:\r\n                    # print(\"Break\")\r\n                    break\r\n            # print(\"Break3\")\r\n    # print(\"Bundle Str\",bundleBytes.decode())\r\n    bundleObj = json.loads(bundleBytes.decode())\r\n    # Fix Bundle Root to be downloaded and location\r\n    client: Client.Client\r\n    bundleObj[\"root\"] = client.DIR_PATH_DOWNLOADS\r\n    bundle = Bundle(bundleObj[\"name\"], bundleObj[\"description\"], bundleObj[\"id\"], bundleObj[\"timestamp\"],\r\n                    bundleObj[\"root\"], bundleObj[\"pieceSize\"], bundleObj[\"files\"])\r\n    group = groupManager.getGroupWithId(groupId)\r\n    groupManager.addBundle(bundle, group.name)\r\n    downloadManager.downloadBundle(bundle, group)\r\n\r\n\r\ndef sendBundle(addr, port, groupManager, group, bundle):\r\n    # print(\"SENDING BUNDLE THREAD\")\r\n    group: Group\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.connect((addr[0], port))\r\n        print(f\"Connected To {addr[0]}:{addr[1]}.\")\r\n        # print(\"SENDING DATA\")\r\n        groupManager: GroupManager\r\n        json_file_name = bundle.name + \".json\"\r\n        bundleDir = groupManager.DIR_PATH_GROUPS + group.name + \"\\\\\" + \"Bundles\" + \"\\\\\" + json_file_name\r\n        print(bundleDir)\r\n        print(json_file_name)\r\n        with open(bundleDir) as f:\r\n            bundleContent = f.read()\r\n            bundleObj = json.loads(bundleContent)\r\n            bundleObj[\"root\"] = \"\"\r\n            bundleStr = json.dumps(bundleObj)\r\n\r\n        s.sendall(bundleStr.encode())\r\n\r\n\r\ndef is_port_in_use(port: int) -> bool:\r\n    import socket\r\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\r\n        return s.connect_ex(('localhost', port)) == 0\r\n\r\n\r\ndef downloadBundle(downloadManager, port, peer, file, bundle, usedPeers, freeFiles):\r\n    pieceList = []\r\n    # Find pieces missing\r\n    for x in bundle.files:\r\n        if x[\"path\"] == file[0]:\r\n            pieceList = x[\"pieces\"]\r\n            break\r\n    # pieceList = [[0, '5920572cf97d3711a77a9b7a3469a5fd03bb2a8a', 0]]\r\n    # print(\"DOWNLOADING BUNDLE THREAD\")\r\n    filePath = bundle.root + f\"\\\\{bundle.name}\" + file[0]\r\n    dir = filePath.rsplit('\\\\', 1)[0]\r\n    # print(dir)\r\n    # Create Directory's that don't exist.\r\n    isExist = os.path.exists(dir)\r\n    if not isExist:\r\n        # Create a new directory because it does not exist\r\n        os.makedirs(dir)\r\n\r\n    if os.path.exists(filePath) is False:\r\n        print(\"Creating File\")\r\n        file = open(filePath, 'x')\r\n        file.close()\r\n\r\n    with open(filePath, 'rb+') as openfileobject:\r\n        with socket(AF_INET, SOCK_STREAM) as s:\r\n            s.bind((\"0.0.0.0\", port))\r\n            # print(\"Bundle Receiver Ready\")\r\n            s.listen()\r\n            conn, addr = s.accept()\r\n            with conn:\r\n                print(f\"Connection From {addr[0]}:{addr[1]} Accepted.\")\r\n                data = conn.recv(1024)\r\n                if data.decode() == \"OK\":\r\n                    # print(\"Received Ok\")\r\n                    for piece in pieceList:\r\n                        if piece[2] == 0:\r\n                            # print(f\"Sending Piece num {piece[0]} \")\r\n                            conn.sendall(str(piece[0]).encode())\r\n                            openfileobject.seek(piece[0] * bundle.pieceSize)\r\n                            data = conn.recv(100000)\r\n                            # print(f\"Received {data}\")\r\n                            if hashlib.sha1(data).hexdigest() == piece[1]:\r\n                                # print(\"HASH OK\")\r\n                                openfileobject.write(data)\r\n                                piece[2] = 1\r\n                                # print(piece)\r\n                            else:\r\n                                pass\r\n                                # print(\"hashes dont match\")\r\n                    # delimmiter for data\r\n                    conn.sendall(\"\uD83E\uDD6D\uD83C\uDF53\uD83C\uDF47\uD83C\uDF49\uD83C\uDF50\uD83E\uDD67\uD83C\uDF4A\uD83C\uDF4D\uD83C\uDF4F\uD83E\uDD51\uD83C\uDF51\uD83C\uDF4C\uD83C\uDF4E\uD83C\uDF50\uD83C\uDF49\uD83C\uDF47\uD83C\uDF53\uD83E\uDD6D\uD83E\uDD5D\uD83C\uDF52\uD83C\uDF45\".encode())\r\n                    usedPeers.remove(peer)\r\n                    downloadManager.saveBundle(bundle)\r\n    # print(f\"Thread Exit {file}\")\r\n\r\n\r\ndef uploadBundle(addr, port, bundleId, groupId, file, groupManager):\r\n    # print(\"SENDING BUNDLE THREAD\")\r\n    group = groupManager.getGroupWithId(groupId)\r\n    bundle = group.getBundleWithId(bundleId)\r\n    with open(bundle.root + file, 'rb') as openfileobject:\r\n        try:\r\n            with socket(AF_INET, SOCK_STREAM) as s:\r\n                s.connect((addr[0], port))\r\n                # print(\"SENDING DATA\")\r\n                s.sendall(\"OK\".encode())\r\n                while True:\r\n                    piece = s.recv(1024)\r\n                    # delimmiter for data\r\n                    if piece == \"\uD83E\uDD6D\uD83C\uDF53\uD83C\uDF47\uD83C\uDF49\uD83C\uDF50\uD83E\uDD67\uD83C\uDF4A\uD83C\uDF4D\uD83C\uDF4F\uD83E\uDD51\uD83C\uDF51\uD83C\uDF4C\uD83C\uDF4E\uD83C\uDF50\uD83C\uDF49\uD83C\uDF47\uD83C\uDF53\uD83E\uDD6D\uD83E\uDD5D\uD83C\uDF52\uD83C\uDF45\".encode():\r\n                        break\r\n                    else:\r\n                        if piece == b'':\r\n                            # print(\"Empty\")\r\n                            pass\r\n                        else:\r\n                            piece = int(piece.decode())\r\n                            # print(f\"Trying to send {piece}\")\r\n                            openfileobject.seek(piece * bundle.pieceSize)\r\n                            readData = openfileobject.read(bundle.pieceSize)\r\n                            s.sendall(readData)\r\n        except ConnectionResetError as exception:\r\n            print(\"Downloader DC\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Networking.py b/Networking.py
--- a/Networking.py	(revision de59e92006cbb426c6bb20267c11c6488949315e)
+++ b/Networking.py	(date 1650894635864)
@@ -10,6 +10,7 @@
 import os
 import hashlib
 import Blockchain
+import rsa
 
 
 class Request:
@@ -236,7 +237,8 @@
             #Up To date
             if group.blockchain.verifyTransaction(req.transaction):
                 #Transaction Ok
-                signature = rsa.sign(transactionStr.encode(), group.client.privateKey, 'SHA-1')
+                signature = rsa.sign(req.transaction.encode(), group.client.privateKey, 'SHA-1')
+                print(f"Signature:{signature}")
                 return pickle.dumps(GetSignatureResponse(str(signature.hex())))
             else:
                 #Transaction not ok.
