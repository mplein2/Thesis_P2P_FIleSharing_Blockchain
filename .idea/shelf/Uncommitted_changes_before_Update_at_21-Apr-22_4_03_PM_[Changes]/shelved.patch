Index: Blockchain.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport json\r\nfrom os import listdir\r\nimport rsa\r\nimport time\r\nfrom time import sleep\r\nimport threading\r\nfrom hashlib import sha256\r\nimport copy\r\nfrom pickle import dumps, loads\r\n\r\n\r\nclass Block:\r\n    def __init__(self, index, transaction, timestamp, previous_hash, signatures):\r\n        self.index = index\r\n\r\n        self.transaction = transaction\r\n\r\n        self.timestamp = timestamp\r\n\r\n        self.previous_hash = previous_hash\r\n\r\n        self.signatures = signatures\r\n\r\n    def compute_hash(self):\r\n        mycopy = copy.copy(self)\r\n        del mycopy.signatures\r\n        # print(mycopy.__dict__)\r\n        if hasattr(mycopy, 'hash'):\r\n            del mycopy.hash\r\n        block_string = json.dumps(mycopy.__dict__, sort_keys=True)\r\n        return sha256(block_string.encode()).hexdigest()\r\n\r\n\r\nclass UnconfirmedTransaction:\r\n    def __init__(self, transaction, signatures=[]):\r\n        self.transaction = transaction\r\n        self.signatures = signatures\r\n\r\n\r\nclass GenesisTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 0\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass InviteTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 1\r\n        self.ip = ip\r\n\r\n\r\nclass Blockchain:\r\n    def __init__(self, path, groupPeers, groupId):\r\n        self.BLOCKCHAIN_PATH = path\r\n        self.TRANSACTION_PATH = self.BLOCKCHAIN_PATH + \"\\\\Transactions\\\\\"\r\n        self.unconfirmed_transactions = []\r\n        self.chain = []\r\n        self.peers = groupPeers\r\n        self.groupId = groupId\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n            # Load Unconfirmed Transactions\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n\r\n        self.loadTransactions()\r\n\r\n        # print(self.unconfirmed_transactions)\r\n        # Load Blocks here\r\n        blockFiles = [f for f in listdir(self.BLOCKCHAIN_PATH) if os.path.isfile(os.path.join(self.BLOCKCHAIN_PATH, f))]\r\n        for blockFile in blockFiles:\r\n            self.loadBlock(blockFile)\r\n\r\n        # Start Casual Operations.\r\n        # Thread This.\r\n        miner = threading.Thread(target=self.mine, args=[])\r\n        miner.start()\r\n        # print(self.unconfirmed_transactions)\r\n        # for block in self.chain:\r\n        #     print(block)\r\n\r\n    def getDifficulty(self):\r\n        # Diffuculty of blockchain will be dependent on the users participating\r\n        # TODO refactor this for join ban unban\r\n        if len(self.peers) == 0:\r\n            return 1\r\n        else:\r\n            return len(self.peers)\r\n\r\n    def create_genesis_block(self, client):\r\n        transaction = GenesisTransaction(client.publicIP, client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        # this is string json format\r\n        # print(transactionStr)\r\n        # print(transactionStr.__class__)\r\n        # Genereate signature for Transaction\r\n\r\n        signature = rsa.sign(transactionStr.encode(), client.privateKey, 'SHA-1')\r\n\r\n        # Bytes\r\n        # print(signature)\r\n        # print(signature.__class__)\r\n\r\n        genesis_block = Block(0, transactionStr, str(time.time()), \"0\", [str(signature)])\r\n        genesis_block.hash = genesis_block.compute_hash()\r\n        self.saveBlock(genesis_block)\r\n        self.chain.append(genesis_block)\r\n\r\n    def saveBlock(self, block):\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Creating Blockchain Folder\")\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n        blockFile = open(self.BLOCKCHAIN_PATH + \"\\\\Block\" + str(block.index) + \".json\", \"w\")\r\n        # print(block.__dict__)\r\n        blockFile.write(json.dumps(block.__dict__))\r\n        blockFile.close()\r\n\r\n    def loadTransactions(self):\r\n        filePath = self.TRANSACTION_PATH + \"Transactions.json\"\r\n        if os.path.exists(filePath):\r\n            try:\r\n                file = open(filePath)\r\n                # print(file)\r\n                json_load_group = json.load(file)\r\n                file.close()\r\n            except Exception as e:\r\n                print(\"Error Opening Transaction file :\", e)\r\n            for x in json_load_group:\r\n                transaction = UnconfirmedTransaction(x[\"transaction\"], x[\"signatures\"])\r\n                # print(transaction)\r\n                self.unconfirmed_transactions.append(transaction)\r\n            # print(self.unconfirmed_transactions)\r\n\r\n    def loadBlock(self, blockFiles):\r\n        # print(blockFiles)\r\n        filePath = self.BLOCKCHAIN_PATH + \"\\\\\" + blockFiles\r\n        file = open(filePath)\r\n        # print(file)\r\n        block = json.load(file)\r\n        file.close()\r\n        # # print(block)\r\n        # transaction = json.loads(block[\"transaction\"])\r\n        # # print(transaction)\r\n        # # print(transaction.__class__)\r\n        # # Make transaction here\r\n        # if transaction[\"type\"] == 0:\r\n        #     # print(\"Genesis block\")\r\n        #     transactionObj = GenesisTransaction(transaction[\"ip\"], transaction[\"publicKey\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        blockObj = Block(block[\"index\"], block[\"transaction\"], block[\"timestamp\"], block[\"previous_hash\"],\r\n                         block[\"signatures\"])\r\n        blockObj.hash = block[\"hash\"]\r\n        # TODO Add all transactions here\r\n\r\n        # elif transaction[\"type\"] == 1:\r\n        #     # print(\"Genesis block\")\r\n        #     # print(transaction)\r\n        #     transactionObj = InviteTransaction(transaction[\"ip\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        #     blockObj = Block(block[\"index\"], transactionStr, block[\"timestamp\"], block[\"previous_hash\"],\r\n        #                      block[\"signatures\"])\r\n        #     blockObj.hash = block[\"hash\"]\r\n\r\n        self.chain.append(blockObj)\r\n        # print(blockObj.__dict__)\r\n\r\n    def add_new_transaction(self, transaction: str):\r\n        newUnconfirmedTransaction = UnconfirmedTransaction(transaction)\r\n        self.unconfirmed_transactions.append(newUnconfirmedTransaction)\r\n        self.save_unconfirmed_transactions()\r\n\r\n    def updateBlockchain(self):\r\n        for peer in self.peers:\r\n            # For each peer ask their max index of blockchain\r\n            updateBlockchainReq = Networking.UpdateBlockchainRequest(self.groupId)\r\n            res = Networking.sendRequest(peer[0], 6700, dumps(updateBlockchainReq))\r\n            if res is not False:\r\n                # if the response is bigger than me ask him for his block until we are at the same.\r\n                if res.answer > self.getLastBlockIndex():\r\n                    print(self.getLastBlockIndex().__class__, res.answer.__class__)\r\n                    while self.getLastBlockIndex() < res.answer:\r\n\r\n                        # Get block\r\n                        getBlockReq = Networking.GetBlockRequest(self.groupId, self.getLastBlockIndex() + 1)\r\n                        blockRes = Networking.sendRequest(peer[0], 6700, dumps(getBlockReq))\r\n                        if blockRes is not False:\r\n                            print(f\"Update BC Response:{blockRes}\")\r\n                            print(blockRes.answer)\r\n                            block = blockRes.answer\r\n                            block: Block\r\n                            print(block.index, block.transaction, block.signatures, block.timestamp,\r\n                                  block.previous_hash, block.hash)\r\n                            newBlock = Block(block.index, block.transaction, block.timestamp, block.previous_hash,\r\n                                  block.signatures)\r\n                            newBlock.hash = block.hash\r\n                            print(newBlock)\r\n                            # Save Block\r\n                            # Append to blockchain\r\n                        else:\r\n                            break\r\n\r\n    def getBlockWithIndex(self, index):\r\n        for block in self.chain:\r\n            block: Block\r\n            if block.index == index:\r\n                return block\r\n        return False\r\n\r\n    def mine(self):\r\n        # Load my public key.\r\n        keyLoc = self.BLOCKCHAIN_PATH + \"\\\\..\\\\..\\\\..\\\\PRIVATEKEY.json\"\r\n        # print(f\"key location = {keyLoc}\")\r\n        f = open(keyLoc, \"rb\")\r\n        data = f.read()\r\n        privateKey = rsa.PrivateKey.load_pkcs1(data)\r\n        # print(publicKey)\r\n        f.close()\r\n        while True:\r\n            # Update Blockchain.\r\n            self.updateBlockchain()\r\n\r\n            if not self.unconfirmed_transactions:\r\n                # If No Transaction sleep and check again soon.\r\n                sleep(30)\r\n            else:\r\n                diff = self.getDifficulty()\r\n                print(f\"Blockchain Difficulty :{diff}\")\r\n                print(f\"Unconfirmed Transactions:{len(self.unconfirmed_transactions)}\")\r\n                for transaction in self.unconfirmed_transactions:\r\n                    transaction: UnconfirmedTransaction\r\n                    # For Each Transaction if signatures < difficulty collect transactions\r\n                    if diff > len(transaction.signatures):\r\n                        if not len(transaction.signatures):\r\n                            # No Signatures add my signature\r\n                            signature = rsa.sign(transaction.transaction.encode(), privateKey, 'SHA-1')\r\n                            transaction.signatures.append(str(signature))\r\n                            self.save_unconfirmed_transactions()\r\n                        else:\r\n                            # Get Signatures from other persons.\r\n                            pass\r\n                    else:\r\n                        # We have the signatures number procede to make block and share.\r\n                        print(f\"Signature {transaction} ready to be made block.\")\r\n                        # Bytes\r\n                        lastBlock = self.getLastBlock()\r\n                        print(lastBlock)\r\n                        lastBlock: Block\r\n                        print(f\"Last Block Index :{lastBlock.index}\")\r\n                        newBlock = Block(lastBlock.index + 1, transaction.transaction, str(time.time()),\r\n                                         lastBlock.compute_hash(), transaction.signatures)\r\n                        newBlock.hash = newBlock.compute_hash()\r\n                        self.unconfirmed_transactions.remove(transaction)\r\n                        self.save_unconfirmed_transactions()\r\n                        self.saveBlock(newBlock)\r\n                        self.chain.append(newBlock)\r\n                sleep(30)\r\n\r\n    def getLastBlock(self):\r\n        lastBlockIndex = self.chain[0].index\r\n        # Find last Block and return it\r\n        lastBlock = self.chain[0]\r\n        for block in self.chain:\r\n            # print(block.index)\r\n            if block.index > lastBlockIndex:\r\n                lastBlock = block\r\n                lastBlockIndex = block.index\r\n        return lastBlock\r\n\r\n    def getLastBlockIndex(self):\r\n        if len(self.chain) == 0:\r\n            return -1\r\n        else:\r\n            lastBlockIndex = self.chain[0].index\r\n            # Find last Block and return it\r\n            lastBlock = self.chain[0]\r\n            for block in self.chain:\r\n                # print(block.index)\r\n                if block.index > lastBlockIndex:\r\n                    lastBlock = block\r\n                    lastBlockIndex = block.index\r\n            return lastBlock.index\r\n\r\n    def save_unconfirmed_transactions(self):\r\n        # print(self.TRANSACTION_PATH)\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Blockchain Folder\")\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n        json_file = open(self.TRANSACTION_PATH + \"Transactions\" + \".json\", \"w\")\r\n        json_file.write((json.dumps([ob.__dict__ for ob in self.unconfirmed_transactions])))\r\n        json_file.close()\r\n\r\n    def isUserAllowed(self, ip):\r\n        for block in self.chain:\r\n            block: Block\r\n            transaction = json.loads(block.transaction)\r\n            # From Create Genesis Block\r\n            if transaction[\"type\"] == 0:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n            # From Invite\r\n            if transaction[\"type\"] == 1:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n        # Didndt find user\r\n        return False\r\n\r\n\r\nimport Networking\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Blockchain.py b/Blockchain.py
--- a/Blockchain.py	(revision 9bbfdef33dc53e171c51c996b292dedf27dd481f)
+++ b/Blockchain.py	(date 1650545735854)
@@ -22,7 +22,7 @@
 
         self.signatures = signatures
 
-    def compute_hash(self):
+    def computeHash(self):
         mycopy = copy.copy(self)
         del mycopy.signatures
         # print(mycopy.__dict__)
@@ -92,7 +92,7 @@
         else:
             return len(self.peers)
 
-    def create_genesis_block(self, client):
+    def createGenesisBlock(self, client):
         transaction = GenesisTransaction(client.publicIP, client.publicKey.save_pkcs1(format='PEM').decode("utf-8"))
         transactionStr = json.dumps(transaction.__dict__)
         # this is string json format
@@ -107,7 +107,7 @@
         # print(signature.__class__)
 
         genesis_block = Block(0, transactionStr, str(time.time()), "0", [str(signature)])
-        genesis_block.hash = genesis_block.compute_hash()
+        genesis_block.hash = genesis_block.computeHash()
         self.saveBlock(genesis_block)
         self.chain.append(genesis_block)
 
@@ -170,10 +170,10 @@
         self.chain.append(blockObj)
         # print(blockObj.__dict__)
 
-    def add_new_transaction(self, transaction: str):
+    def addNewTransaction(self, transaction: str):
         newUnconfirmedTransaction = UnconfirmedTransaction(transaction)
         self.unconfirmed_transactions.append(newUnconfirmedTransaction)
-        self.save_unconfirmed_transactions()
+        self.saveUnconfirmedTransactions()
 
     def updateBlockchain(self):
         for peer in self.peers:
@@ -199,9 +199,9 @@
                             newBlock = Block(block.index, block.transaction, block.timestamp, block.previous_hash,
                                   block.signatures)
                             newBlock.hash = block.hash
-                            print(newBlock)
-                            # Save Block
-                            # Append to blockchain
+                            if self.validateNewBlock(newBlock):
+                                self.saveBlock(newBlock)
+                                self.chain.append(newBlock)
                         else:
                             break
 
@@ -212,6 +212,24 @@
                 return block
         return False
 
+    def validateNewBlock(self,newBlock):
+        """This function is for new blocks that come from peers returns true if blocks checks out."""
+        newBlock : Block
+
+
+        if newBlock.index ==0:
+            # Validation for genesis blocks
+            transactionStr = newBlock.transaction
+            transactionJSON = json.loads(transactionStr)
+            print(transactionJSON)
+            #Load Transaction
+
+
+        else:
+            #Validation for everything else
+            pass
+
+
     def mine(self):
         # Load my public key.
         keyLoc = self.BLOCKCHAIN_PATH + "\\..\\..\\..\\PRIVATEKEY.json"
@@ -240,7 +258,7 @@
                             # No Signatures add my signature
                             signature = rsa.sign(transaction.transaction.encode(), privateKey, 'SHA-1')
                             transaction.signatures.append(str(signature))
-                            self.save_unconfirmed_transactions()
+                            self.saveUnconfirmedTransactions()
                         else:
                             # Get Signatures from other persons.
                             pass
@@ -253,10 +271,10 @@
                         lastBlock: Block
                         print(f"Last Block Index :{lastBlock.index}")
                         newBlock = Block(lastBlock.index + 1, transaction.transaction, str(time.time()),
-                                         lastBlock.compute_hash(), transaction.signatures)
-                        newBlock.hash = newBlock.compute_hash()
+                                         lastBlock.computeHash(), transaction.signatures)
+                        newBlock.hash = newBlock.computeHash()
                         self.unconfirmed_transactions.remove(transaction)
-                        self.save_unconfirmed_transactions()
+                        self.saveUnconfirmedTransactions()
                         self.saveBlock(newBlock)
                         self.chain.append(newBlock)
                 sleep(30)
@@ -286,7 +304,7 @@
                     lastBlockIndex = block.index
             return lastBlock.index
 
-    def save_unconfirmed_transactions(self):
+    def saveUnconfirmedTransactions(self):
         # print(self.TRANSACTION_PATH)
         if not os.path.exists(self.TRANSACTION_PATH):
             # Create a new directory because it does not exist
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import json\r\nimport logging\r\nimport threading\r\nfrom pickle import dumps, loads\r\nfrom flask import Flask, render_template, request, redirect\r\n\r\nimport Blockchain\r\nimport Compress\r\nfrom Networking import receiver, sendRequest, JoinRequest,SearchBundleRequest,receiveBundle,GetBundleRequest\r\nfrom Groups import GroupManager, Invite,Group\r\nfrom Client import Client\r\nimport easygui\r\nfrom Bundles import BundleManager\r\nfrom Downloads import DownloadManager\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = True\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    progress = downloadManager.getDownloadProgress()\r\n    return render_template(\"index.html\", groups=groupManager.groups,client=client,progress=progress)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    group = groupManager.getGroupWithName(group)\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    if downloadManager.STATUS:\r\n        downloadManager.STATUS = False\r\n        #downloadManager Off\r\n        print(\"Download Manager Not Active\")\r\n        return \"0\"\r\n    else:\r\n        downloadManager.STATUS = True\r\n        #downloadManager On\r\n        print(\"Download Manager Active\")\r\n        return \"1\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n        # TODO KEY SPECIFIC BLOCKCHAIN\r\n        ip = data[\"ip\"] #This is string\r\n        transaction = Blockchain.InviteTransaction(ip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.add_new_transaction(transactionStr)\r\n        # print(\"Generate Invite for :\", group)\r\n        # print(group)\r\n        invite = group.generateInvite()\r\n        return Compress.compress(invite.toJSON())\r\n\r\n@app.route('/deleteBundle', methods=['POST'])\r\ndef deleteBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupId = data[\"groupId\"]\r\n        bundleId = data[\"bundleId\"]\r\n        if groupManager.deleteBundle(groupId,bundleId):\r\n            return \"1\"\r\n        else:\r\n            return \"0\"\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        inviteDecomp = Compress.decompress(invite)\r\n        inviteLoad = json.loads(inviteDecomp)\r\n        invite = Invite(inviteLoad[\"id\"],inviteLoad[\"name\"], inviteLoad[\"timestamp\"], inviteLoad[\"peers\"])\r\n        joinReq = JoinRequest(invite.name, invite.timestamp)\r\n        print(invite.peers)\r\n        for peer in invite.peers:\r\n            print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq))\r\n            if res is not False:\r\n                group = res.group\r\n                group = Group(group.name,group.admins,group.peers,group.timestamp,blockchainPath=groupManager.DIR_PATH_GROUPS+group.name+\"\\\\Blockchain\")\r\n                groupManager.addGroup(group)\r\n        #Make thread to update blockhain and get up to date.\r\n        #TODO if fail do something.\r\n        return \"1\"\r\n\r\n\r\n@app.route('/shareBundle', methods=['POST'])\r\ndef shareBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"bundleName\"]\r\n        desc = data[\"bundleDescription\"]\r\n        groupName = data[\"groupName\"]\r\n        print(name)\r\n        print(desc)\r\n        print(groupName)\r\n        path = easygui.diropenbox(msg=\"Select folder to share as bundle\", title=\"Share Bundle\")\r\n        bundle = bundleManager.createBundle(name,desc,path=path)\r\n        groupManager.addBundle(bundle,groupName)\r\n        return \"0\"\r\n\r\n@app.route('/selectDownloadLocation', methods=['POST'])\r\ndef selectDownloadLocation():\r\n    if request.method == 'POST':\r\n        path = easygui.diropenbox(msg=\"Select folder to download bundles\", title=\"Select Bundle Download Location\")\r\n        print(path)\r\n        #Update Download Path in Config\r\n        client.DIR_PATH_DOWNLOADS=path\r\n        client.saveConfig()\r\n        #Return path to browser and update it in modal\r\n        return path\r\n\r\n@app.route('/searchBundles', methods=['POST'])\r\ndef searchBundles():\r\n    # print(\"Search Bundles Route\")\r\n    if request.method == 'POST':\r\n        data = request.form\r\n\r\n        #Get Keywords from search\r\n        keywords = data[\"searchKeyWords\"].split()\r\n        # print(\"Search for :\",keywords)\r\n\r\n        #Get Group\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n\r\n        searchReq = SearchBundleRequest(group.id,keywords)\r\n        responses = []\r\n        # SEND TO ALL PEERS COLLECT RESPONSES AND PRESENT\r\n        for peer in group.peers:\r\n            res = sendRequest(peer[0], 6700, dumps(searchReq))\r\n            #if other peer is responded.\r\n            if res is not False:\r\n                # print(res)\r\n                responses.append([peer[0],res])\r\n            else:\r\n                print(\"No Response from\",peer[0])\r\n        #Merge all responses to single list\r\n        # for x in responses:\r\n        #     print(\"Response:\",x[0],x[1],x[1].responseBundles)\r\n        #WITH RESPONSES DO STUFF.\r\n        #Respond\r\n        return render_template(\"search.html\", groups=groupManager.groups, group=group , responses = responses)\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n    if groupManager.createGroup(name, [client.publicIP]):\r\n        #Make First Block In Blockchain Append Admin\r\n        #Type 0 First Created\r\n        group = groupManager.getGroupWithName(name)\r\n        group.blockchain.create_genesis_block(client)\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n@app.route('/getBundle', methods=['POST'])\r\ndef getBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        bundleId = data[\"bundleId\"]\r\n        groupId = data[\"groupId\"]\r\n        userIp = data[\"userIp\"]\r\n        #TODO dynamic port on receiver for bundle\r\n        portForBundleReceiver = 6701\r\n        bundleReceiver = threading.Thread(target=receiveBundle, args=[portForBundleReceiver,client,groupManager,groupId,downloadManager])\r\n        bundleReceiver.start()\r\n        getBundleReq = GetBundleRequest(bundleId,groupId,portForBundleReceiver)\r\n        res = sendRequest(userIp, 6700, dumps(getBundleReq))\r\n        # if other peer is responded.\r\n        if res is not False:\r\n            #Responded decide what to do\r\n            pass\r\n        else:\r\n            # print(\"No Response from\", userIp)\r\n            pass\r\n    return \"1\"\r\n\r\n\r\n@app.route('/quitGroup', methods=['POST'])\r\ndef quitGroup():\r\n    # print('QUIT GROUP REQ')\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        if groupManager.quitGroup(group):\r\n            # True\r\n            return \"0\"\r\n        else:\r\n            # False\r\n            return \"1\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    groupManager = GroupManager()\r\n    bundleManager = BundleManager()\r\n    downloadManager = DownloadManager(groupManager,client)\r\n    #TODO Networking Thread To Receive From Internet\r\n    receiver = threading.Thread(target=receiver, args=[groupManager])\r\n    receiver.start()\r\n    app.run(host='', port=6969)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 9bbfdef33dc53e171c51c996b292dedf27dd481f)
+++ b/main.py	(date 1650545818448)
@@ -18,7 +18,7 @@
 # This Disables Logging
 app.logger.disabled = False
 log = logging.getLogger('werkzeug')
-log.disabled = True
+log.disabled = False
 
 
 # Routes
@@ -60,7 +60,7 @@
         ip = data["ip"] #This is string
         transaction = Blockchain.InviteTransaction(ip)
         transactionStr = json.dumps(transaction.__dict__)
-        group.blockchain.add_new_transaction(transactionStr)
+        group.blockchain.addNewTransaction(transactionStr)
         # print("Generate Invite for :", group)
         # print(group)
         invite = group.generateInvite()
@@ -167,7 +167,7 @@
         #Make First Block In Blockchain Append Admin
         #Type 0 First Created
         group = groupManager.getGroupWithName(name)
-        group.blockchain.create_genesis_block(client)
+        group.blockchain.createGenesisBlock(client)
         # True
         return "0"
     else:
Index: decap/files_small/crypt_and_hashing.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import rsa\r\n\r\n# https://stuvel.eu/python-rsa-doc/usage.html\r\npeer1pub, peer1prv = rsa.newkeys(512)\r\npeer2pub, peer2prv = rsa.newkeys(512)\r\npeer3pub, peer3prv = rsa.newkeys(512)\r\n\r\nmessage = \"Verify\".encode(\"utf8\")\r\n\r\ncrypto = rsa.encrypt(message, peer1pub)\r\nprint(crypto)\r\nmessage = rsa.decrypt(crypto, peer1prv)\r\nprint(message.decode('utf8'))\r\n\r\n\r\nhash = rsa.compute_hash(message, 'SHA-1')\r\n\r\npeer1signature = rsa.sign_hash(hash, peer1prv, 'SHA-1')\r\npeer2signature = rsa.sign_hash(hash, peer2prv, 'SHA-1')\r\npeer3signature = rsa.sign_hash(hash, peer3prv, 'SHA-1')\r\n\r\nprint(rsa.verify(message, peer1signature, peer1pub))\r\nprint(rsa.verify(message, peer2signature, peer2pub))\r\n#\r\n# message = 'Go right at the blue tree'.encode()\r\n# rsa.verify(message, signature, pubkey)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/decap/files_small/crypt_and_hashing.py b/decap/files_small/crypt_and_hashing.py
--- a/decap/files_small/crypt_and_hashing.py	(revision 9bbfdef33dc53e171c51c996b292dedf27dd481f)
+++ b/decap/files_small/crypt_and_hashing.py	(date 1650544946378)
@@ -13,7 +13,7 @@
 print(message.decode('utf8'))
 
 
-hash = rsa.compute_hash(message, 'SHA-1')
+hash = rsa.computeHash(message, 'SHA-1')
 
 peer1signature = rsa.sign_hash(hash, peer1prv, 'SHA-1')
 peer2signature = rsa.sign_hash(hash, peer2prv, 'SHA-1')
Index: decap/crypt_and_hashing.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import rsa\r\nimport base64\r\n# https://stuvel.eu/python-rsa-doc/usage.html\r\npeer1pub, peer1prv = rsa.newkeys(512)\r\npeer2pub, peer2prv = rsa.newkeys(512)\r\npeer3pub, peer3prv = rsa.newkeys(512)\r\n\r\nmessage = \"Verify\".encode(\"utf8\")\r\n\r\ncrypto = rsa.encrypt(message, peer1pub)\r\n# print(crypto)\r\nmessage = rsa.decrypt(crypto, peer1prv)\r\n# print(message.decode('utf8'))\r\n\r\n\r\nhash = rsa.compute_hash(message, 'SHA-1')\r\n\r\npeer1signature = rsa.sign_hash(hash, peer1prv, 'SHA-1')\r\npeer2signature = rsa.sign_hash(hash, peer2prv, 'SHA-1')\r\npeer3signature = rsa.sign_hash(hash, peer3prv, 'SHA-1')\r\nprint(peer3signature.encode())\r\n\r\n# print(rsa.verify(message, peer1signature, peer1pub))\r\n# print(rsa.verify(message, peer2signature, peer2pub))\r\n#\r\n# message = 'Go right at the blue tree'.encode()\r\n# rsa.verify(message, signature, pubkey)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/decap/crypt_and_hashing.py b/decap/crypt_and_hashing.py
--- a/decap/crypt_and_hashing.py	(revision 9bbfdef33dc53e171c51c996b292dedf27dd481f)
+++ b/decap/crypt_and_hashing.py	(date 1650544946351)
@@ -13,7 +13,7 @@
 # print(message.decode('utf8'))
 
 
-hash = rsa.compute_hash(message, 'SHA-1')
+hash = rsa.computeHash(message, 'SHA-1')
 
 peer1signature = rsa.sign_hash(hash, peer1prv, 'SHA-1')
 peer2signature = rsa.sign_hash(hash, peer2prv, 'SHA-1')
Index: decap/files_small/blockchain.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\r\nfrom hashlib import sha256\r\nimport json\r\n\r\n\r\nclass Block:\r\n    def __init__(self, index, transactions, timestamp, previous_hash, nonce=0):\r\n        self.index = index\r\n        self.transactions = transactions\r\n        self.timestamp = timestamp\r\n        self.previous_hash = previous_hash\r\n        self.nonce = nonce\r\n\r\n    def compute_hash(self):\r\n        block_string = json.dumps(self.__dict__, sort_keys=True)\r\n        return sha256(block_string.encode()).hexdigest()\r\n\r\nclass Blockchain:\r\n    difficulty = 6\r\n\r\n    def __init__(self):\r\n        self.unconfirmed_transactions = []\r\n        self.chain = []\r\n        self.create_genesis_block()\r\n\r\n    def create_genesis_block(self):\r\n        genesis_block = Block(0, [], time.time(), \"0\")\r\n        genesis_block.hash = genesis_block.compute_hash()\r\n        self.chain.append(genesis_block)\r\n\r\n    @property\r\n    def last_block(self):\r\n        return self.chain[-1]\r\n\r\n    def proof_of_work(self, block):\r\n        block.nonce = 0\r\n        computed_hash = block.compute_hash()\r\n        print(\"Starting Mining\")\r\n        while not computed_hash.startswith('0' * Blockchain.difficulty):\r\n            block.nonce += 1\r\n            computed_hash = block.compute_hash()\r\n        print(\"Mining Ended Nonce :\", block.nonce)\r\n        return computed_hash\r\n\r\n    def add_block(self, block, proof):\r\n        previous_hash = self.last_block.hash\r\n        if previous_hash != block.previous_hash:\r\n            return False\r\n        if not self.is_valid_proof(block, proof):\r\n            return False\r\n        block.hash = proof\r\n        self.chain.append(block)\r\n        return True\r\n\r\n    def is_valid_proof(self, block, block_hash):\r\n        return (block_hash.startswith('0' * Blockchain.difficulty) and\r\n                block_hash == block.compute_hash())\r\n\r\n    def add_new_transaction(self, transaction):\r\n        self.unconfirmed_transactions.append(transaction)\r\n\r\n    def mine(self):\r\n        if not self.unconfirmed_transactions:\r\n            return False\r\n\r\n        last_block = self.last_block\r\n\r\n        new_block = Block(index=last_block.index + 1,\r\n                          transactions=self.unconfirmed_transactions,\r\n                          timestamp=time.time(),\r\n                          previous_hash=last_block.hash)\r\n\r\n        proof = self.proof_of_work(new_block)\r\n        self.add_block(new_block, proof)\r\n        self.unconfirmed_transactions = []\r\n        return new_block.index\r\n\r\n\r\nif __name__ == '__main__':\r\n    blockchain = Blockchain()\r\n    blockchain.add_new_transaction(\"A INVITED 8.8.8.8\")\r\n    blockchain.add_new_transaction(\"8.8.8.8 Joined\")\r\n    mine_response = blockchain.mine()\r\n    print(mine_response)\r\n    print(blockchain.last_block.transactions)\r\n    blockchain.add_new_transaction(\"8.8.8.8 Joined\")\r\n    blockchain.add_new_transaction(\"8.8.8.8 Shared File asdasdasdasd\")\r\n    mine_response = blockchain.mine()\r\n    print(mine_response)\r\n    print(blockchain.last_block.transactions)\r\n    blockchain.add_new_transaction(\"B ivited 1.1.1.1\")\r\n    blockchain.add_new_transaction(\"8.8.8.8 Joined\")\r\n    blockchain.add_new_transaction(\"8.8.8.8 Joined\")\r\n    mine_response = blockchain.mine()\r\n    print(mine_response)\r\n    print(blockchain.last_block.transactions)\r\n    blockchain.add_new_transaction(\"8.8.8.8 Joined\")\r\n    blockchain.add_new_transaction(\"8.8.8.8 Joined\")\r\n    mine_response = blockchain.mine()\r\n    print(mine_response)\r\n    print(blockchain.last_block.transactions)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/decap/files_small/blockchain.py b/decap/files_small/blockchain.py
--- a/decap/files_small/blockchain.py	(revision 9bbfdef33dc53e171c51c996b292dedf27dd481f)
+++ b/decap/files_small/blockchain.py	(date 1650544946365)
@@ -34,11 +34,11 @@
 
     def proof_of_work(self, block):
         block.nonce = 0
-        computed_hash = block.compute_hash()
+        computed_hash = block.computeHash()
         print("Starting Mining")
         while not computed_hash.startswith('0' * Blockchain.difficulty):
             block.nonce += 1
-            computed_hash = block.compute_hash()
+            computed_hash = block.computeHash()
         print("Mining Ended Nonce :", block.nonce)
         return computed_hash
 
@@ -54,7 +54,7 @@
 
     def is_valid_proof(self, block, block_hash):
         return (block_hash.startswith('0' * Blockchain.difficulty) and
-                block_hash == block.compute_hash())
+                block_hash == block.computeHash())
 
     def add_new_transaction(self, transaction):
         self.unconfirmed_transactions.append(transaction)
Index: decap/blockchain.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\r\nfrom hashlib import sha256\r\nimport json\r\n\r\n\r\nclass Block:\r\n    def __init__(self, index, transactions, timestamp, previous_hash, nonce=0):\r\n        self.index = index\r\n        self.transactions = transactions\r\n        self.timestamp = timestamp\r\n        self.previous_hash = previous_hash\r\n        self.nonce = nonce\r\n\r\n    def compute_hash(self):\r\n        block_string = json.dumps(self.__dict__, sort_keys=True)\r\n        return sha256(block_string.encode()).hexdigest()\r\n\r\nclass Blockchain:\r\n    difficulty = 5\r\n\r\n    def __init__(self):\r\n        self.unconfirmed_transactions = []\r\n        self.chain = []\r\n        self.create_genesis_block()\r\n\r\n    def create_genesis_block(self):\r\n        genesis_block = Block(0, [], time.time(), \"0\")\r\n        genesis_block.hash = genesis_block.compute_hash()\r\n        self.chain.append(genesis_block)\r\n\r\n    @property\r\n    def last_block(self):\r\n        return self.chain[-1]\r\n\r\n    def proof_of_work(self, block):\r\n        block.nonce = 0\r\n        computed_hash = block.compute_hash()\r\n        print(\"Starting Mining\")\r\n        while not computed_hash.startswith('0' * Blockchain.difficulty):\r\n            block.nonce += 1\r\n            computed_hash = block.compute_hash()\r\n        print(\"Mining Ended Nonce :\", block.nonce)\r\n        return computed_hash\r\n\r\n    def add_block(self, block, proof):\r\n        previous_hash = self.last_block.hash\r\n        if previous_hash != block.previous_hash:\r\n            return False\r\n        if not self.is_valid_proof(block, proof):\r\n            return False\r\n        block.hash = proof\r\n        self.chain.append(block)\r\n        return True\r\n\r\n    def is_valid_proof(self, block, block_hash):\r\n        return (block_hash.startswith('0' * Blockchain.difficulty) and\r\n                block_hash == block.compute_hash())\r\n\r\n    def add_new_transaction(self, transaction):\r\n        self.unconfirmed_transactions.append(transaction)\r\n\r\n    def mine(self):\r\n        if not self.unconfirmed_transactions:\r\n            return False\r\n\r\n        last_block = self.last_block\r\n\r\n        new_block = Block(index=last_block.index + 1,\r\n                          transactions=self.unconfirmed_transactions,\r\n                          timestamp=time.time(),\r\n                          previous_hash=last_block.hash)\r\n\r\n        proof = self.proof_of_work(new_block)\r\n        self.add_block(new_block, proof)\r\n        self.unconfirmed_transactions = []\r\n        return new_block.index\r\n\r\n\r\nif __name__ == '__main__':\r\n    blockchain = Blockchain()\r\n    blockchain.add_new_transaction(\"A INVITED 8.8.8.8\")\r\n    blockchain.add_new_transaction(\"8.8.8.8 Joined\")\r\n    mine_response = blockchain.mine()\r\n    print(mine_response)\r\n    print(blockchain.last_block.transactions)\r\n    blockchain.add_new_transaction(\"8.8.8.8 Joined\")\r\n    blockchain.add_new_transaction(\"8.8.8.8 Shared File asdasdasdasd\")\r\n    mine_response = blockchain.mine()\r\n    print(mine_response)\r\n    print(blockchain.last_block.transactions)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/decap/blockchain.py b/decap/blockchain.py
--- a/decap/blockchain.py	(revision 9bbfdef33dc53e171c51c996b292dedf27dd481f)
+++ b/decap/blockchain.py	(date 1650544946339)
@@ -34,11 +34,11 @@
 
     def proof_of_work(self, block):
         block.nonce = 0
-        computed_hash = block.compute_hash()
+        computed_hash = block.computeHash()
         print("Starting Mining")
         while not computed_hash.startswith('0' * Blockchain.difficulty):
             block.nonce += 1
-            computed_hash = block.compute_hash()
+            computed_hash = block.computeHash()
         print("Mining Ended Nonce :", block.nonce)
         return computed_hash
 
@@ -54,7 +54,7 @@
 
     def is_valid_proof(self, block, block_hash):
         return (block_hash.startswith('0' * Blockchain.difficulty) and
-                block_hash == block.compute_hash())
+                block_hash == block.computeHash())
 
     def add_new_transaction(self, transaction):
         self.unconfirmed_transactions.append(transaction)
