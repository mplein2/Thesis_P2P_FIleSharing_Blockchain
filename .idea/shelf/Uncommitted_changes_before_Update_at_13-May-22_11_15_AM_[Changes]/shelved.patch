Index: .idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_53_AM_[Changes]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_53_AM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_53_AM_[Changes]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_53_AM_[Changes]/shelved.patch	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,101 +0,0 @@
-Index: Blockchain.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import os\r\nimport json\r\nfrom os import listdir\r\nimport rsa\r\nimport time\r\nfrom time import sleep\r\nimport threading\r\nfrom hashlib import sha256\r\nimport copy\r\nfrom pickle import dumps, loads\r\n\r\n\r\n\r\nclass Block:\r\n    def __init__(self, index, transaction, timestamp, previous_hash, signatures):\r\n        self.index = index\r\n\r\n        self.transaction = transaction\r\n\r\n        self.timestamp = timestamp\r\n\r\n        self.previous_hash = previous_hash\r\n\r\n        self.signatures = signatures\r\n\r\n    def compute_hash(self):\r\n        mycopy = copy.copy(self)\r\n        del mycopy.signatures\r\n        # print(mycopy.__dict__)\r\n        if hasattr(mycopy, 'hash'):\r\n            del mycopy.hash\r\n        block_string = json.dumps(mycopy.__dict__, sort_keys=True)\r\n        return sha256(block_string.encode()).hexdigest()\r\n\r\nclass UnconfirmedTransaction:\r\n    def __init__(self,transaction,signatures=[]):\r\n        self.transaction = transaction\r\n        self.signatures = signatures\r\n\r\n\r\nclass GenesisTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 0\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass InviteTransaction:\r\n    def __init__(self,ip):\r\n        self.type = 1\r\n        self.ip = ip\r\n\r\n\r\nclass Blockchain:\r\n    def __init__(self, path, groupPeers,groupId):\r\n        self.BLOCKCHAIN_PATH = path\r\n        self.TRANSACTION_PATH = self.BLOCKCHAIN_PATH + \"\\\\Transactions\\\\\"\r\n        self.unconfirmed_transactions = []\r\n        self.chain = []\r\n        self.peers = groupPeers\r\n        self.groupId = groupId\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n            # Load Unconfirmed Transactions\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n\r\n\r\n        self.loadTransactions()\r\n\r\n        # print(self.unconfirmed_transactions)\r\n        # Load Blocks here\r\n        blockFiles = [f for f in listdir(self.BLOCKCHAIN_PATH) if os.path.isfile(os.path.join(self.BLOCKCHAIN_PATH, f))]\r\n        for blockFile in blockFiles:\r\n            self.loadBlock(blockFile)\r\n\r\n        # Start Casual Operations.\r\n        # Thread This.\r\n        miner = threading.Thread(target=self.mine, args=[])\r\n        miner.start()\r\n        # print(self.unconfirmed_transactions)\r\n        # for block in self.chain:\r\n        #     print(block)\r\n\r\n    def getDifficulty(self):\r\n        # Diffuculty of blockchain will be dependent on the users participating\r\n        # TODO refactor this for join ban unban\r\n        if len(self.peers) == 0:\r\n            return 1\r\n        else:\r\n            return len(self.peers)\r\n\r\n    def create_genesis_block(self, client):\r\n        transaction = GenesisTransaction(client.publicIP, client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        # this is string json format\r\n        # print(transactionStr)\r\n        # print(transactionStr.__class__)\r\n        # Genereate signature for Transaction\r\n\r\n        signature = rsa.sign(transactionStr.encode(), client.privateKey, 'SHA-1')\r\n\r\n        # Bytes\r\n        # print(signature)\r\n        # print(signature.__class__)\r\n\r\n        genesis_block = Block(0, transactionStr, str(time.time()), \"0\", [str(signature)])\r\n        genesis_block.hash = genesis_block.compute_hash()\r\n        self.saveBlock(genesis_block)\r\n        self.chain.append(genesis_block)\r\n\r\n    def saveBlock(self, block):\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Creating Blockchain Folder\")\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n        blockFile = open(self.BLOCKCHAIN_PATH + \"\\\\Block\" + str(block.index) + \".json\", \"w\")\r\n        # print(block.__dict__)\r\n        blockFile.write(json.dumps(block.__dict__))\r\n        blockFile.close()\r\n\r\n    def loadTransactions(self):\r\n        filePath = self.TRANSACTION_PATH + \"Transactions.json\"\r\n        if os.path.exists(filePath):\r\n            try:\r\n                file = open(filePath)\r\n                # print(file)\r\n                json_load_group = json.load(file)\r\n                file.close()\r\n            except Exception as e:\r\n                print(\"Error Opening Transaction file :\", e)\r\n            for x in json_load_group:\r\n                transaction = UnconfirmedTransaction(x[\"transaction\"], x[\"signatures\"])\r\n                # print(transaction)\r\n                self.unconfirmed_transactions.append(transaction)\r\n            # print(self.unconfirmed_transactions)\r\n\r\n    def loadBlock(self, blockFiles):\r\n        # print(blockFiles)\r\n        filePath = self.BLOCKCHAIN_PATH + \"\\\\\" + blockFiles\r\n        file = open(filePath)\r\n        # print(file)\r\n        block = json.load(file)\r\n        file.close()\r\n        # # print(block)\r\n        # transaction = json.loads(block[\"transaction\"])\r\n        # # print(transaction)\r\n        # # print(transaction.__class__)\r\n        # # Make transaction here\r\n        # if transaction[\"type\"] == 0:\r\n        #     # print(\"Genesis block\")\r\n        #     transactionObj = GenesisTransaction(transaction[\"ip\"], transaction[\"publicKey\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        blockObj = Block(block[\"index\"], block[\"transaction\"], block[\"timestamp\"], block[\"previous_hash\"],\r\n                             block[\"signatures\"])\r\n        blockObj.hash = block[\"hash\"]\r\n        #TODO Add all transactions here\r\n\r\n        # elif transaction[\"type\"] == 1:\r\n        #     # print(\"Genesis block\")\r\n        #     # print(transaction)\r\n        #     transactionObj = InviteTransaction(transaction[\"ip\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        #     blockObj = Block(block[\"index\"], transactionStr, block[\"timestamp\"], block[\"previous_hash\"],\r\n        #                      block[\"signatures\"])\r\n        #     blockObj.hash = block[\"hash\"]\r\n\r\n        self.chain.append(blockObj)\r\n            # print(blockObj.__dict__)\r\n\r\n    def add_new_transaction(self, transaction : str):\r\n        newUnconfirmedTransaction = UnconfirmedTransaction(transaction)\r\n        self.unconfirmed_transactions.append(newUnconfirmedTransaction)\r\n        self.save_unconfirmed_transactions()\r\n\r\n    def updateBlockchain(self):\r\n        responses = []\r\n        for peer in self.peers:\r\n            # print(\"Peer to ask for update:\",peer)\r\n            updateBlockchainReq = Networking.UpdateBlockchainRequest(self.groupId)\r\n            res = Networking.sendRequest(peer[0], 6700, dumps(updateBlockchainReq))\r\n            print(res)\r\n            if res is not False:\r\n                 responses.append(res)\r\n        if len(responses):\r\n            for x in res:\r\n                print(x.answer)\r\n            #Someone answered.\r\n            # update from responded peers until you have max blockchain thing .\r\n\r\n    def mine(self):\r\n        #Load my public key.\r\n        keyLoc = self.BLOCKCHAIN_PATH+\"..\\\\..\\\\..\\\\PRIVATEKEY.json\"\r\n        # print(f\"key location = {keyLoc}\")\r\n        f = open(keyLoc, \"rb\")\r\n        data = f.read()\r\n        privateKey = rsa.PrivateKey.load_pkcs1(data)\r\n        # print(publicKey)\r\n        f.close()\r\n        while True:\r\n                #Update Blockchain.\r\n                self.updateBlockchain()\r\n\r\n                if not self.unconfirmed_transactions:\r\n                    #If No Transaction sleep and check again soon.\r\n                    sleep(30)\r\n                else:\r\n                    diff = self.getDifficulty()\r\n                    print(f\"Blockchain Difficulty :{diff}\")\r\n                    print(f\"Unconfirmed Transactions:{len(self.unconfirmed_transactions)}\")\r\n                    for transaction in self.unconfirmed_transactions:\r\n                        transaction :UnconfirmedTransaction\r\n                        #For Each Transaction if signatures < difficulty collect transactions\r\n                        if diff>len(transaction.signatures):\r\n                            if not len(transaction.signatures):\r\n                                # No Signatures add my signature\r\n                                signature = rsa.sign(transaction.transaction.encode(),privateKey, 'SHA-1')\r\n                                transaction.signatures.append(str(signature))\r\n                                self.save_unconfirmed_transactions()\r\n                            else:\r\n                                #Get Signatures from other persons.\r\n                                pass\r\n                        else:\r\n                            #We have the signatures number procede to make block and share.\r\n                            print(f\"Signature {transaction} ready to be made block.\")\r\n                            # Bytes\r\n                            lastBlock = self.getLastBlock()\r\n                            print(lastBlock)\r\n                            lastBlock : Block\r\n                            print(f\"Last Block Index :{lastBlock.index}\")\r\n                            newBlock = Block(lastBlock.index+1, transaction.transaction, str(time.time()), lastBlock.compute_hash(),transaction.signatures)\r\n                            newBlock.hash = newBlock.compute_hash()\r\n                            self.unconfirmed_transactions.remove(transaction)\r\n                            self.save_unconfirmed_transactions()\r\n                            self.saveBlock(newBlock)\r\n                            self.chain.append(newBlock)\r\n                    sleep(30)\r\n\r\n    def getLastBlock(self):\r\n        lastBlockIndex = self.chain[0].index\r\n        #Find last Block and return it\r\n        lastBlock = self.chain[0]\r\n        for block in self.chain:\r\n            print(block.index)\r\n            if block.index > lastBlockIndex:\r\n                lastBlock = block\r\n                lastBlockIndex = block.index\r\n        return lastBlock\r\n\r\n\r\n    def save_unconfirmed_transactions(self):\r\n        # print(self.TRANSACTION_PATH)\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Blockchain Folder\")\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n        json_file = open(self.TRANSACTION_PATH + \"Transactions\"+ \".json\", \"w\")\r\n        json_file.write((json.dumps([ob.__dict__ for ob in self.unconfirmed_transactions])))\r\n        json_file.close()\r\n\r\n    def isUserAllowed(self,ip):\r\n        for block in self.chain:\r\n            block : Block\r\n            transaction = json.loads(block.transaction)\r\n            if transaction[\"type\"]==1:\r\n                if transaction[\"ip\"]==ip:\r\n                    return True\r\n        return False\r\n\r\n\r\n\r\nimport Networking
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/Blockchain.py b/Blockchain.py
---- a/Blockchain.py	(revision 7083ac7d2a09f8bc9830d05546c2e696de7a9374)
-+++ b/Blockchain.py	(date 1650530012494)
-@@ -193,7 +193,7 @@
- 
-     def mine(self):
-         #Load my public key.
--        keyLoc = self.BLOCKCHAIN_PATH+"..\\..\\..\\PRIVATEKEY.json"
-+        keyLoc = self.BLOCKCHAIN_PATH+"\\..\\..\\..\\PRIVATEKEY.json"
-         # print(f"key location = {keyLoc}")
-         f = open(keyLoc, "rb")
-         data = f.read()
-Index: main.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import json\r\nimport logging\r\nimport threading\r\nfrom pickle import dumps, loads\r\nfrom flask import Flask, render_template, request, redirect\r\n\r\nimport Blockchain\r\nimport Compress\r\nfrom Networking import receiver, sendRequest, JoinRequest,SearchBundleRequest,receiveBundle,GetBundleRequest\r\nfrom Groups import GroupManager, Invite,Group\r\nfrom Client import Client\r\nimport easygui\r\nfrom Bundles import BundleManager\r\nfrom Downloads import DownloadManager\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = False\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    progress = downloadManager.getDownloadProgress()\r\n    return render_template(\"index.html\", groups=groupManager.groups,client=client,progress=progress)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    group = groupManager.getGroupWithName(group)\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    if downloadManager.STATUS:\r\n        downloadManager.STATUS = False\r\n        #downloadManager Off\r\n        print(\"Download Manager Not Active\")\r\n        return \"0\"\r\n    else:\r\n        downloadManager.STATUS = True\r\n        #downloadManager On\r\n        print(\"Download Manager Active\")\r\n        return \"1\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n        # TODO KEY SPECIFIC BLOCKCHAIN\r\n        ip = data[\"ip\"] #This is string\r\n        transaction = Blockchain.InviteTransaction(ip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.add_new_transaction(transactionStr)\r\n        # print(\"Generate Invite for :\", group)\r\n        # print(group)\r\n        invite = group.generateInvite()\r\n        return Compress.compress(invite.toJSON())\r\n\r\n@app.route('/deleteBundle', methods=['POST'])\r\ndef deleteBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupId = data[\"groupId\"]\r\n        bundleId = data[\"bundleId\"]\r\n        if groupManager.deleteBundle(groupId,bundleId):\r\n            return \"1\"\r\n        else:\r\n            return \"0\"\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        inviteDecomp = Compress.decompress(invite)\r\n        inviteLoad = json.loads(inviteDecomp)\r\n        invite = Invite(inviteLoad[\"id\"],inviteLoad[\"name\"], inviteLoad[\"timestamp\"], inviteLoad[\"peers\"])\r\n        joinReq = JoinRequest(invite.name, invite.timestamp)\r\n        print(invite.peers)\r\n        for peer in invite.peers:\r\n            print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq))\r\n            if res is not False:\r\n                group = res.group\r\n                group = Group(group.name,group.admins,group.peers,group.timestamp,blockchainPath=groupManager.DIR_PATH_GROUPS+group.name+\"\\\\Blockchain\")\r\n                groupManager.addGroup(group)\r\n        #Make thread to update blockhain and get up to date.\r\n        #TODO\r\n        return \"1\"\r\n\r\n\r\n@app.route('/shareBundle', methods=['POST'])\r\ndef shareBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"bundleName\"]\r\n        desc = data[\"bundleDescription\"]\r\n        groupName = data[\"groupName\"]\r\n        print(name)\r\n        print(desc)\r\n        print(groupName)\r\n        path = easygui.diropenbox(msg=\"Select folder to share as bundle\", title=\"Share Bundle\")\r\n        bundle = bundleManager.createBundle(name,desc,path=path)\r\n        groupManager.addBundle(bundle,groupName)\r\n        return \"0\"\r\n\r\n@app.route('/selectDownloadLocation', methods=['POST'])\r\ndef selectDownloadLocation():\r\n    if request.method == 'POST':\r\n        path = easygui.diropenbox(msg=\"Select folder to download bundles\", title=\"Select Bundle Download Location\")\r\n        print(path)\r\n        #Update Download Path in Config\r\n        client.DIR_PATH_DOWNLOADS=path\r\n        client.saveConfig()\r\n        #Return path to browser and update it in modal\r\n        return path\r\n\r\n@app.route('/searchBundles', methods=['POST'])\r\ndef searchBundles():\r\n    # print(\"Search Bundles Route\")\r\n    if request.method == 'POST':\r\n        data = request.form\r\n\r\n        #Get Keywords from search\r\n        keywords = data[\"searchKeyWords\"].split()\r\n        # print(\"Search for :\",keywords)\r\n\r\n        #Get Group\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n\r\n        searchReq = SearchBundleRequest(group.id,keywords)\r\n        responses = []\r\n        # SEND TO ALL PEERS COLLECT RESPONSES AND PRESENT\r\n        for peer in group.peers:\r\n            res = sendRequest(peer[0], 6700, dumps(searchReq))\r\n            #if other peer is responded.\r\n            if res is not False:\r\n                # print(res)\r\n                responses.append([peer[0],res])\r\n            else:\r\n                print(\"No Response from\",peer[0])\r\n        #Merge all responses to single list\r\n        # for x in responses:\r\n        #     print(\"Response:\",x[0],x[1],x[1].responseBundles)\r\n        #WITH RESPONSES DO STUFF.\r\n        #Respond\r\n        return render_template(\"search.html\", groups=groupManager.groups, group=group , responses = responses)\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n    if groupManager.createGroup(name, [client.publicIP]):\r\n        #Make First Block In Blockchain Append Admin\r\n        #Type 0 First Created\r\n        group = groupManager.getGroupWithName(name)\r\n        group.blockchain.create_genesis_block(client)\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n@app.route('/getBundle', methods=['POST'])\r\ndef getBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        bundleId = data[\"bundleId\"]\r\n        groupId = data[\"groupId\"]\r\n        userIp = data[\"userIp\"]\r\n        #TODO dynamic port on receiver for bundle\r\n        portForBundleReceiver = 6701\r\n        bundleReceiver = threading.Thread(target=receiveBundle, args=[portForBundleReceiver,client,groupManager,groupId,downloadManager])\r\n        bundleReceiver.start()\r\n        getBundleReq = GetBundleRequest(bundleId,groupId,portForBundleReceiver)\r\n        res = sendRequest(userIp, 6700, dumps(getBundleReq))\r\n        # if other peer is responded.\r\n        if res is not False:\r\n            #Responded decide what to do\r\n            pass\r\n        else:\r\n            # print(\"No Response from\", userIp)\r\n            pass\r\n    return \"1\"\r\n\r\n\r\n@app.route('/quitGroup', methods=['POST'])\r\ndef quitGroup():\r\n    print('QUIT GROUP REQ')\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        if groupManager.quitGroup(group):\r\n            # True\r\n            return \"0\"\r\n        else:\r\n            # False\r\n            return \"1\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    groupManager = GroupManager()\r\n    bundleManager = BundleManager()\r\n    downloadManager = DownloadManager(groupManager,client)\r\n    #TODO Networking Thread To Receive From Internet\r\n    receiver = threading.Thread(target=receiver, args=[groupManager])\r\n    receiver.start()\r\n    app.run(host='', port=6969)\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/main.py b/main.py
---- a/main.py	(revision 7083ac7d2a09f8bc9830d05546c2e696de7a9374)
-+++ b/main.py	(date 1650530212954)
-@@ -199,7 +199,7 @@
- 
- @app.route('/quitGroup', methods=['POST'])
- def quitGroup():
--    print('QUIT GROUP REQ')
-+    # print('QUIT GROUP REQ')
-     if request.method == 'POST':
-         data = request.form
-         groupid = data["group"]
-Index: Groups.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>from time import time\r\nimport os\r\nfrom os import listdir\r\nfrom os.path import isfile, join\r\nimport json\r\nfrom typing import Type\r\nimport shutil\r\nimport hashlib\r\nfrom Blockchain import Blockchain\r\nimport Blockchain\r\nfrom Bundles import Bundle\r\nimport copy\r\n\r\n\r\nclass Invite:\r\n    def __init__(self, id, name, timestamp, peers):\r\n        self.id = id\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n        self.peers = peers\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\n\r\nclass Group:\r\n    def __init__(self, name, admin, peers, timestamp, blockchainPath,id=None):\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n        self.admins = admin\r\n        self.peers = peers\r\n\r\n        self.bundles = []\r\n        if id is None:\r\n            self.id = hashlib.sha256((name + str(timestamp)).encode('utf-8')).hexdigest()\r\n        else:\r\n            self.id = id\r\n\r\n        self.blockchain = Blockchain.Blockchain(blockchainPath,self.peers,self.id)\r\n\r\n    def generateInvite(self):\r\n        invite = Invite(self.id, self.name, self.timestamp, self.peers)\r\n        return invite\r\n\r\n\r\n    def removeBundle(self,bundle):\r\n        self.bundles.remove(bundle)\r\n        return True\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\n    def getBundleWithId(self, bundleid):\r\n        group: Bundle\r\n        for bundle in self.bundles:\r\n            # print(\"trying to match\",bundle.id)\r\n            if bundle.id == bundleid:\r\n                return bundle\r\n        # If Nothing Proked return in for loop return false for not having the bundle .\r\n        return False\r\n\r\nclass GroupManager:\r\n\r\n    def __init__(self):\r\n        self.groups = []\r\n        self.DIR_PATH_GROUPS = '%s\\\\TorrentApp\\\\Groups\\\\' % os.environ['APPDATA']\r\n        if not os.path.exists(self.DIR_PATH_GROUPS):\r\n            # Create a new directory because it does not exist\r\n            print(\"Gonna Create Group Folder\")\r\n            os.makedirs(self.DIR_PATH_GROUPS)\r\n        # Load Groups\r\n        self.loadGroups()\r\n        print(\"GroupManager Initialized\")\r\n\r\n    def deleteBundle(self,group,bundle):\r\n        group = self.getGroupWithId(group)\r\n        bundle = group.getBundleWithId(bundle)\r\n        group.removeBundle(bundle)\r\n        os.remove(self.DIR_PATH_GROUPS + group.name+\"\\\\Bundles\\\\\"+bundle.name+\".json\")\r\n        return True\r\n\r\n\r\n    def addGroup(self, group):\r\n        self.saveGroup(group)\r\n        self.groups.append(group)\r\n\r\n    def removeGroup(self, group):\r\n        self.groups.remove(group)\r\n        print(self.groups)\r\n\r\n    def getGroupWithName(self, name):\r\n        group: Group\r\n        for group in self.groups:\r\n            if group.name == name:\r\n                return group\r\n\r\n    def getGroupWithId(self, id):\r\n        group: Group\r\n        for group in self.groups:\r\n            if group.id == id:\r\n                return group\r\n\r\n    def addPeerGroup(self, name, peer):\r\n        group: Group\r\n        for group in self.groups:\r\n            if group.name == name:\r\n                if peer not in group.peers:\r\n                    group.peers.append(peer)\r\n                    self.saveGroup(group)\r\n                    return\r\n\r\n    def createGroup(self, name, admin):\r\n        timeNow = time()\r\n        newGroup = Group(name, [admin, ], [admin, ], timeNow,blockchainPath=self.DIR_PATH_GROUPS+name+\"\\\\Blockchain\")\r\n        self.saveGroup(newGroup)\r\n        self.groups.append(newGroup)\r\n        return True\r\n\r\n    def quitGroup(self, group):\r\n        group : Group\r\n        shutil.rmtree(self.DIR_PATH_GROUPS + group.name)\r\n        self.removeGroup(group)\r\n        return True\r\n\r\n    def saveGroup(self, group: Group):\r\n        # Create JSON file\r\n        json_file_name = group.name + \".json\"\r\n        if not os.path.exists(self.DIR_PATH_GROUPS + group.name):\r\n            # Create a new directory because it does not exist\r\n            print(\"Gonna Create Group Folder\")\r\n            os.makedirs(self.DIR_PATH_GROUPS + group.name)\r\n        json_file = open(self.DIR_PATH_GROUPS + group.name + '\\\\' + json_file_name, \"w\")\r\n        saveCopy = copy.copy(group)\r\n        del saveCopy.bundles\r\n        del saveCopy.blockchain\r\n        json_file.write(saveCopy.toJSON())\r\n        json_file.close()\r\n\r\n    def loadGroup(self, groupName):\r\n        try:\r\n            file = open(self.DIR_PATH_GROUPS + groupName + \"\\\\\" + groupName + \".json\")\r\n            json_load_group = json.load(file)\r\n            file.close()\r\n        except:\r\n            print(\"Error Opening Group file :\", groupName)\r\n\r\n        group = Group(json_load_group[\"name\"], json_load_group[\"admins\"],\r\n                      json_load_group[\"peers\"], json_load_group[\"timestamp\"],self.DIR_PATH_GROUPS + groupName + \"\\\\\" + \"Blockchain\\\\\", json_load_group[\"id\"])\r\n\r\n        # Load Bundles of Each group.\r\n        groupBundlePath = self.DIR_PATH_GROUPS + groupName + \"\\\\\" + \"Bundles\\\\\"\r\n        # Make the folder if it dosent exist .\r\n        if not os.path.exists(groupBundlePath):\r\n            os.makedirs(groupBundlePath)\r\n        else:\r\n            # if exists search all the files\r\n            bundles = [f for f in listdir(groupBundlePath) if isfile(join(groupBundlePath, f))]\r\n            for bundle in bundles:\r\n                pathForBundleFile = join(groupBundlePath, bundle)\r\n                with open(pathForBundleFile) as json_file:\r\n                    data = json.load(json_file)\r\n                    #    def __init__(self,name,desc,root,pieceSize=49152,files=[],path=None):\r\n                    bundleObj = Bundle(data[\"name\"], data[\"description\"], data[\"id\"], data[\"timestamp\"], data[\"root\"],\r\n                                       data[\"pieceSize\"], data[\"files\"])\r\n                    group.bundles.append(bundleObj)\r\n\r\n\r\n\r\n        self.groups.append(group)\r\n\r\n    def loadGroups(self):\r\n        groups = [group for group in listdir(self.DIR_PATH_GROUPS)]\r\n        for group in groups:\r\n            self.loadGroup(group)\r\n\r\n    def addBundle(self, bundle, group):\r\n        if not os.path.exists(self.DIR_PATH_GROUPS + group + \"\\\\\" + \"Bundles\"):\r\n            # Create a new directory because it does not exist\r\n            print(\"Creating Group Folder\")\r\n            os.makedirs(self.DIR_PATH_GROUPS + group + \"\\\\\" + \"Bundles\")\r\n        json_file_name = bundle.name + \".json\"\r\n        json_file = open(self.DIR_PATH_GROUPS + group + \"\\\\\" + \"Bundles\" + \"\\\\\" + json_file_name, \"w\")\r\n        json_file.write(json.dumps(bundle.toJSON()))\r\n        json_file.close()\r\n        self.getGroupWithName(group).bundles.append(bundle)\r\n        # print(\"Added Bundle\")\r\n        # print(self.DIR_PATH_GROUPS + group + \"\\\\\" + \"Bundles\")\r\n        # print(self.DIR_PATH_GROUPS + group + \"\\\\\" + \"Bundles\" + \"\\\\\" + json_file_name)\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/Groups.py b/Groups.py
---- a/Groups.py	(revision 7083ac7d2a09f8bc9830d05546c2e696de7a9374)
-+++ b/Groups.py	(date 1650530142770)
-@@ -93,12 +93,16 @@
-         for group in self.groups:
-             if group.name == name:
-                 return group
-+        #Group not found
-+        return False
- 
-     def getGroupWithId(self, id):
-         group: Group
-         for group in self.groups:
-             if group.id == id:
-                 return group
-+        #Group not found
-+        return False
- 
-     def addPeerGroup(self, name, peer):
-         group: Group
-Index: Networking.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import copy\r\nimport json\r\nimport pickle\r\nimport socket\r\nimport threading\r\nfrom socket import *\r\nfrom Bundles import Bundle\r\nimport Client\r\nfrom Groups import GroupManager, Group\r\nimport os\r\nimport hashlib\r\nimport Blockchain\r\n\r\n\r\nclass Request:\r\n    def __init__(self, type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\n\r\n# All Classes extended Request even Response Classes just for type and toJSON method.\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self, name, timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self, group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\n\r\nclass SearchBundleRequest(Request):\r\n    def __init__(self, groupId, keyword):\r\n        super().__init__(2)\r\n        self.groupID = groupId\r\n        self.keywords = keyword\r\n\r\n\r\nclass SearchBundleResponse(Request):\r\n    def __init__(self, responseBundles):\r\n        super().__init__(2)\r\n        self.responseBundles = responseBundles\r\n\r\n\r\nclass GetBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId, portForBundleReceiver):\r\n        super().__init__(3)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.portForBundleReceiver = portForBundleReceiver\r\n\r\n\r\nclass GetBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(3)\r\n        self.answer = answer\r\n\r\n\r\nclass CheckBundleAvailabilityRequest(Request):\r\n    def __init__(self, bundleId, groupId):\r\n        super().__init__(4)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n\r\n\r\nclass CheckBundleAvailabilityResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(4)\r\n        self.answer = answer\r\n\r\n\r\nclass DownloadBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId, file, port):\r\n        super().__init__(5)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.file = file\r\n        self.port = port\r\n\r\n\r\nclass DownloadBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(5)\r\n        self.answer = answer\r\n\r\nclass UpdateBlockchainRequest(Request):\r\n    def __init__(self, groupId):\r\n        super().__init__(6)\r\n        self.groupId = groupId\r\n\r\n\r\nclass UpdateBlockchainResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(6)\r\n        self.answer = answer\r\n\r\ndef requestHandler(data, addr, groupManager: GroupManager):\r\n    req = pickle.loads(data)\r\n    print(f\"Received From {addr[0]}:{addr[1]} {req.__class__.__name__}\")\r\n\r\n    # Response to JoinRequest\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name, req.timestamp)\r\n        group = groupManager.getGroupWithName(req.name)\r\n        if group.blockchain.isUserAllowed(addr[0]):\r\n            groupManager.addPeerGroup(req.name, [addr[0]])\r\n            groupCpy = copy.copy(group)\r\n            del groupCpy.bundles\r\n            joinResponse = JoinResponse(groupCpy)\r\n            return pickle.dumps(joinResponse)\r\n        else:\r\n            return False\r\n\r\n    # Response to search req\r\n    elif req.type == 2:\r\n        # Create The Request again for local use\r\n        req = SearchBundleRequest(req.groupID, req.keywords)\r\n        # Get All Bundles User has\r\n        bundlesOfGroup = groupManager.getGroupWithId(req.groupID).bundles\r\n        # Bundles to reply\r\n        responseBundles = []\r\n        # print(responseBundles)\r\n        for bundle in bundlesOfGroup:\r\n            # For each bundle make a single list (bundleKeywords) and search if any of the keywords other user send are in there then send back\r\n            name = bundle.name.split()\r\n            desc = bundle.description.split()\r\n            bundleKeywords = name + desc\r\n            # print(\"Bundle Keywords : \",bundleKeywords)\r\n            # print(\"Request Keywords : \",req.keywords)\r\n            if any(keyword in req.keywords for keyword in bundleKeywords):\r\n                # print(\"HIT\")\r\n                responseBundles.append({\"id\": bundle.id, \"name\": bundle.name, \"description\": bundle.description})\r\n        # Create Response and return it to be used as answer\r\n        # print(responseBundles)\r\n        searchResponse = SearchBundleResponse(responseBundles)\r\n        # print(\"Search Response :\",searchResponse)\r\n        return pickle.dumps(searchResponse)\r\n\r\n    elif req.type == 3:\r\n        req = GetBundleRequest(req.bundleId, req.groupId, req.portForBundleReceiver)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        bundle = group.getBundleWithId(req.bundleId)\r\n        bundleReceiver = threading.Thread(target=sendBundle,\r\n                                          args=[addr, req.portForBundleReceiver, groupManager, group, bundle])\r\n        bundleReceiver.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        # TODO 9/4 ????\r\n        return pickle.dumps(GetBundleResponse(1))\r\n\r\n    elif req.type == 4:\r\n        req = CheckBundleAvailabilityRequest(req.bundleId, req.groupId)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        bundle = group.getBundleWithId(req.bundleId)\r\n        if bundle is False:\r\n            # Not Found\r\n            return pickle.dumps(CheckBundleAvailabilityResponse(0))\r\n        else:\r\n            # Found\r\n            return pickle.dumps(CheckBundleAvailabilityResponse(1))\r\n\r\n    elif req.type == 5:\r\n        # print(\"Received Request To Send File\")\r\n        req = DownloadBundleRequest(req.bundleId, req.groupId, req.file, req.port)\r\n        uploadThread = threading.Thread(target=uploadBundle,\r\n                                        args=[addr, req.port, req.bundleId, req.groupId, req.file, groupManager])\r\n        uploadThread.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        # TODO 9/4 ????\r\n        return pickle.dumps(DownloadBundleResponse(1))\r\n\r\n    elif req.type == 6:\r\n        req = UpdateBlockchainRequest(req.groupId)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        if group.blockchain.isUserAllowed(addr[0]):\r\n            #User is ok\r\n            lastBlock = group.blockchain.getLastBlock()\r\n            lastBlock : Blockchain.Block\r\n            lastBlockIndex = lastBlock.index\r\n            return pickle.dumps(UpdateBlockchainResponse(lastBlockIndex))\r\n        else:\r\n            #User not invited not joined, therefore don't answer.\r\n            return False\r\n\r\ndef responseHandler(data):\r\n    res = pickle.loads(data)\r\n\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        return res\r\n\r\n    elif res.type == 2:\r\n        res = SearchBundleResponse(res.responseBundles)\r\n        return res\r\n\r\n    elif res.type == 3:\r\n        res = SearchBundleResponse(res.answer)\r\n        return res\r\n\r\n    elif res.type == 4:\r\n        res = CheckBundleAvailabilityResponse(res.answer)\r\n        return res\r\n\r\n    elif res.type == 5:\r\n        res = DownloadBundleResponse(res.answer)\r\n        return res\r\n\r\n    elif res.type == 6:\r\n        res = UpdateBlockchainResponse(res.answer)\r\n        return res\r\n\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        # RECEIVE AND RESPOND.\r\n        data, addr = sock.recvfrom(65537)\r\n        # data, addr = sock.recvfrom(65507)\r\n        # print(\"Received from :\", addr)\r\n        response = requestHandler(data, addr, groupManager)\r\n        #Request Handler if not want to answer returns False.\r\n        if response is not False:\r\n            sock.sendto(response, addr)\r\n\r\n\r\ndef sendRequest(address, port, request):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.settimeout(1)\r\n    try:\r\n        clientSocket.sendto(request, (address, port))\r\n        data, addr = clientSocket.recvfrom(65537)\r\n        # data, addr = clientSocket.recvfrom(65507)\r\n        res = responseHandler(data)\r\n        return res\r\n    # TODO except socket.timeout\r\n    except Exception as exception:\r\n        # print(\"Exception on SendRequest:\", exception)\r\n        return False\r\n\r\n\r\ndef receiveBundle(port, client, groupManager, groupId, downloadManager):\r\n    # print(\"RECEIVING BUNDLE THREAD\")\r\n    bundleBytes = b\"\"\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.bind((\"0.0.0.0\", port))\r\n        # print(\"Bundle Receiver Ready\")\r\n        s.listen()\r\n        conn, addr = s.accept()\r\n        with conn:\r\n            print(f\"Connection From {addr[0]}:{addr[1]} Accepted.\")\r\n            while True:\r\n                data = conn.recv(1024)\r\n                # print(data)\r\n                bundleBytes = bundleBytes + data\r\n                # TODO save Bytes to group and downloads also start downloading.\r\n                if not data:\r\n                    # print(\"Break\")\r\n                    break\r\n            # print(\"Break3\")\r\n    # print(\"Bundle Str\",bundleBytes.decode())\r\n    bundleObj = json.loads(bundleBytes.decode())\r\n    # Fix Bundle Root to be downloaded and location\r\n    client: Client.Client\r\n    bundleObj[\"root\"] = client.DIR_PATH_DOWNLOADS\r\n    bundle = Bundle(bundleObj[\"name\"], bundleObj[\"description\"], bundleObj[\"id\"], bundleObj[\"timestamp\"],\r\n                    bundleObj[\"root\"], bundleObj[\"pieceSize\"], bundleObj[\"files\"])\r\n    group = groupManager.getGroupWithId(groupId)\r\n    groupManager.addBundle(bundle, group.name)\r\n    downloadManager.downloadBundle(bundle, group)\r\n\r\n\r\ndef sendBundle(addr, port, groupManager, group, bundle):\r\n    # print(\"SENDING BUNDLE THREAD\")\r\n    group: Group\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.connect((addr[0], port))\r\n        print(f\"Connected To {addr[0]}:{addr[1]}.\")\r\n        # print(\"SENDING DATA\")\r\n        groupManager: GroupManager\r\n        json_file_name = bundle.name + \".json\"\r\n        bundleDir = groupManager.DIR_PATH_GROUPS + group.name + \"\\\\\" + \"Bundles\" + \"\\\\\" + json_file_name\r\n        print(bundleDir)\r\n        print(json_file_name)\r\n        with open(bundleDir) as f:\r\n            bundleContent = f.read()\r\n            bundleObj = json.loads(bundleContent)\r\n            bundleObj[\"root\"] = \"\"\r\n            bundleStr = json.dumps(bundleObj)\r\n\r\n        s.sendall(bundleStr.encode())\r\n\r\n\r\ndef is_port_in_use(port: int) -> bool:\r\n    import socket\r\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\r\n        return s.connect_ex(('localhost', port)) == 0\r\n\r\n\r\ndef downloadBundle(downloadManager , port, peer, file, bundle, usedPeers, freeFiles):\r\n    bundle: BundleToDownload\r\n    pieceList = []\r\n    # Find pieces missing\r\n    for x in bundle.files:\r\n        if x[\"path\"] == file[0]:\r\n            pieceList = x[\"pieces\"]\r\n            break\r\n    # pieceList = [[0, '5920572cf97d3711a77a9b7a3469a5fd03bb2a8a', 0]]\r\n    # print(\"DOWNLOADING BUNDLE THREAD\")\r\n    filePath = bundle.root +f\"\\\\{bundle.name}\"+ file[0]\r\n    dir = filePath.rsplit('\\\\', 1)[0]\r\n    # print(dir)\r\n    #Create Directory's that don't exist.\r\n    isExist = os.path.exists(dir)\r\n    if not isExist:\r\n        # Create a new directory because it does not exist\r\n        os.makedirs(dir)\r\n\r\n    if os.path.exists(filePath) is False:\r\n        print(\"Creating File\")\r\n        file = open(filePath, 'x')\r\n        file.close()\r\n\r\n\r\n    with open(filePath, 'rb+') as openfileobject:\r\n        with socket(AF_INET, SOCK_STREAM) as s:\r\n            s.bind((\"0.0.0.0\", port))\r\n            # print(\"Bundle Receiver Ready\")\r\n            s.listen()\r\n            conn, addr = s.accept()\r\n            with conn:\r\n                print(f\"Connection From {addr[0]}:{addr[1]} Accepted.\")\r\n                data = conn.recv(1024)\r\n                if data.decode() == \"OK\":\r\n                    # print(\"Received Ok\")\r\n                    for piece in pieceList:\r\n                        if piece[2] == 0:\r\n                            # print(f\"Sending Piece num {piece[0]} \")\r\n                            conn.sendall(str(piece[0]).encode())\r\n                            openfileobject.seek(piece[0]*bundle.pieceSize)\r\n                            data = conn.recv(100000)\r\n                            # print(f\"Received {data}\")\r\n                            if hashlib.sha1(data).hexdigest() == piece[1]:\r\n                                # print(\"HASH OK\")\r\n                                openfileobject.write(data)\r\n                                piece[2]=1\r\n                                # print(piece)\r\n                            else:\r\n                                pass\r\n                                # print(\"hashes dont match\")\r\n                    # delimmiter for data\r\n                    conn.sendall(\"\uD83E\uDD6D\uD83C\uDF53\uD83C\uDF47\uD83C\uDF49\uD83C\uDF50\uD83E\uDD67\uD83C\uDF4A\uD83C\uDF4D\uD83C\uDF4F\uD83E\uDD51\uD83C\uDF51\uD83C\uDF4C\uD83C\uDF4E\uD83C\uDF50\uD83C\uDF49\uD83C\uDF47\uD83C\uDF53\uD83E\uDD6D\uD83E\uDD5D\uD83C\uDF52\uD83C\uDF45\".encode())\r\n                    usedPeers.remove(peer)\r\n                    downloadManager.saveBundle(bundle)\r\n    # print(f\"Thread Exit {file}\")\r\n\r\n\r\n\r\ndef uploadBundle(addr, port, bundleId, groupId, file, groupManager):\r\n    # print(\"SENDING BUNDLE THREAD\")\r\n    group = groupManager.getGroupWithId(groupId)\r\n    bundle = group.getBundleWithId(bundleId)\r\n    with open(bundle.root + file, 'rb') as openfileobject:\r\n        try:\r\n            with socket(AF_INET, SOCK_STREAM) as s:\r\n                s.connect((addr[0], port))\r\n                # print(\"SENDING DATA\")\r\n                s.sendall(\"OK\".encode())\r\n                while True:\r\n                    piece = s.recv(1024)\r\n                    #delimmiter for data\r\n                    if piece == \"\uD83E\uDD6D\uD83C\uDF53\uD83C\uDF47\uD83C\uDF49\uD83C\uDF50\uD83E\uDD67\uD83C\uDF4A\uD83C\uDF4D\uD83C\uDF4F\uD83E\uDD51\uD83C\uDF51\uD83C\uDF4C\uD83C\uDF4E\uD83C\uDF50\uD83C\uDF49\uD83C\uDF47\uD83C\uDF53\uD83E\uDD6D\uD83E\uDD5D\uD83C\uDF52\uD83C\uDF45\".encode():\r\n                        break\r\n                    else:\r\n                        if piece == b'':\r\n                            # print(\"Empty\")\r\n                            pass\r\n                        else:\r\n                            piece = int(piece.decode())\r\n                            # print(f\"Trying to send {piece}\")\r\n                            openfileobject.seek(piece * bundle.pieceSize)\r\n                            readData = openfileobject.read(bundle.pieceSize)\r\n                            s.sendall(readData)\r\n        except ConnectionResetError as exception:\r\n            print(\"Downloader DC\")\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/Networking.py b/Networking.py
---- a/Networking.py	(revision 7083ac7d2a09f8bc9830d05546c2e696de7a9374)
-+++ b/Networking.py	(date 1650530163744)
-@@ -177,15 +177,16 @@
-     elif req.type == 6:
-         req = UpdateBlockchainRequest(req.groupId)
-         group = groupManager.getGroupWithId(req.groupId)
--        if group.blockchain.isUserAllowed(addr[0]):
--            #User is ok
--            lastBlock = group.blockchain.getLastBlock()
--            lastBlock : Blockchain.Block
--            lastBlockIndex = lastBlock.index
--            return pickle.dumps(UpdateBlockchainResponse(lastBlockIndex))
--        else:
--            #User not invited not joined, therefore don't answer.
--            return False
-+        if group is not False:
-+            if group.blockchain.isUserAllowed(addr[0]):
-+                #User is ok
-+                lastBlock = group.blockchain.getLastBlock()
-+                lastBlock : Blockchain.Block
-+                lastBlockIndex = lastBlock.index
-+                return pickle.dumps(UpdateBlockchainResponse(lastBlockIndex))
-+            else:
-+                #User not invited not joined, therefore don't answer.
-+                return False
- 
- def responseHandler(data):
-     res = pickle.loads(data)
Index: .idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_53_AM__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_53_AM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_53_AM__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_53_AM__Changes_.xml	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_21-Apr-22_11_53_AM_[Changes]" date="1650531217094" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_53_AM_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 21-Apr-22 11:53 AM [Changes]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_26_PM_[Changes]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_26_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_26_PM_[Changes]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_26_PM_[Changes]/shelved.patch	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,32 +0,0 @@
-Index: Blockchain.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import math\r\nimport os\r\nimport json\r\nfrom os import listdir\r\nimport rsa\r\nimport time\r\nfrom time import sleep\r\nimport threading\r\nfrom hashlib import sha256\r\nimport copy\r\nfrom pickle import dumps, loads\r\n\r\n\r\nclass Block:\r\n    def __init__(self, index, transaction, timestamp, previous_hash, signatures):\r\n        self.index = index\r\n\r\n        self.transaction = transaction\r\n\r\n        self.timestamp = timestamp\r\n\r\n        self.previous_hash = previous_hash\r\n\r\n        self.signatures = signatures\r\n\r\n    def computeHash(self):\r\n        mycopy = copy.copy(self)\r\n        del mycopy.signatures\r\n        # print(mycopy.__dict__)\r\n        if hasattr(mycopy, 'hash'):\r\n            del mycopy.hash\r\n        block_string = json.dumps(mycopy.__dict__, sort_keys=True)\r\n        return sha256(block_string.encode()).hexdigest()\r\n\r\n\r\nclass UnconfirmedTransaction:\r\n    def __init__(self, transaction, signatures=[]):\r\n        self.transaction = transaction\r\n        self.signatures = signatures\r\n\r\n\r\nclass GenesisTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 0\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass InviteTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 1\r\n        self.ip = ip\r\n\r\n\r\nclass JoinTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 2\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass BanTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 3\r\n        self.ip = ip\r\n\r\n\r\nclass UnbanTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 4\r\n        self.ip = ip\r\n\r\n\r\nclass AddAdminTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 5\r\n        self.ip = ip\r\n\r\n\r\nclass RemoveAdminTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 6\r\n        self.ip = ip\r\n\r\n\r\nclass Blockchain:\r\n    def __init__(self, path, groupPeers, groupAdmins, groupId, client):\r\n        self.BLOCKCHAIN_PATH = path\r\n        self.TRANSACTION_PATH = self.BLOCKCHAIN_PATH + \"\\\\Transactions\\\\\"\r\n        self.unconfirmed_transactions = []\r\n        self.chain = []\r\n        self.peers = groupPeers\r\n        self.groupId = groupId\r\n        self.groupAdmins = groupAdmins\r\n        self.client = client\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n            # Load Unconfirmed Transactions\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n\r\n        self.loadTransactions()\r\n\r\n        # print(self.unconfirmed_transactions)\r\n        # Load Blocks here\r\n        blockFiles = [f for f in listdir(self.BLOCKCHAIN_PATH) if os.path.isfile(os.path.join(self.BLOCKCHAIN_PATH, f))]\r\n        for blockFile in blockFiles:\r\n            self.loadBlock(blockFile)\r\n\r\n        # Start Casual Operations.\r\n        # Thread This.\r\n        miner = threading.Thread(target=self.mine, args=[client])\r\n        miner.start()\r\n        # print(self.unconfirmed_transactions)\r\n        # for block in self.chain:\r\n        #     print(block)\r\n\r\n    def getDifficulty(self):\r\n        # Diffuculty of blockchain will be dependent on the users participating\r\n        # TODO refactor this for join ban unban\r\n        if len(self.peers) == 0:\r\n            return 1\r\n        else:\r\n            peers, bans, admins, owner = self.parseBlockchain()\r\n            return math.floor(math.log2(len(peers)))\r\n\r\n    def createGenesisBlock(self, client):\r\n        transaction = GenesisTransaction(client.publicIP, client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        # this is string json format\r\n        # print(transactionStr)\r\n        # print(transactionStr.__class__)\r\n        # Genereate signature for Transaction\r\n        signature = rsa.sign(transactionStr.encode(), client.privateKey, 'SHA-1')\r\n        genesis_block = Block(0, transactionStr, str(time.time()), \"0\", [str(signature)])\r\n        genesis_block.hash = genesis_block.computeHash()\r\n        self.saveBlock(genesis_block)\r\n        self.chain.append(genesis_block)\r\n\r\n    def saveBlock(self, block):\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Creating Blockchain Folder\")\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n        blockFile = open(self.BLOCKCHAIN_PATH + \"\\\\Block\" + str(block.index) + \".json\", \"w\")\r\n        # print(block.__dict__)\r\n        blockFile.write(json.dumps(block.__dict__))\r\n        blockFile.close()\r\n\r\n    def loadTransactions(self):\r\n        filePath = self.TRANSACTION_PATH + \"Transactions.json\"\r\n        if os.path.exists(filePath):\r\n            try:\r\n                file = open(filePath)\r\n                # print(file)\r\n                json_load_group = json.load(file)\r\n                file.close()\r\n            except Exception as e:\r\n                print(\"Error Opening Transaction file :\", e)\r\n            for x in json_load_group:\r\n                transaction = UnconfirmedTransaction(x[\"transaction\"], x[\"signatures\"])\r\n                # print(transaction)\r\n                self.unconfirmed_transactions.append(transaction)\r\n            # print(self.unconfirmed_transactions)\r\n\r\n    def loadBlock(self, blockFiles):\r\n        # print(blockFiles)\r\n        filePath = self.BLOCKCHAIN_PATH + \"\\\\\" + blockFiles\r\n        file = open(filePath)\r\n        # print(file)\r\n        block = json.load(file)\r\n        file.close()\r\n        # # print(block)\r\n        # transaction = json.loads(block[\"transaction\"])\r\n        # # print(transaction)\r\n        # # print(transaction.__class__)\r\n        # # Make transaction here\r\n        # if transaction[\"type\"] == 0:\r\n        #     # print(\"Genesis block\")\r\n        #     transactionObj = GenesisTransaction(transaction[\"ip\"], transaction[\"publicKey\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        blockObj = Block(block[\"index\"], block[\"transaction\"], block[\"timestamp\"], block[\"previous_hash\"],\r\n                         block[\"signatures\"])\r\n        blockObj.hash = block[\"hash\"]\r\n        # TODO Add all transactions here\r\n\r\n        # elif transaction[\"type\"] == 1:\r\n        #     # print(\"Genesis block\")\r\n        #     # print(transaction)\r\n        #     transactionObj = InviteTransaction(transaction[\"ip\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        #     blockObj = Block(block[\"index\"], transactionStr, block[\"timestamp\"], block[\"previous_hash\"],\r\n        #                      block[\"signatures\"])\r\n        #     blockObj.hash = block[\"hash\"]\r\n\r\n        self.chain.append(blockObj)\r\n        # print(blockObj.__dict__)\r\n\r\n    def addNewTransaction(self, transaction: str):\r\n        newUnconfirmedTransaction = UnconfirmedTransaction(transaction)\r\n        self.unconfirmed_transactions.append(newUnconfirmedTransaction)\r\n        self.saveUnconfirmedTransactions()\r\n\r\n    def updateBlockchain(self, client):\r\n        for peer in self.peers:\r\n            # Dont send to self\r\n            if peer[0] != client.publicIP:\r\n                # For each peer ask their max index of blockchain\r\n                updateBlockchainReq = Networking.UpdateBlockchainRequest(self.groupId)\r\n                res = Networking.sendRequest(peer[0], 6700, dumps(updateBlockchainReq))\r\n                if res is not False:\r\n                    # if the response is bigger than me ask him for his block until we are at the same.\r\n                    if res.answer > self.getLastBlockIndex():\r\n                        print(self.getLastBlockIndex().__class__, res.answer.__class__)\r\n                        while self.getLastBlockIndex() < res.answer:\r\n                            # Get block\r\n                            getBlockReq = Networking.GetBlockRequest(self.groupId, self.getLastBlockIndex() + 1)\r\n                            blockRes = Networking.sendRequest(peer[0], 6700, dumps(getBlockReq))\r\n                            if blockRes is not False:\r\n                                print(f\"Update BC Response:{blockRes}\")\r\n                                # print(blockRes.answer)\r\n                                block = blockRes.answer\r\n                                block: Block\r\n                                print(block.index, block.transaction, block.signatures, block.timestamp,\r\n                                      block.previous_hash, block.hash)\r\n                                newBlock = Block(block.index, block.transaction, block.timestamp, block.previous_hash,\r\n                                                 block.signatures)\r\n                                newBlock.hash = block.hash\r\n                                if self.validateNewBlock(newBlock):\r\n                                    self.saveBlock(newBlock)\r\n                                    self.chain.append(newBlock)\r\n                            else:\r\n                                break\r\n                    else:\r\n                        # print(id(self.peers))\r\n                        peers, bans, admins, owner = self.parseBlockchain()\r\n                        # self.peers = peers\r\n                        # self.groupAdmins = admins\r\n                        # print(id(self.peers))\r\n                        # print(\"Blockchain Updated And Parsed\")\r\n                        # print(\"Up-to-date.\")\r\n                        pass\r\n\r\n        #Update Group Peers And Admins\r\n        peers, bans, admins, owner = self.parseBlockchain()\r\n        for ip in admins:\r\n            inside = False\r\n            for admin in self.groupAdmins:\r\n                if admin[0]==ip:\r\n                    inside = True\r\n            if not inside:\r\n                self.groupAdmins.append([ip])\r\n\r\n\r\n        for ip in peers:\r\n            inside = False\r\n            for peer in self.peers:\r\n                if peer[0]==ip:\r\n                    inside = True\r\n            if not inside:\r\n                self.peers.append([ip])\r\n\r\n\r\n    def getBlockWithIndex(self, index):\r\n        for block in self.chain:\r\n            block: Block\r\n            if block.index == index:\r\n                return block\r\n        return False\r\n\r\n    def validateNewBlock(self, newBlock):\r\n        \"\"\"This function is for new blocks that come from peers returns true if blocks checks out.\"\"\"\r\n        newBlock: Block\r\n\r\n        # If hash ok.\r\n        if newBlock.computeHash() == newBlock.hash:\r\n            # Validation for genesis block\r\n            if newBlock.index == 0:\r\n                if self.getLastBlockIndex() == -1:\r\n                    # No other blocks accept it.\r\n                    return True\r\n                else:\r\n                    return False\r\n            else:\r\n                # Check if new block is made with the same previous block.\r\n                # TODO if not resolve ?\r\n                if newBlock.previous_hash == self.getLastBlock().computeHash():\r\n                    # TODO check if signatures okay.\r\n                    # TODO check timestamp.\r\n                    # TODO check difficulty based on blockchain etc.\r\n                    return True\r\n\r\n    def mine(self, client):\r\n        while True:\r\n            # Update Blockchain.\r\n            self.updateBlockchain(client)\r\n            if not self.unconfirmed_transactions:\r\n                # If No Transaction sleep and check again soon.\r\n                sleep(30)\r\n            else:\r\n                diff = self.getDifficulty()\r\n                print(f\"Blockchain Difficulty :{diff}\")\r\n                print(f\"Unconfirmed Transactions:{len(self.unconfirmed_transactions)}\")\r\n                for transaction in self.unconfirmed_transactions:\r\n                    transaction: UnconfirmedTransaction\r\n                    # For Each Transaction if signatures < difficulty collect transactions\r\n                    if diff > len(transaction.signatures):\r\n                        if not len(transaction.signatures):\r\n                            # No Signatures add my signature\r\n                            signature = rsa.sign(transaction.transaction.encode(), client.privateKey, 'SHA-1')\r\n                            transaction.signatures.append(str(signature))\r\n                            self.saveUnconfirmedTransactions()\r\n                        else:\r\n                            # Get Signatures from other persons.\r\n                            #TODO IMPORTANT.\r\n                            pass\r\n                    else:\r\n                        # We have the signatures number procede to make block and share.\r\n                        print(f\"Signature {transaction} ready to be made block.\")\r\n                        # Bytes\r\n                        lastBlock = self.getLastBlock()\r\n                        print(lastBlock)\r\n                        lastBlock: Block\r\n                        print(f\"Last Block Index :{lastBlock.index}\")\r\n                        newBlock = Block(lastBlock.index + 1, transaction.transaction, str(time.time()),\r\n                                         lastBlock.computeHash(), transaction.signatures)\r\n                        newBlock.hash = newBlock.computeHash()\r\n                        self.unconfirmed_transactions.remove(transaction)\r\n                        self.saveUnconfirmedTransactions()\r\n                        self.saveBlock(newBlock)\r\n                        self.chain.append(newBlock)\r\n                sleep(30)\r\n\r\n    def getLastBlock(self) -> Block:\r\n        lastBlockIndex = self.chain[0].index\r\n        # Find last Block and return it\r\n        lastBlock = self.chain[0]\r\n        for block in self.chain:\r\n            # print(block.index)\r\n            if block.index > lastBlockIndex:\r\n                lastBlock = block\r\n                lastBlockIndex = block.index\r\n        return lastBlock\r\n\r\n    def getLastBlockIndex(self):\r\n        if len(self.chain) == 0:\r\n            return -1\r\n        else:\r\n            lastBlockIndex = self.chain[0].index\r\n            # Find last Block and return it\r\n            lastBlock = self.chain[0]\r\n            for block in self.chain:\r\n                # print(block.index)\r\n                if block.index > lastBlockIndex:\r\n                    lastBlock = block\r\n                    lastBlockIndex = block.index\r\n            return lastBlock.index\r\n\r\n    def saveUnconfirmedTransactions(self):\r\n        # print(self.TRANSACTION_PATH)\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Blockchain Folder\")\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n        json_file = open(self.TRANSACTION_PATH + \"Transactions\" + \".json\", \"w\")\r\n        json_file.write((json.dumps([ob.__dict__ for ob in self.unconfirmed_transactions])))\r\n        json_file.close()\r\n\r\n    def isUserAllowed(self, ip):\r\n        for block in self.chain:\r\n            block: Block\r\n            transaction = json.loads(block.transaction)\r\n            # From Create Genesis Block\r\n            if transaction[\"type\"] == 0:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n            # From Invite\r\n            if transaction[\"type\"] == 1:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n        # Didndt find user\r\n        return False\r\n\r\n    def getOwner(self):\r\n        for block in self.chain:\r\n            transaction = json.loads(block.transaction)\r\n            if transaction[\"type\"] == 0:\r\n                return transaction[\"ip\"]\r\n\r\n    def parseBlockchain(self):\r\n        \"\"\"\r\n        Parses Blockchain and returns 5 list of user types.\r\n        Peers that are in the blockchain and allowed.\r\n        Banned peers, Invites ,Admins and, Owner . All are lists.\r\n        \"\"\"\r\n        peers = []\r\n        bans = []\r\n        admins = []\r\n        invites = []\r\n        owner = []\r\n\r\n        for block in self.chain:\r\n            transaction = json.loads(block.transaction)\r\n            #GenesisTransactio\r\n            if transaction[\"type\"] == 0:\r\n                owner.append(transaction[\"ip\"])\r\n                admins.append(transaction[\"ip\"])\r\n                peers.append(transaction[\"ip\"])\r\n\r\n            #InviteTransaction\r\n            elif transaction[\"type\"] == 1:\r\n                invites.append(transaction[\"ip\"])\r\n\r\n            #JoinTransaction\r\n            elif transaction[\"type\"] == 2:\r\n                peers.append(transaction[\"ip\"])\r\n                invites.remove(transaction[\"ip\"])\r\n\r\n            #BanTransaction\r\n            elif transaction[\"type\"] == 3:\r\n                peers.remove(transaction[\"ip\"])\r\n                bans.append(transaction[\"ip\"])\r\n\r\n            # UnbanTransaction\r\n            elif transaction[\"type\"] == 4:\r\n                bans.remove(transaction[\"ip\"])\r\n\r\n                # AddAdminTransaction\r\n            elif transaction[\"type\"] == 5:\r\n                admins.append(transaction[\"ip\"])\r\n\r\n            # RemoveAdminTransaction\r\n            elif transaction[\"type\"] == 6:\r\n                admins.remove(transaction[\"ip\"])\r\n\r\n        # print(f\"Peers:{peers},Bans:{bans},Admins:{admins},Owners:{owner}\")\r\n        return peers, bans, admins, owner\r\n\r\n\r\nimport Networking\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/Blockchain.py b/Blockchain.py
---- a/Blockchain.py	(revision d5d09b0699efe693ad225bc36ba9b6f59bdb84ae)
-+++ b/Blockchain.py	(date 1650890195294)
-@@ -405,8 +405,12 @@
- 
-         for block in self.chain:
-             transaction = json.loads(block.transaction)
-+            print(peers,invites)
-+            print(transaction)
-+
-             #GenesisTransactio
-             if transaction["type"] == 0:
-+
-                 owner.append(transaction["ip"])
-                 admins.append(transaction["ip"])
-                 peers.append(transaction["ip"])
-@@ -418,7 +422,7 @@
-             #JoinTransaction
-             elif transaction["type"] == 2:
-                 peers.append(transaction["ip"])
--                invites.remove(transaction["ip"])
-+                                invites.remove(transaction["ip"])
- 
-             #BanTransaction
-             elif transaction["type"] == 3:
Index: .idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_26_PM__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_26_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_26_PM__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_26_PM__Changes_.xml	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_25-Apr-22_4_26_PM_[Changes]" date="1650893201731" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_26_PM_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 25-Apr-22 4:26 PM [Changes]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_41_AM_[Changes]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_41_AM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_41_AM_[Changes]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_41_AM_[Changes]/shelved.patch	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,33 +0,0 @@
-Index: Blockchain.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import os\r\nimport json\r\nfrom os import listdir\r\nimport rsa\r\nimport time\r\nfrom time import sleep\r\nimport threading\r\nfrom hashlib import sha256\r\nimport copy\r\nfrom pickle import dumps, loads\r\n\r\n\r\nclass Block:\r\n    def __init__(self, index, transaction, timestamp, previous_hash, signatures):\r\n        self.index = index\r\n\r\n        self.transaction = transaction\r\n\r\n        self.timestamp = timestamp\r\n\r\n        self.previous_hash = previous_hash\r\n\r\n        self.signatures = signatures\r\n\r\n    def computeHash(self):\r\n        mycopy = copy.copy(self)\r\n        del mycopy.signatures\r\n        # print(mycopy.__dict__)\r\n        if hasattr(mycopy, 'hash'):\r\n            del mycopy.hash\r\n        block_string = json.dumps(mycopy.__dict__, sort_keys=True)\r\n        return sha256(block_string.encode()).hexdigest()\r\n\r\n\r\nclass UnconfirmedTransaction:\r\n    def __init__(self, transaction, signatures=[]):\r\n        self.transaction = transaction\r\n        self.signatures = signatures\r\n\r\n\r\nclass GenesisTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 0\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass InviteTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 1\r\n        self.ip = ip\r\n\r\nclass JoinTransaction:\r\n    def __init__(self,ip,publicKey):\r\n        # Type of Transaction\r\n        self.type = 2\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass BanTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 3\r\n        self.ip = ip\r\n\r\n\r\nclass UnbanTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 4\r\n        self.ip = ip\r\n\r\n\r\nclass AddAdminTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 5\r\n        self.ip = ip\r\n\r\n\r\nclass RemoveAdminTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 6\r\n        self.ip = ip\r\n\r\n\r\nclass Blockchain:\r\n    def __init__(self, path, groupPeers, groupId, client):\r\n        self.BLOCKCHAIN_PATH = path\r\n        self.TRANSACTION_PATH = self.BLOCKCHAIN_PATH + \"\\\\Transactions\\\\\"\r\n        self.unconfirmed_transactions = []\r\n        self.chain = []\r\n        self.peers = groupPeers\r\n        self.groupId = groupId\r\n        self.client = client\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n            # Load Unconfirmed Transactions\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n\r\n        self.loadTransactions()\r\n\r\n        # print(self.unconfirmed_transactions)\r\n        # Load Blocks here\r\n        blockFiles = [f for f in listdir(self.BLOCKCHAIN_PATH) if os.path.isfile(os.path.join(self.BLOCKCHAIN_PATH, f))]\r\n        for blockFile in blockFiles:\r\n            self.loadBlock(blockFile)\r\n\r\n        # Start Casual Operations.\r\n        # Thread This.\r\n        miner = threading.Thread(target=self.mine, args=[client])\r\n        miner.start()\r\n        # print(self.unconfirmed_transactions)\r\n        # for block in self.chain:\r\n        #     print(block)\r\n\r\n    def getDifficulty(self):\r\n        # Diffuculty of blockchain will be dependent on the users participating\r\n        # TODO refactor this for join ban unban\r\n        if len(self.peers) == 0:\r\n            return 1\r\n        else:\r\n            return len(self.peers)\r\n\r\n    def createGenesisBlock(self, client):\r\n        transaction = GenesisTransaction(client.publicIP, client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        # this is string json format\r\n        # print(transactionStr)\r\n        # print(transactionStr.__class__)\r\n        # Genereate signature for Transaction\r\n        signature = rsa.sign(transactionStr.encode(), client.privateKey, 'SHA-1')\r\n        genesis_block = Block(0, transactionStr, str(time.time()), \"0\", [str(signature)])\r\n        genesis_block.hash = genesis_block.computeHash()\r\n        self.saveBlock(genesis_block)\r\n        self.chain.append(genesis_block)\r\n\r\n    def saveBlock(self, block):\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Creating Blockchain Folder\")\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n        blockFile = open(self.BLOCKCHAIN_PATH + \"\\\\Block\" + str(block.index) + \".json\", \"w\")\r\n        # print(block.__dict__)\r\n        blockFile.write(json.dumps(block.__dict__))\r\n        blockFile.close()\r\n\r\n    def loadTransactions(self):\r\n        filePath = self.TRANSACTION_PATH + \"Transactions.json\"\r\n        if os.path.exists(filePath):\r\n            try:\r\n                file = open(filePath)\r\n                # print(file)\r\n                json_load_group = json.load(file)\r\n                file.close()\r\n            except Exception as e:\r\n                print(\"Error Opening Transaction file :\", e)\r\n            for x in json_load_group:\r\n                transaction = UnconfirmedTransaction(x[\"transaction\"], x[\"signatures\"])\r\n                # print(transaction)\r\n                self.unconfirmed_transactions.append(transaction)\r\n            # print(self.unconfirmed_transactions)\r\n\r\n    def loadBlock(self, blockFiles):\r\n        # print(blockFiles)\r\n        filePath = self.BLOCKCHAIN_PATH + \"\\\\\" + blockFiles\r\n        file = open(filePath)\r\n        # print(file)\r\n        block = json.load(file)\r\n        file.close()\r\n        # # print(block)\r\n        # transaction = json.loads(block[\"transaction\"])\r\n        # # print(transaction)\r\n        # # print(transaction.__class__)\r\n        # # Make transaction here\r\n        # if transaction[\"type\"] == 0:\r\n        #     # print(\"Genesis block\")\r\n        #     transactionObj = GenesisTransaction(transaction[\"ip\"], transaction[\"publicKey\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        blockObj = Block(block[\"index\"], block[\"transaction\"], block[\"timestamp\"], block[\"previous_hash\"],\r\n                         block[\"signatures\"])\r\n        blockObj.hash = block[\"hash\"]\r\n        # TODO Add all transactions here\r\n\r\n        # elif transaction[\"type\"] == 1:\r\n        #     # print(\"Genesis block\")\r\n        #     # print(transaction)\r\n        #     transactionObj = InviteTransaction(transaction[\"ip\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        #     blockObj = Block(block[\"index\"], transactionStr, block[\"timestamp\"], block[\"previous_hash\"],\r\n        #                      block[\"signatures\"])\r\n        #     blockObj.hash = block[\"hash\"]\r\n\r\n        self.chain.append(blockObj)\r\n        # print(blockObj.__dict__)\r\n\r\n    def addNewTransaction(self, transaction: str):\r\n        newUnconfirmedTransaction = UnconfirmedTransaction(transaction)\r\n        self.unconfirmed_transactions.append(newUnconfirmedTransaction)\r\n        self.saveUnconfirmedTransactions()\r\n\r\n    def updateBlockchain(self, client):\r\n        for peer in self.peers:\r\n            # Dont send to self\r\n            if peer[0] != client.publicIP:\r\n                # For each peer ask their max index of blockchain\r\n                updateBlockchainReq = Networking.UpdateBlockchainRequest(self.groupId)\r\n                res = Networking.sendRequest(peer[0], 6700, dumps(updateBlockchainReq))\r\n                if res is not False:\r\n                    # if the response is bigger than me ask him for his block until we are at the same.\r\n                    if res.answer > self.getLastBlockIndex():\r\n                        print(self.getLastBlockIndex().__class__, res.answer.__class__)\r\n                        while self.getLastBlockIndex() < res.answer:\r\n                            # Get block\r\n                            getBlockReq = Networking.GetBlockRequest(self.groupId, self.getLastBlockIndex() + 1)\r\n                            blockRes = Networking.sendRequest(peer[0], 6700, dumps(getBlockReq))\r\n                            if blockRes is not False:\r\n                                print(f\"Update BC Response:{blockRes}\")\r\n                                # print(blockRes.answer)\r\n                                block = blockRes.answer\r\n                                block: Block\r\n                                print(block.index, block.transaction, block.signatures, block.timestamp,\r\n                                      block.previous_hash, block.hash)\r\n                                newBlock = Block(block.index, block.transaction, block.timestamp, block.previous_hash,\r\n                                                 block.signatures)\r\n                                newBlock.hash = block.hash\r\n                                if self.validateNewBlock(newBlock):\r\n                                    self.saveBlock(newBlock)\r\n                                    self.chain.append(newBlock)\r\n                            else:\r\n                                break\r\n                    else:\r\n                        # print(\"Up-to-date.\")\r\n                        pass\r\n\r\n    def getBlockWithIndex(self, index):\r\n        for block in self.chain:\r\n            block: Block\r\n            if block.index == index:\r\n                return block\r\n        return False\r\n\r\n    def validateNewBlock(self, newBlock):\r\n        \"\"\"This function is for new blocks that come from peers returns true if blocks checks out.\"\"\"\r\n        newBlock: Block\r\n\r\n        # If hash ok.\r\n        if newBlock.computeHash() == newBlock.hash:\r\n            # Validation for genesis block\r\n            if newBlock.index == 0:\r\n                if self.getLastBlockIndex() == -1:\r\n                    # No other blocks accept it.\r\n                    return True\r\n                else:\r\n                    return False\r\n            else:\r\n                # Check if new block is made with the same previous block.\r\n                # TODO if not resolve ?\r\n                if newBlock.previous_hash == self.getLastBlock().computeHash():\r\n                    # TODO check if signatures okay.\r\n                    # TODO check timestamp.\r\n                    # TODO check difficulty based on blockchain etc.\r\n                    return True\r\n\r\n    def mine(self, client):\r\n        # Load my public key.\r\n        # keyLoc = self.BLOCKCHAIN_PATH + \"\\\\..\\\\..\\\\..\\\\PRIVATEKEY.json\"\r\n        # # print(f\"key location = {keyLoc}\")\r\n        # f = open(keyLoc, \"rb\")\r\n        # data = f.read()\r\n        # privateKey = rsa.PrivateKey.load_pkcs1(data)\r\n        # # print(publicKey)\r\n        # f.close()\r\n        while True:\r\n            # Update Blockchain.\r\n            self.updateBlockchain(client)\r\n            if not self.unconfirmed_transactions:\r\n                # If No Transaction sleep and check again soon.\r\n                sleep(30)\r\n            else:\r\n                diff = self.getDifficulty()\r\n                print(f\"Blockchain Difficulty :{diff}\")\r\n                print(f\"Unconfirmed Transactions:{len(self.unconfirmed_transactions)}\")\r\n                for transaction in self.unconfirmed_transactions:\r\n                    transaction: UnconfirmedTransaction\r\n                    # For Each Transaction if signatures < difficulty collect transactions\r\n                    if diff > len(transaction.signatures):\r\n                        if not len(transaction.signatures):\r\n                            # No Signatures add my signature\r\n                            signature = rsa.sign(transaction.transaction.encode(), client.privateKey, 'SHA-1')\r\n                            transaction.signatures.append(str(signature))\r\n                            self.saveUnconfirmedTransactions()\r\n                        else:\r\n                            # Get Signatures from other persons.\r\n                            pass\r\n                    else:\r\n                        # We have the signatures number procede to make block and share.\r\n                        print(f\"Signature {transaction} ready to be made block.\")\r\n                        # Bytes\r\n                        lastBlock = self.getLastBlock()\r\n                        print(lastBlock)\r\n                        lastBlock: Block\r\n                        print(f\"Last Block Index :{lastBlock.index}\")\r\n                        newBlock = Block(lastBlock.index + 1, transaction.transaction, str(time.time()),\r\n                                         lastBlock.computeHash(), transaction.signatures)\r\n                        newBlock.hash = newBlock.computeHash()\r\n                        self.unconfirmed_transactions.remove(transaction)\r\n                        self.saveUnconfirmedTransactions()\r\n                        self.saveBlock(newBlock)\r\n                        self.chain.append(newBlock)\r\n                sleep(30)\r\n\r\n    def getLastBlock(self) -> Block:\r\n        lastBlockIndex = self.chain[0].index\r\n        # Find last Block and return it\r\n        lastBlock = self.chain[0]\r\n        for block in self.chain:\r\n            # print(block.index)\r\n            if block.index > lastBlockIndex:\r\n                lastBlock = block\r\n                lastBlockIndex = block.index\r\n        return lastBlock\r\n\r\n    def getLastBlockIndex(self):\r\n        if len(self.chain) == 0:\r\n            return -1\r\n        else:\r\n            lastBlockIndex = self.chain[0].index\r\n            # Find last Block and return it\r\n            lastBlock = self.chain[0]\r\n            for block in self.chain:\r\n                # print(block.index)\r\n                if block.index > lastBlockIndex:\r\n                    lastBlock = block\r\n                    lastBlockIndex = block.index\r\n            return lastBlock.index\r\n\r\n    def saveUnconfirmedTransactions(self):\r\n        # print(self.TRANSACTION_PATH)\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Blockchain Folder\")\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n        json_file = open(self.TRANSACTION_PATH + \"Transactions\" + \".json\", \"w\")\r\n        json_file.write((json.dumps([ob.__dict__ for ob in self.unconfirmed_transactions])))\r\n        json_file.close()\r\n\r\n    def isUserAllowed(self, ip):\r\n        for block in self.chain:\r\n            block: Block\r\n            transaction = json.loads(block.transaction)\r\n            # From Create Genesis Block\r\n            if transaction[\"type\"] == 0:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n            # From Invite\r\n            if transaction[\"type\"] == 1:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n        # Didndt find user\r\n        return False\r\n\r\n    def getOwner(self):\r\n        for block in self.chain:\r\n            transaction = json.loads(block.transaction)\r\n            if transaction[\"type\"]==0:\r\n                return transaction[\"ip\"]\r\n\r\n    def parseBlockchain(self):\r\n        \"\"\"\r\n        Parses Blockchain and returns 5 list of user types.\r\n        Peers that are in the blockchain and allowed.\r\n        Banned peers, Invites ,Admins and, Owner . All are lists.\r\n        \"\"\"\r\n        peers = []\r\n        bans = []\r\n        admins = []\r\n        invites = []\r\n        owner = []\r\n\r\n        # class GenesisTransaction:\r\n        #         self.type = 0\r\n        # class InviteTransaction:\r\n        #         self.type = 1\r\n        # class JoinTransaction:\r\n        #         self.type = 2\r\n        # class BanTransaction:\r\n        #         self.type = 3\r\n        # class UnbanTransaction:\r\n        #         self.type = 4\r\n        # class AddAdminTransaction:\r\n        #         self.type = 5\r\n        # class RemoveAdminTransaction:\r\n        #         self.type = 6\r\n\r\n        for block in self.chain:\r\n            transaction = json.loads(block.transaction)\r\n            if transaction[\"type\"]==0:\r\n                owner.append(transaction[\"ip\"])\r\n                admins.append(transaction[\"ip\"])\r\n                peers.append(transaction[\"ip\"])\r\n            elif transaction[\"type\"]==1:\r\n                invites.append(transaction[\"ip\"])\r\n            elif transaction[\"type\"]==2:\r\n                peers.append(transaction[\"ip\"])\r\n                invites.remove(transaction[\"ip\"])\r\n            elif transaction[\"type\"]==3:\r\n                peers.remove(transaction[\"ip\"])\r\n                bans.append(transaction[\"ip\"])\r\n            elif transaction[\"type\"]==4:\r\n                bans.remove(transaction[\"ip\"])\r\n            elif transaction[\"type\"]==5:\r\n                admins.append(transaction[\"ip\"])\r\n            elif transaction[\"type\"]==6:\r\n                admins.remove(transaction[\"ip\"])\r\n        # print(f\"Peers:{peers},Bans:{bans},Admins:{admins},Owners:{owner}\")\r\n        return peers,bans,admins,owner\r\n\r\nimport Networking\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/Blockchain.py b/Blockchain.py
---- a/Blockchain.py	(revision cb4143701770ee3570453e872214f89077e4515f)
-+++ b/Blockchain.py	(date 1650782465136)
-@@ -1,3 +1,4 @@
-+import math
- import os
- import json
- from os import listdir
-@@ -122,7 +123,8 @@
-         if len(self.peers) == 0:
-             return 1
-         else:
--            return len(self.peers)
-+            peers, bans, admins, owner = self.parseBlockchain()
-+            return math.floor(math.log2(len(peers)))
- 
-     def createGenesisBlock(self, client):
-         transaction = GenesisTransaction(client.publicIP, client.publicKey.save_pkcs1(format='PEM').decode("utf-8"))
-@@ -409,6 +411,7 @@
-             elif transaction["type"]==3:
-                 peers.remove(transaction["ip"])
-                 bans.append(transaction["ip"])
-+                if
-             elif transaction["type"]==4:
-                 bans.remove(transaction["ip"])
-             elif transaction["type"]==5:
Index: .idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_12_AM_[Changes]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_12_AM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_12_AM_[Changes]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_12_AM_[Changes]/shelved.patch	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,21 +0,0 @@
-Index: main.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import json\r\nimport logging\r\nimport threading\r\nfrom pickle import dumps, loads\r\nfrom flask import Flask, render_template, request, redirect\r\n\r\nimport Blockchain\r\nimport Compress\r\nfrom Networking import receiver, sendRequest, JoinRequest, SearchBundleRequest, receiveBundle, GetBundleRequest\r\nfrom Groups import GroupManager, Invite, Group\r\nfrom Client import Client\r\nimport easygui\r\nfrom Bundles import BundleManager\r\nfrom Downloads import DownloadManager\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = False\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    progress = downloadManager.getDownloadProgress()\r\n    return render_template(\"index.html\", groups=groupManager.groups, client=client, progress=progress)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    group = groupManager.getGroupWithName(group)\r\n    # Check if user should see admin panels.\r\n    peers, bans, admins, owner = group.blockchain.parseBlockchain()\r\n    print(peers,admins,bans)\r\n    # Check privs what to show on group page.\r\n    adminPriv = False\r\n    for admin in group.admins:\r\n        if admin[0] == client.publicIP:\r\n            adminPriv = True\r\n\r\n    ownerPriv = False\r\n    if group.blockchain.getOwner() == client.publicIP:\r\n        ownerPriv = True\r\n\r\n\r\n\r\n\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group, client=client, adminPriv=adminPriv,\r\n                           ownerPriv=ownerPriv, peers=peers, bans=bans, admins=admins)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    if downloadManager.STATUS:\r\n        downloadManager.STATUS = False\r\n        # downloadManager Off\r\n        print(\"Download Manager Not Active\")\r\n        return \"0\"\r\n    else:\r\n        downloadManager.STATUS = True\r\n        # downloadManager On\r\n        print(\"Download Manager Active\")\r\n        return \"1\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n        # TODO KEY SPECIFIC BLOCKCHAIN\r\n        ip = data[\"ip\"]  # This is string\r\n        transaction = Blockchain.InviteTransaction(ip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        # print(\"Generate Invite for :\", group)\r\n        # print(group)\r\n        invite = group.generateInvite()\r\n        return Compress.compress(invite.toJSON())\r\n\r\n\r\n\r\n@app.route('/deleteBundle', methods=['POST'])\r\ndef deleteBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupId = data[\"groupId\"]\r\n        bundleId = data[\"bundleId\"]\r\n        if groupManager.deleteBundle(groupId, bundleId):\r\n            return \"1\"\r\n        else:\r\n            return \"0\"\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        inviteDecomp = Compress.decompress(invite)\r\n        inviteLoad = json.loads(inviteDecomp)\r\n        invite = Invite(inviteLoad[\"id\"], inviteLoad[\"name\"], inviteLoad[\"timestamp\"], inviteLoad[\"peers\"])\r\n        joinReq = JoinRequest(invite.name, invite.timestamp)\r\n        print(invite.peers)\r\n        for peer in invite.peers:\r\n            print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq))\r\n            if res is not False:\r\n                # Response from user with group data.\r\n                group = res.group\r\n                group = Group(group.name, group.admins, group.peers, group.timestamp,\r\n                              blockchainPath=groupManager.DIR_PATH_GROUPS + group.name + \"\\\\Blockchain\", client=client)\r\n                groupManager.addGroup(group)\r\n                # Make Join Transaction.\r\n                transaction = Blockchain.JoinTransaction(client.publicIP,\r\n                                                         client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n                transactionStr = json.dumps(transaction.__dict__)\r\n                group.blockchain.addNewTransaction(transactionStr)\r\n                # transactionStr = json.dumps(transaction.__dict__)\r\n                # this is string json format\r\n                # print(transactionStr)\r\n                # print(transactionStr.__class__)\r\n                # Genereate signature for Transaction\r\n                # signature = rsa.sign(transactionStr.encode(), client.privateKey, 'SHA-1')\r\n                # genesis_block = Block(0, transactionStr, str(time.time()), \"0\", [str(signature)])\r\n                # genesis_block.hash = genesis_block.computeHash()\r\n                # self.saveBlock(genesis_block)\r\n                # self.chain.append(genesis_block)\r\n                return \"1\"\r\n        # No responses.\r\n        return \"0\"\r\n\r\n\r\n@app.route('/shareBundle', methods=['POST'])\r\ndef shareBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"bundleName\"]\r\n        desc = data[\"bundleDescription\"]\r\n        groupName = data[\"groupName\"]\r\n        print(name)\r\n        print(desc)\r\n        print(groupName)\r\n        path = easygui.diropenbox(msg=\"Select folder to share as bundle\", title=\"Share Bundle\")\r\n        bundle = bundleManager.createBundle(name, desc, path=path)\r\n        groupManager.addBundle(bundle, groupName)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/selectDownloadLocation', methods=['POST'])\r\ndef selectDownloadLocation():\r\n    if request.method == 'POST':\r\n        path = easygui.diropenbox(msg=\"Select folder to download bundles\", title=\"Select Bundle Download Location\")\r\n        print(path)\r\n        # Update Download Path in Config\r\n        client.DIR_PATH_DOWNLOADS = path\r\n        client.saveConfig()\r\n        # Return path to browser and update it in modal\r\n        return path\r\n\r\n\r\n@app.route('/searchBundles', methods=['POST'])\r\ndef searchBundles():\r\n    # print(\"Search Bundles Route\")\r\n    if request.method == 'POST':\r\n        data = request.form\r\n\r\n        # Get Keywords from search\r\n        keywords = data[\"searchKeyWords\"].split()\r\n        # print(\"Search for :\",keywords)\r\n\r\n        # Get Group\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n\r\n        searchReq = SearchBundleRequest(group.id, keywords)\r\n        responses = []\r\n        # SEND TO ALL PEERS COLLECT RESPONSES AND PRESENT\r\n        for peer in group.peers:\r\n            res = sendRequest(peer[0], 6700, dumps(searchReq))\r\n            # if other peer is responded.\r\n            if res is not False:\r\n                # print(res)\r\n                responses.append([peer[0], res])\r\n            else:\r\n                print(\"No Response from\", peer[0])\r\n        # Merge all responses to single list\r\n        # for x in responses:\r\n        #     print(\"Response:\",x[0],x[1],x[1].responseBundles)\r\n        # WITH RESPONSES DO STUFF.\r\n        # Respond\r\n        return render_template(\"search.html\", groups=groupManager.groups, group=group, responses=responses)\r\n\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n    if groupManager.createGroup(name, [client.publicIP]):\r\n        # Make First Block In Blockchain Append Admin\r\n        # Type 0 First Created\r\n        group = groupManager.getGroupWithName(name)\r\n        group.blockchain.createGenesisBlock(client)\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n\r\n@app.route('/getBundle', methods=['POST'])\r\ndef getBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        bundleId = data[\"bundleId\"]\r\n        groupId = data[\"groupId\"]\r\n        userIp = data[\"userIp\"]\r\n        # TODO dynamic port on receiver for bundle\r\n        portForBundleReceiver = 6701\r\n        bundleReceiver = threading.Thread(target=receiveBundle,\r\n                                          args=[portForBundleReceiver, client, groupManager, groupId, downloadManager])\r\n        bundleReceiver.start()\r\n        getBundleReq = GetBundleRequest(bundleId, groupId, portForBundleReceiver)\r\n        res = sendRequest(userIp, 6700, dumps(getBundleReq))\r\n        # if other peer is responded.\r\n        if res is not False:\r\n            # Responded decide what to do\r\n            pass\r\n        else:\r\n            # print(\"No Response from\", userIp)\r\n            pass\r\n    return \"1\"\r\n\r\n\r\n@app.route('/quitGroup', methods=['POST'])\r\ndef quitGroup():\r\n    # print('QUIT GROUP REQ')\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        if groupManager.quitGroup(group):\r\n            # True\r\n            return \"0\"\r\n        else:\r\n            # False\r\n            return \"1\"\r\n\r\n\r\n@app.route('/banUser', methods=['POST'])\r\ndef banUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.BanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/unbanUser', methods=['POST'])\r\ndef unbanUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.UnbanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/addAdmin', methods=['POST'])\r\ndef addAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.AddAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/removeAdmin', methods=['POST'])\r\ndef removeAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.RemoveAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    groupManager = GroupManager(client)\r\n    bundleManager = BundleManager()\r\n    downloadManager = DownloadManager(groupManager, client)\r\n    # TODO Networking Thread To Receive From Internet\r\n    receiver = threading.Thread(target=receiver, args=[groupManager])\r\n    receiver.start()\r\n    app.run(host='', port=6969)\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/main.py b/main.py
---- a/main.py	(revision 9bc0ced24672e1b7c197c25e5681de5191a1b7fc)
-+++ b/main.py	(date 1650784310570)
-@@ -34,7 +34,10 @@
-     group = groupManager.getGroupWithName(group)
-     # Check if user should see admin panels.
-     peers, bans, admins, owner = group.blockchain.parseBlockchain()
-+
-     print(peers,admins,bans)
-+    # print(group.admins)
-+    # print(group.peers)
-     # Check privs what to show on group page.
-     adminPriv = False
-     for admin in group.admins:
Index: .idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_12_AM__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_12_AM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_12_AM__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_12_AM__Changes_.xml	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_24-Apr-22_10_12_AM_[Changes]" date="1650784378671" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_12_AM_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 24-Apr-22 10:12 AM [Changes]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_3_18_PM__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_3_18_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_3_18_PM__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_3_18_PM__Changes_.xml	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_25-Apr-22_3_18_PM_[Changes]" date="1650889121347" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_3_18_PM_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 25-Apr-22 3:18 PM [Changes]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_48_PM_[Changes]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_48_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_48_PM_[Changes]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_48_PM_[Changes]/shelved.patch	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,69 +0,0 @@
-Index: main.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import json\r\nimport logging\r\nimport threading\r\nfrom pickle import dumps, loads\r\nfrom flask import Flask, render_template, request, redirect\r\n\r\nimport Blockchain\r\nimport Compress\r\nfrom Networking import receiver, sendRequest, JoinRequest, SearchBundleRequest, receiveBundle, GetBundleRequest\r\nfrom Groups import GroupManager, Invite, Group\r\nfrom Client import Client\r\nimport easygui\r\nfrom Bundles import BundleManager\r\nfrom Downloads import DownloadManager\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = False\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    progress = downloadManager.getDownloadProgress()\r\n    return render_template(\"index.html\", groups=groupManager.groups, client=client, progress=progress)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    group = groupManager.getGroupWithName(group)\r\n    groupManager.saveGroup(group)\r\n    # Check if user should see admin panels.\r\n    peers, bans, admins, owner = group.blockchain.parseBlockchain()\r\n    if owner[0] in peers:\r\n        peers.remove(owner[0])\r\n\r\n    if owner[0] in admins:\r\n        admins.remove(owner[0])\r\n\r\n    # Check privs what to show on group page.\r\n    adminPriv = False\r\n    for admin in group.admins:\r\n        if admin[0] == client.publicIP:\r\n            adminPriv = True\r\n\r\n    ownerPriv = False\r\n    if group.blockchain.getOwner() == client.publicIP:\r\n        ownerPriv = True\r\n\r\n    if client.publicIP in admins:\r\n        admins.remove(client.publicIP)\r\n    if client.publicIP in peers:\r\n        peers.remove(client.publicIP)\r\n\r\n    dif = group.blockchain.getDifficulty()\r\n    print(dif)\r\n    groupManager.saveGroup(group)\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group, client=client, adminPriv=adminPriv,\r\n                           ownerPriv=ownerPriv, peers=peers, bans=bans, admins=admins)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    if downloadManager.STATUS:\r\n        downloadManager.STATUS = False\r\n        # downloadManager Off\r\n        print(\"Download Manager Not Active\")\r\n        return \"0\"\r\n    else:\r\n        downloadManager.STATUS = True\r\n        # downloadManager On\r\n        print(\"Download Manager Active\")\r\n        return \"1\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n        # TODO KEY SPECIFIC BLOCKCHAIN\r\n        ip = data[\"ip\"]  # This is string\r\n        transaction = Blockchain.InviteTransaction(ip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        # print(\"Generate Invite for :\", group)\r\n        # print(group)\r\n        invite = group.generateInvite()\r\n        return Compress.compress(invite.toJSON())\r\n\r\n\r\n\r\n@app.route('/deleteBundle', methods=['POST'])\r\ndef deleteBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupId = data[\"groupId\"]\r\n        bundleId = data[\"bundleId\"]\r\n        if groupManager.deleteBundle(groupId, bundleId):\r\n            return \"1\"\r\n        else:\r\n            return \"0\"\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        inviteDecomp = Compress.decompress(invite)\r\n        inviteLoad = json.loads(inviteDecomp)\r\n        invite = Invite(inviteLoad[\"id\"], inviteLoad[\"name\"], inviteLoad[\"timestamp\"], inviteLoad[\"peers\"])\r\n        joinReq = JoinRequest(invite.name, invite.timestamp)\r\n        # print(invite.peers)\r\n        for peer in invite.peers:\r\n            # print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq))\r\n            if res is not False:\r\n                # Response from user with group data.\r\n                group = res.group\r\n                group = Group(group.name, group.admins, group.peers, group.timestamp,\r\n                              blockchainPath=groupManager.DIR_PATH_GROUPS + group.name + \"\\\\Blockchain\", client=client)\r\n                groupManager.addGroup(group)\r\n                # Make Join Transaction.\r\n                transaction = Blockchain.JoinTransaction(client.publicIP,\r\n                                                         client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n                transactionStr = json.dumps(transaction.__dict__)\r\n                group.blockchain.addNewTransaction(transactionStr)\r\n                return \"1\"\r\n        # No responses.\r\n        return \"0\"\r\n\r\n\r\n@app.route('/shareBundle', methods=['POST'])\r\ndef shareBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"bundleName\"]\r\n        desc = data[\"bundleDescription\"]\r\n        groupName = data[\"groupName\"]\r\n        # print(name)\r\n        # print(desc)\r\n        # print(groupName)\r\n        path = easygui.diropenbox(msg=\"Select folder to share as bundle\", title=\"Share Bundle\")\r\n        bundle = bundleManager.createBundle(name, desc, path=path)\r\n        groupManager.addBundle(bundle, groupName)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/selectDownloadLocation', methods=['POST'])\r\ndef selectDownloadLocation():\r\n    if request.method == 'POST':\r\n        path = easygui.diropenbox(msg=\"Select folder to download bundles\", title=\"Select Bundle Download Location\")\r\n        # print(path)\r\n        # Update Download Path in Config\r\n        client.DIR_PATH_DOWNLOADS = path\r\n        client.saveConfig()\r\n        # Return path to browser and update it in modal\r\n        return path\r\n\r\n\r\n@app.route('/searchBundles', methods=['POST'])\r\ndef searchBundles():\r\n    # print(\"Search Bundles Route\")\r\n    if request.method == 'POST':\r\n        data = request.form\r\n\r\n        # Get Keywords from search\r\n        keywords = data[\"searchKeyWords\"].split()\r\n        # print(\"Search for :\",keywords)\r\n\r\n        # Get Group\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n\r\n        searchReq = SearchBundleRequest(group.id, keywords)\r\n        responses = []\r\n        # SEND TO ALL PEERS COLLECT RESPONSES AND PRESENT\r\n        for peer in group.peers:\r\n            res = sendRequest(peer[0], 6700, dumps(searchReq))\r\n            # if other peer is responded.\r\n            if res is not False:\r\n                # print(res)\r\n                responses.append([peer[0], res])\r\n            else:\r\n                print(\"No Response from\", peer[0])\r\n        # Merge all responses to single list\r\n        # for x in responses:\r\n        #     print(\"Response:\",x[0],x[1],x[1].responseBundles)\r\n        # WITH RESPONSES DO STUFF.\r\n        # Respond\r\n        return render_template(\"search.html\", groups=groupManager.groups, group=group, responses=responses)\r\n\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n    if groupManager.createGroup(name, [client.publicIP]):\r\n        # Make First Block In Blockchain Append Admin\r\n        # Type 0 First Created\r\n        group = groupManager.getGroupWithName(name)\r\n        group.blockchain.createGenesisBlock(client)\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n\r\n@app.route('/getBundle', methods=['POST'])\r\ndef getBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        bundleId = data[\"bundleId\"]\r\n        groupId = data[\"groupId\"]\r\n        userIp = data[\"userIp\"]\r\n        # TODO dynamic port on receiver for bundle\r\n        portForBundleReceiver = 6701\r\n        bundleReceiver = threading.Thread(target=receiveBundle,\r\n                                          args=[portForBundleReceiver, client, groupManager, groupId, downloadManager])\r\n        bundleReceiver.start()\r\n        getBundleReq = GetBundleRequest(bundleId, groupId, portForBundleReceiver)\r\n        res = sendRequest(userIp, 6700, dumps(getBundleReq))\r\n        # if other peer is responded.\r\n        if res is not False:\r\n            # Responded decide what to do\r\n            pass\r\n        else:\r\n            # print(\"No Response from\", userIp)\r\n            pass\r\n    return \"1\"\r\n\r\n\r\n@app.route('/quitGroup', methods=['POST'])\r\ndef quitGroup():\r\n    # print('QUIT GROUP REQ')\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        if groupManager.quitGroup(group):\r\n            # True\r\n            return \"0\"\r\n        else:\r\n            # False\r\n            return \"1\"\r\n\r\n\r\n@app.route('/banUser', methods=['POST'])\r\ndef banUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.BanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/unbanUser', methods=['POST'])\r\ndef unbanUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.UnbanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/addAdmin', methods=['POST'])\r\ndef addAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.AddAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/removeAdmin', methods=['POST'])\r\ndef removeAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.RemoveAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    groupManager = GroupManager(client)\r\n    bundleManager = BundleManager()\r\n    downloadManager = DownloadManager(groupManager, client)\r\n    # TODO Networking Thread To Receive From Internet\r\n    receiver = threading.Thread(target=receiver, args=[groupManager])\r\n    receiver.start()\r\n    app.run(host='', port=6969)\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/main.py b/main.py
---- a/main.py	(revision 6318741464290219269f85647dad53f456eab1ec)
-+++ b/main.py	(date 1650893248251)
-@@ -57,7 +57,7 @@
-         peers.remove(client.publicIP)
- 
-     dif = group.blockchain.getDifficulty()
--    print(dif)
-+    # print(dif)
-     groupManager.saveGroup(group)
-     return render_template("groups.html", groups=groupManager.groups, group=group, client=client, adminPriv=adminPriv,
-                            ownerPriv=ownerPriv, peers=peers, bans=bans, admins=admins)
-Index: Networking.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import copy\r\nimport json\r\nimport pickle\r\nimport socket\r\nimport threading\r\nfrom socket import *\r\nfrom Bundles import Bundle\r\nimport Client\r\nfrom Groups import GroupManager, Group\r\nimport os\r\nimport hashlib\r\nimport Blockchain\r\n\r\n\r\nclass Request:\r\n    def __init__(self, type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\n\r\n# All Classes extended Request even Response Classes just for type and toJSON method.\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self, name, timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self, group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\n\r\nclass SearchBundleRequest(Request):\r\n    def __init__(self, groupId, keyword):\r\n        super().__init__(2)\r\n        self.groupID = groupId\r\n        self.keywords = keyword\r\n\r\n\r\nclass SearchBundleResponse(Request):\r\n    def __init__(self, responseBundles):\r\n        super().__init__(2)\r\n        self.responseBundles = responseBundles\r\n\r\n\r\nclass GetBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId, portForBundleReceiver):\r\n        super().__init__(3)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.portForBundleReceiver = portForBundleReceiver\r\n\r\n\r\nclass GetBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(3)\r\n        self.answer = answer\r\n\r\n\r\nclass CheckBundleAvailabilityRequest(Request):\r\n    def __init__(self, bundleId, groupId):\r\n        super().__init__(4)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n\r\n\r\nclass CheckBundleAvailabilityResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(4)\r\n        self.answer = answer\r\n\r\n\r\nclass DownloadBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId, file, port):\r\n        super().__init__(5)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.file = file\r\n        self.port = port\r\n\r\n\r\nclass DownloadBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(5)\r\n        self.answer = answer\r\n\r\n\r\nclass UpdateBlockchainRequest(Request):\r\n    def __init__(self, groupId):\r\n        super().__init__(6)\r\n        self.groupId = groupId\r\n\r\n\r\nclass UpdateBlockchainResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(6)\r\n        self.answer = answer\r\n\r\n\r\nclass GetBlockRequest(Request):\r\n    def __init__(self, groupId, blockIndex):\r\n        super().__init__(7)\r\n        self.groupId = groupId\r\n        self.blockIndex = blockIndex\r\n\r\n\r\nclass GetBlockResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(7)\r\n        self.answer = answer\r\n\r\nclass GetSignatureRequest(Request):\r\n    def __init__(self, groupId, lastIndex,transaction):\r\n        super().__init__(8)\r\n        self.groupId = groupId\r\n        self.lastIndex = lastIndex\r\n        self.transaction = transaction\r\n\r\nclass GetSignatureResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(8)\r\n        self.answer = answer\r\n\r\n\r\n\r\ndef requestHandler(data, addr, groupManager: GroupManager):\r\n    req = pickle.loads(data)\r\n    print(f\"Received From {addr[0]}:{addr[1]} {req.__class__.__name__}\")\r\n\r\n    # Response to JoinRequest\r\n    #TODO refactor this.\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name, req.timestamp)\r\n        group = groupManager.getGroupWithName(req.name)\r\n        if group.blockchain.isUserAllowed(addr[0]):\r\n            groupManager.addPeerGroup(req.name, [addr[0]])\r\n            groupCpy = copy.copy(group)\r\n            del groupCpy.bundles\r\n            joinResponse = JoinResponse(groupCpy)\r\n            return pickle.dumps(joinResponse)\r\n        else:\r\n            return False\r\n\r\n    # Response to search req\r\n    elif req.type == 2:\r\n        # Create The Request again for local use\r\n        req = SearchBundleRequest(req.groupID, req.keywords)\r\n        # Get All Bundles User has\r\n        bundlesOfGroup = groupManager.getGroupWithId(req.groupID).bundles\r\n        # Bundles to reply\r\n        responseBundles = []\r\n        # print(responseBundles)\r\n        for bundle in bundlesOfGroup:\r\n            # For each bundle make a single list (bundleKeywords) and search if any of the keywords other user send are in there then send back\r\n            name = bundle.name.split()\r\n            desc = bundle.description.split()\r\n            bundleKeywords = name + desc\r\n            # print(\"Bundle Keywords : \",bundleKeywords)\r\n            # print(\"Request Keywords : \",req.keywords)\r\n            if any(keyword in req.keywords for keyword in bundleKeywords):\r\n                # print(\"HIT\")\r\n                responseBundles.append({\"id\": bundle.id, \"name\": bundle.name, \"description\": bundle.description})\r\n        # Create Response and return it to be used as answer\r\n        # print(responseBundles)\r\n        searchResponse = SearchBundleResponse(responseBundles)\r\n        # print(\"Search Response :\",searchResponse)\r\n        return pickle.dumps(searchResponse)\r\n\r\n    elif req.type == 3:\r\n        req = GetBundleRequest(req.bundleId, req.groupId, req.portForBundleReceiver)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        bundle = group.getBundleWithId(req.bundleId)\r\n        bundleReceiver = threading.Thread(target=sendBundle,\r\n                                          args=[addr, req.portForBundleReceiver, groupManager, group, bundle])\r\n        bundleReceiver.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        # TODO 9/4 ????\r\n        return pickle.dumps(GetBundleResponse(1))\r\n\r\n    elif req.type == 4:\r\n        req = CheckBundleAvailabilityRequest(req.bundleId, req.groupId)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        bundle = group.getBundleWithId(req.bundleId)\r\n        if bundle is False:\r\n            # Not Found\r\n            return pickle.dumps(CheckBundleAvailabilityResponse(0))\r\n        else:\r\n            # Found\r\n            return pickle.dumps(CheckBundleAvailabilityResponse(1))\r\n\r\n    elif req.type == 5:\r\n        # print(\"Received Request To Send File\")\r\n        req = DownloadBundleRequest(req.bundleId, req.groupId, req.file, req.port)\r\n        uploadThread = threading.Thread(target=uploadBundle,\r\n                                        args=[addr, req.port, req.bundleId, req.groupId, req.file, groupManager])\r\n        uploadThread.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        # TODO 9/4 ????\r\n        return pickle.dumps(DownloadBundleResponse(1))\r\n\r\n    elif req.type == 6:\r\n        req = UpdateBlockchainRequest(req.groupId)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        # If i am in group for group that im not in.\r\n        if group is not False:\r\n            if group.blockchain.isUserAllowed(addr[0]):\r\n                # User is ok\r\n                lastBlock = group.blockchain.getLastBlock()\r\n                lastBlock: Blockchain.Block\r\n                lastBlockIndex = lastBlock.index\r\n                return pickle.dumps(UpdateBlockchainResponse(lastBlockIndex))\r\n            else:\r\n                # User not invited not joined, therefore don't answer.\r\n                return False\r\n\r\n    elif req.type == 7:\r\n        req = GetBlockRequest(req.groupId, req.blockIndex)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        block = group.blockchain.getBlockWithIndex(req.blockIndex)\r\n        if block is not False:\r\n            return pickle.dumps(GetBlockResponse(block))\r\n        else:\r\n            return False\r\n\r\n    elif req.type == 8:\r\n        req = GetSignatureRequest(req.groupId, req.lastIndex, req.transaction)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        lastIndex = group.blockchain.getLastBlockIndex()\r\n        #If up to date or more\r\n        if lastIndex==req.lastIndex:\r\n            #Up To date\r\n            if group.blockchain.verifyTransaction(req.transaction):\r\n                #Transaction Ok\r\n                signature = rsa.sign(transactionStr.encode(), group.client.privateKey, 'SHA-1')\r\n                return pickle.dumps(GetSignatureResponse(str(signature)))\r\n            else:\r\n                #Transaction not ok.\r\n                return pickle.dumps(GetSignatureResponse(1))\r\n\r\n        else:\r\n            #Not up to date.\r\n            return pickle.dumps(GetSignatureResponse(0))\r\n\r\n\r\ndef responseHandler(data, addr):\r\n    res = pickle.loads(data)\r\n\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 2:\r\n        res = SearchBundleResponse(res.responseBundles)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 3:\r\n        res = SearchBundleResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 4:\r\n        res = CheckBundleAvailabilityResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 5:\r\n        res = DownloadBundleResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 6:\r\n        res = UpdateBlockchainResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 7:\r\n        res = GetBlockResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 8:\r\n        res = GetSignatureResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        try:\r\n            # RECEIVE AND RESPOND.\r\n            data, addr = sock.recvfrom(65537)\r\n            # data, addr = sock.recvfrom(65507)\r\n            # print(\"Received from :\", addr)\r\n            response = requestHandler(data, addr, groupManager)\r\n            # Request Handler if not want to answer returns False.\r\n            if response is not False:\r\n                sock.sendto(response, addr)\r\n        except Exception as e:\r\n            pass\r\n\r\n\r\ndef sendRequest(address, port, request):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.settimeout(1)\r\n    try:\r\n        clientSocket.sendto(request, (address, port))\r\n        data, addr = clientSocket.recvfrom(65537)\r\n        res = responseHandler(data, addr)\r\n        return res\r\n    # TODO except socket.timeout\r\n    except Exception as exception:\r\n        # print(\"Exception on SendRequest:\", exception)\r\n        return False\r\n\r\n\r\ndef receiveBundle(port, client, groupManager, groupId, downloadManager):\r\n    # print(\"RECEIVING BUNDLE THREAD\")\r\n    bundleBytes = b\"\"\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.bind((\"0.0.0.0\", port))\r\n        # print(\"Bundle Receiver Ready\")\r\n        s.listen()\r\n        conn, addr = s.accept()\r\n        with conn:\r\n            print(f\"Connection From {addr[0]}:{addr[1]} Accepted.\")\r\n            while True:\r\n                data = conn.recv(1024)\r\n                # print(data)\r\n                bundleBytes = bundleBytes + data\r\n                # TODO save Bytes to group and downloads also start downloading.\r\n                if not data:\r\n                    # print(\"Break\")\r\n                    break\r\n            # print(\"Break3\")\r\n    # print(\"Bundle Str\",bundleBytes.decode())\r\n    bundleObj = json.loads(bundleBytes.decode())\r\n    # Fix Bundle Root to be downloaded and location\r\n    client: Client.Client\r\n    bundleObj[\"root\"] = client.DIR_PATH_DOWNLOADS\r\n    bundle = Bundle(bundleObj[\"name\"], bundleObj[\"description\"], bundleObj[\"id\"], bundleObj[\"timestamp\"],\r\n                    bundleObj[\"root\"], bundleObj[\"pieceSize\"], bundleObj[\"files\"])\r\n    group = groupManager.getGroupWithId(groupId)\r\n    groupManager.addBundle(bundle, group.name)\r\n    downloadManager.downloadBundle(bundle, group)\r\n\r\n\r\ndef sendBundle(addr, port, groupManager, group, bundle):\r\n    # print(\"SENDING BUNDLE THREAD\")\r\n    group: Group\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.connect((addr[0], port))\r\n        print(f\"Connected To {addr[0]}:{addr[1]}.\")\r\n        # print(\"SENDING DATA\")\r\n        groupManager: GroupManager\r\n        json_file_name = bundle.name + \".json\"\r\n        bundleDir = groupManager.DIR_PATH_GROUPS + group.name + \"\\\\\" + \"Bundles\" + \"\\\\\" + json_file_name\r\n        print(bundleDir)\r\n        print(json_file_name)\r\n        with open(bundleDir) as f:\r\n            bundleContent = f.read()\r\n            bundleObj = json.loads(bundleContent)\r\n            bundleObj[\"root\"] = \"\"\r\n            bundleStr = json.dumps(bundleObj)\r\n\r\n        s.sendall(bundleStr.encode())\r\n\r\n\r\ndef is_port_in_use(port: int) -> bool:\r\n    import socket\r\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\r\n        return s.connect_ex(('localhost', port)) == 0\r\n\r\n\r\ndef downloadBundle(downloadManager, port, peer, file, bundle, usedPeers, freeFiles):\r\n    pieceList = []\r\n    # Find pieces missing\r\n    for x in bundle.files:\r\n        if x[\"path\"] == file[0]:\r\n            pieceList = x[\"pieces\"]\r\n            break\r\n    # pieceList = [[0, '5920572cf97d3711a77a9b7a3469a5fd03bb2a8a', 0]]\r\n    # print(\"DOWNLOADING BUNDLE THREAD\")\r\n    filePath = bundle.root + f\"\\\\{bundle.name}\" + file[0]\r\n    dir = filePath.rsplit('\\\\', 1)[0]\r\n    # print(dir)\r\n    # Create Directory's that don't exist.\r\n    isExist = os.path.exists(dir)\r\n    if not isExist:\r\n        # Create a new directory because it does not exist\r\n        os.makedirs(dir)\r\n\r\n    if os.path.exists(filePath) is False:\r\n        print(\"Creating File\")\r\n        file = open(filePath, 'x')\r\n        file.close()\r\n\r\n    with open(filePath, 'rb+') as openfileobject:\r\n        with socket(AF_INET, SOCK_STREAM) as s:\r\n            s.bind((\"0.0.0.0\", port))\r\n            # print(\"Bundle Receiver Ready\")\r\n            s.listen()\r\n            conn, addr = s.accept()\r\n            with conn:\r\n                print(f\"Connection From {addr[0]}:{addr[1]} Accepted.\")\r\n                data = conn.recv(1024)\r\n                if data.decode() == \"OK\":\r\n                    # print(\"Received Ok\")\r\n                    for piece in pieceList:\r\n                        if piece[2] == 0:\r\n                            # print(f\"Sending Piece num {piece[0]} \")\r\n                            conn.sendall(str(piece[0]).encode())\r\n                            openfileobject.seek(piece[0] * bundle.pieceSize)\r\n                            data = conn.recv(100000)\r\n                            # print(f\"Received {data}\")\r\n                            if hashlib.sha1(data).hexdigest() == piece[1]:\r\n                                # print(\"HASH OK\")\r\n                                openfileobject.write(data)\r\n                                piece[2] = 1\r\n                                # print(piece)\r\n                            else:\r\n                                pass\r\n                                # print(\"hashes dont match\")\r\n                    # delimmiter for data\r\n                    conn.sendall(\"\uD83E\uDD6D\uD83C\uDF53\uD83C\uDF47\uD83C\uDF49\uD83C\uDF50\uD83E\uDD67\uD83C\uDF4A\uD83C\uDF4D\uD83C\uDF4F\uD83E\uDD51\uD83C\uDF51\uD83C\uDF4C\uD83C\uDF4E\uD83C\uDF50\uD83C\uDF49\uD83C\uDF47\uD83C\uDF53\uD83E\uDD6D\uD83E\uDD5D\uD83C\uDF52\uD83C\uDF45\".encode())\r\n                    usedPeers.remove(peer)\r\n                    downloadManager.saveBundle(bundle)\r\n    # print(f\"Thread Exit {file}\")\r\n\r\n\r\ndef uploadBundle(addr, port, bundleId, groupId, file, groupManager):\r\n    # print(\"SENDING BUNDLE THREAD\")\r\n    group = groupManager.getGroupWithId(groupId)\r\n    bundle = group.getBundleWithId(bundleId)\r\n    with open(bundle.root + file, 'rb') as openfileobject:\r\n        try:\r\n            with socket(AF_INET, SOCK_STREAM) as s:\r\n                s.connect((addr[0], port))\r\n                # print(\"SENDING DATA\")\r\n                s.sendall(\"OK\".encode())\r\n                while True:\r\n                    piece = s.recv(1024)\r\n                    # delimmiter for data\r\n                    if piece == \"\uD83E\uDD6D\uD83C\uDF53\uD83C\uDF47\uD83C\uDF49\uD83C\uDF50\uD83E\uDD67\uD83C\uDF4A\uD83C\uDF4D\uD83C\uDF4F\uD83E\uDD51\uD83C\uDF51\uD83C\uDF4C\uD83C\uDF4E\uD83C\uDF50\uD83C\uDF49\uD83C\uDF47\uD83C\uDF53\uD83E\uDD6D\uD83E\uDD5D\uD83C\uDF52\uD83C\uDF45\".encode():\r\n                        break\r\n                    else:\r\n                        if piece == b'':\r\n                            # print(\"Empty\")\r\n                            pass\r\n                        else:\r\n                            piece = int(piece.decode())\r\n                            # print(f\"Trying to send {piece}\")\r\n                            openfileobject.seek(piece * bundle.pieceSize)\r\n                            readData = openfileobject.read(bundle.pieceSize)\r\n                            s.sendall(readData)\r\n        except ConnectionResetError as exception:\r\n            print(\"Downloader DC\")\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/Networking.py b/Networking.py
---- a/Networking.py	(revision 6318741464290219269f85647dad53f456eab1ec)
-+++ b/Networking.py	(date 1650893380803)
-@@ -10,6 +10,7 @@
- import os
- import hashlib
- import Blockchain
-+import rsa
- 
- 
- class Request:
-@@ -236,7 +237,7 @@
-             #Up To date
-             if group.blockchain.verifyTransaction(req.transaction):
-                 #Transaction Ok
--                signature = rsa.sign(transactionStr.encode(), group.client.privateKey, 'SHA-1')
-+                signature = rsa.sign(req.transaction.encode(), group.client.privateKey, 'SHA-1')
-                 return pickle.dumps(GetSignatureResponse(str(signature)))
-             else:
-                 #Transaction not ok.
-Index: Blockchain.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import math\r\nimport os\r\nimport json\r\nfrom os import listdir\r\nimport rsa\r\nimport time\r\nfrom time import sleep\r\nimport threading\r\nfrom hashlib import sha256\r\nimport copy\r\nfrom pickle import dumps, loads\r\n\r\n\r\nclass Block:\r\n    def __init__(self, index, transaction, timestamp, previous_hash, signatures):\r\n        self.index = index\r\n\r\n        self.transaction = transaction\r\n\r\n        self.timestamp = timestamp\r\n\r\n        self.previous_hash = previous_hash\r\n\r\n        self.signatures = signatures\r\n\r\n    def computeHash(self):\r\n        mycopy = copy.copy(self)\r\n        del mycopy.signatures\r\n        # print(mycopy.__dict__)\r\n        if hasattr(mycopy, 'hash'):\r\n            del mycopy.hash\r\n        block_string = json.dumps(mycopy.__dict__, sort_keys=True)\r\n        return sha256(block_string.encode()).hexdigest()\r\n\r\n\r\nclass UnconfirmedTransaction:\r\n    def __init__(self, transaction, signatures=[]):\r\n        self.transaction = transaction\r\n        self.signatures = signatures\r\n\r\n\r\nclass GenesisTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 0\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass InviteTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 1\r\n        self.ip = ip\r\n\r\n\r\nclass JoinTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 2\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass BanTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 3\r\n        self.ip = ip\r\n\r\n\r\nclass UnbanTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 4\r\n        self.ip = ip\r\n\r\n\r\nclass AddAdminTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 5\r\n        self.ip = ip\r\n\r\n\r\nclass RemoveAdminTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 6\r\n        self.ip = ip\r\n\r\n\r\nclass Blockchain:\r\n    def __init__(self, path, groupPeers, groupAdmins, groupId, client):\r\n        self.BLOCKCHAIN_PATH = path\r\n        self.TRANSACTION_PATH = self.BLOCKCHAIN_PATH + \"\\\\Transactions\\\\\"\r\n        self.unconfirmed_transactions = []\r\n        self.chain = []\r\n        self.peers = groupPeers\r\n        self.groupId = groupId\r\n        self.groupAdmins = groupAdmins\r\n        self.client = client\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n            # Load Unconfirmed Transactions\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n\r\n        self.loadTransactions()\r\n\r\n        # print(self.unconfirmed_transactions)\r\n        # Load Blocks here\r\n        blockFiles = [f for f in listdir(self.BLOCKCHAIN_PATH) if os.path.isfile(os.path.join(self.BLOCKCHAIN_PATH, f))]\r\n        for blockFile in blockFiles:\r\n            self.loadBlock(blockFile)\r\n\r\n        # Start Casual Operations.\r\n        # Thread This.\r\n        miner = threading.Thread(target=self.mine, args=[client])\r\n        miner.start()\r\n        # print(self.unconfirmed_transactions)\r\n        # for block in self.chain:\r\n        #     print(block)\r\n\r\n    def getDifficulty(self):\r\n        # Diffuculty of blockchain will be dependent on the users participating in  --->log2(peers)\r\n        return 2\r\n        if len(self.peers) == 0:\r\n            return 1\r\n        else:\r\n            peers, bans, admins, owner = self.parseBlockchain()\r\n            return math.floor(math.log2(len(peers)))\r\n\r\n    def createGenesisBlock(self, client):\r\n        transaction = GenesisTransaction(client.publicIP, client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        # this is string json format\r\n        # print(transactionStr)\r\n        # print(transactionStr.__class__)\r\n        # Genereate signature for Transaction\r\n        signature = rsa.sign(transactionStr.encode(), client.privateKey, 'SHA-1')\r\n        genesis_block = Block(0, transactionStr, str(time.time()), \"0\", [client.publicIP,str(signature)])\r\n        genesis_block.hash = genesis_block.computeHash()\r\n        self.saveBlock(genesis_block)\r\n        self.chain.append(genesis_block)\r\n\r\n    def verifyTransaction(self,transaction):\r\n        #TODO verify transactions.\r\n        return True\r\n\r\n    def saveBlock(self, block):\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Creating Blockchain Folder\")\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n        blockFile = open(self.BLOCKCHAIN_PATH + \"\\\\Block\" + str(block.index) + \".json\", \"w\")\r\n        # print(block.__dict__)\r\n        blockFile.write(json.dumps(block.__dict__))\r\n        blockFile.close()\r\n\r\n    def loadTransactions(self):\r\n        filePath = self.TRANSACTION_PATH + \"Transactions.json\"\r\n        if os.path.exists(filePath):\r\n            try:\r\n                file = open(filePath)\r\n                # print(file)\r\n                json_load_group = json.load(file)\r\n                file.close()\r\n            except Exception as e:\r\n                print(\"Error Opening Transaction file :\", e)\r\n            for x in json_load_group:\r\n                transaction = UnconfirmedTransaction(x[\"transaction\"], x[\"signatures\"])\r\n                # print(transaction)\r\n                self.unconfirmed_transactions.append(transaction)\r\n            # print(self.unconfirmed_transactions)\r\n\r\n    def loadBlock(self, blockFiles):\r\n        # print(blockFiles)\r\n        filePath = self.BLOCKCHAIN_PATH + \"\\\\\" + blockFiles\r\n        file = open(filePath)\r\n        # print(file)\r\n        block = json.load(file)\r\n        file.close()\r\n        # # print(block)\r\n        # transaction = json.loads(block[\"transaction\"])\r\n        # # print(transaction)\r\n        # # print(transaction.__class__)\r\n        # # Make transaction here\r\n        # if transaction[\"type\"] == 0:\r\n        #     # print(\"Genesis block\")\r\n        #     transactionObj = GenesisTransaction(transaction[\"ip\"], transaction[\"publicKey\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        blockObj = Block(block[\"index\"], block[\"transaction\"], block[\"timestamp\"], block[\"previous_hash\"],\r\n                         block[\"signatures\"])\r\n        blockObj.hash = block[\"hash\"]\r\n        # elif transaction[\"type\"] == 1:\r\n        #     # print(\"Genesis block\")\r\n        #     # print(transaction)\r\n        #     transactionObj = InviteTransaction(transaction[\"ip\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        #     blockObj = Block(block[\"index\"], transactionStr, block[\"timestamp\"], block[\"previous_hash\"],\r\n        #                      block[\"signatures\"])\r\n        #     blockObj.hash = block[\"hash\"]\r\n\r\n        self.chain.append(blockObj)\r\n        # print(blockObj.__dict__)\r\n\r\n    def addNewTransaction(self, transaction: str):\r\n        newUnconfirmedTransaction = UnconfirmedTransaction(transaction)\r\n        self.unconfirmed_transactions.append(newUnconfirmedTransaction)\r\n        self.saveUnconfirmedTransactions()\r\n\r\n    def updateBlockchain(self, client):\r\n        for peer in self.peers:\r\n            # Dont send to self\r\n            if peer[0] != client.publicIP:\r\n                # For each peer ask their max index of blockchain\r\n                updateBlockchainReq = Networking.UpdateBlockchainRequest(self.groupId)\r\n                res = Networking.sendRequest(peer[0], 6700, dumps(updateBlockchainReq))\r\n                if res is not False:\r\n                    # if the response is bigger than me ask him for his block until we are at the same.\r\n                    if res.answer > self.getLastBlockIndex():\r\n                        print(self.getLastBlockIndex().__class__, res.answer.__class__)\r\n                        while self.getLastBlockIndex() < res.answer:\r\n                            # Get block\r\n                            getBlockReq = Networking.GetBlockRequest(self.groupId, self.getLastBlockIndex() + 1)\r\n                            blockRes = Networking.sendRequest(peer[0], 6700, dumps(getBlockReq))\r\n                            if blockRes is not False:\r\n                                print(f\"Update BC Response:{blockRes}\")\r\n                                # print(blockRes.answer)\r\n                                block = blockRes.answer\r\n                                block: Block\r\n                                print(block.index, block.transaction, block.signatures, block.timestamp,\r\n                                      block.previous_hash, block.hash)\r\n                                newBlock = Block(block.index, block.transaction, block.timestamp, block.previous_hash,\r\n                                                 block.signatures)\r\n                                newBlock.hash = block.hash\r\n                                if self.validateNewBlock(newBlock):\r\n                                    self.saveBlock(newBlock)\r\n                                    self.chain.append(newBlock)\r\n                            else:\r\n                                break\r\n                    else:\r\n                        # print(id(self.peers))\r\n                        peers, bans, admins, owner = self.parseBlockchain()\r\n                        # self.peers = peers\r\n                        # self.groupAdmins = admins\r\n                        # print(id(self.peers))\r\n                        # print(\"Blockchain Updated And Parsed\")\r\n                        # print(\"Up-to-date.\")\r\n                        pass\r\n\r\n        #Update Group Peers And Admins\r\n        peers, bans, admins, owner = self.parseBlockchain()\r\n        for ip in admins:\r\n            inside = False\r\n            for admin in self.groupAdmins:\r\n                if admin[0]==ip:\r\n                    inside = True\r\n            if not inside:\r\n                self.groupAdmins.append([ip])\r\n\r\n\r\n        for ip in peers:\r\n            inside = False\r\n            for peer in self.peers:\r\n                if peer[0]==ip:\r\n                    inside = True\r\n            if not inside:\r\n                self.peers.append([ip])\r\n\r\n\r\n    def getBlockWithIndex(self, index):\r\n        for block in self.chain:\r\n            block: Block\r\n            if block.index == index:\r\n                return block\r\n        return False\r\n\r\n    def validateNewBlock(self, newBlock):\r\n        \"\"\"This function is for new blocks that come from peers returns true if blocks checks out.\"\"\"\r\n        newBlock: Block\r\n\r\n        # If hash ok.\r\n        if newBlock.computeHash() == newBlock.hash:\r\n            # Validation for genesis block\r\n            if newBlock.index == 0:\r\n                if self.getLastBlockIndex() == -1:\r\n                    # No other blocks accept it.\r\n                    return True\r\n                else:\r\n                    return False\r\n            else:\r\n                # Check if new block is made with the same previous block.\r\n                # TODO if not resolve ?\r\n                if newBlock.previous_hash == self.getLastBlock().computeHash():\r\n                    # TODO check if signatures okay.\r\n                    # TODO check timestamp.\r\n                    # TODO check difficulty based on blockchain etc.\r\n                    return True\r\n\r\n    def mine(self, client):\r\n        while True:\r\n            # Update Blockchain.\r\n            self.updateBlockchain(client)\r\n            if not self.unconfirmed_transactions:\r\n                # If No Transaction sleep and check again soon.\r\n                sleep(30)\r\n            else:\r\n                diff = self.getDifficulty()\r\n                print(f\"Blockchain Difficulty :{diff}\")\r\n                print(f\"Unconfirmed Transactions:{len(self.unconfirmed_transactions)}\")\r\n                for transaction in self.unconfirmed_transactions:\r\n                    transaction: UnconfirmedTransaction\r\n                    # For Each Transaction if signatures < difficulty collect transactions\r\n                    if diff > len(transaction.signatures):\r\n                        if not len(transaction.signatures):\r\n                            # No Signatures add my signature\r\n                            signature = rsa.sign(transaction.transaction.encode(), client.privateKey, 'SHA-1')\r\n                            transaction.signatures.append([str(client.publicIP),str(signature)])\r\n                            self.saveUnconfirmedTransactions()\r\n                        else:\r\n                            print(\"TRYING TO MINE FROM PEERS\")\r\n                            for peer in self.peers:\r\n                                if peer[0]!=client.publicIP:\r\n                                    print(f\"Trying to get signatures from :{peer[0]}\")\r\n                                    print(transaction.transaction)\r\n                                    #Send Transaction get signature.\r\n                                    signReq = Networking.GetSignatureRequest(self.groupId,self.getLastBlockIndex(),transaction.transaction)\r\n                                    res = Networking.sendRequest(peer[0], 6700, dumps(signReq))\r\n                                    if res is not False:\r\n                                        if res.answer!=0 and res.answer!=1:\r\n                                            #Verified.\r\n                                            print(res.answer)\r\n                                    else:\r\n                                        #Peer Dead Try From Others.\r\n                                        print(\"No Response from\", peer[0])\r\n                                        pass\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                            pass\r\n                    else:\r\n                        # We have the signatures number procede to make block and share.\r\n                        print(f\"Signature {transaction} ready to be made block.\")\r\n                        # Bytes\r\n                        lastBlock = self.getLastBlock()\r\n                        # print(lastBlock)\r\n                        lastBlock: Block\r\n                        print(f\"Last Block Index :{lastBlock.index}\")\r\n                        newBlock = Block(lastBlock.index + 1, transaction.transaction, str(time.time()),\r\n                                         lastBlock.computeHash(), transaction.signatures)\r\n                        newBlock.hash = newBlock.computeHash()\r\n                        self.unconfirmed_transactions.remove(transaction)\r\n                        self.saveUnconfirmedTransactions()\r\n                        self.saveBlock(newBlock)\r\n                        self.chain.append(newBlock)\r\n                sleep(30)\r\n\r\n    def getLastBlock(self) -> Block:\r\n        lastBlockIndex = self.chain[0].index\r\n        # Find last Block and return it\r\n        lastBlock = self.chain[0]\r\n        for block in self.chain:\r\n            # print(block.index)\r\n            if block.index > lastBlockIndex:\r\n                lastBlock = block\r\n                lastBlockIndex = block.index\r\n        return lastBlock\r\n\r\n    def getLastBlockIndex(self):\r\n        if len(self.chain) == 0:\r\n            return -1\r\n        else:\r\n            lastBlockIndex = self.chain[0].index\r\n            # Find last Block and return it\r\n            lastBlock = self.chain[0]\r\n            for block in self.chain:\r\n                # print(block.index)\r\n                if block.index > lastBlockIndex:\r\n                    lastBlock = block\r\n                    lastBlockIndex = block.index\r\n            return lastBlock.index\r\n\r\n    def saveUnconfirmedTransactions(self):\r\n        # print(self.TRANSACTION_PATH)\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Blockchain Folder\")\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n        json_file = open(self.TRANSACTION_PATH + \"Transactions\" + \".json\", \"w\")\r\n        json_file.write((json.dumps([ob.__dict__ for ob in self.unconfirmed_transactions])))\r\n        json_file.close()\r\n\r\n    def isUserAllowed(self, ip):\r\n        for block in self.chain:\r\n            block: Block\r\n            transaction = json.loads(block.transaction)\r\n            # From Create Genesis Block\r\n            if transaction[\"type\"] == 0:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n            # From Invite\r\n            if transaction[\"type\"] == 1:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n        # Didndt find user\r\n        return False\r\n\r\n    def getOwner(self):\r\n        for block in self.chain:\r\n            transaction = json.loads(block.transaction)\r\n            if transaction[\"type\"] == 0:\r\n                return transaction[\"ip\"]\r\n\r\n    def parseBlockchain(self):\r\n        \"\"\"\r\n        Parses Blockchain and returns 5 list of user types.\r\n        Peers that are in the blockchain and allowed.\r\n        Banned peers, Invites ,Admins and, Owner . All are lists.\r\n        \"\"\"\r\n        peers = []\r\n        bans = []\r\n        admins = []\r\n        invites = []\r\n        owner = []\r\n\r\n        for block in self.chain:\r\n            transaction = json.loads(block.transaction)\r\n            #GenesisTransactio\r\n            if transaction[\"type\"] == 0:\r\n                owner.append(transaction[\"ip\"])\r\n                admins.append(transaction[\"ip\"])\r\n                peers.append(transaction[\"ip\"])\r\n\r\n            #InviteTransaction\r\n            elif transaction[\"type\"] == 1:\r\n                invites.append(transaction[\"ip\"])\r\n\r\n            #JoinTransaction\r\n            elif transaction[\"type\"] == 2:\r\n                peers.append(transaction[\"ip\"])\r\n                invites.remove(transaction[\"ip\"])\r\n\r\n            #BanTransaction\r\n            elif transaction[\"type\"] == 3:\r\n                peers.remove(transaction[\"ip\"])\r\n                bans.append(transaction[\"ip\"])\r\n\r\n            # UnbanTransaction\r\n            elif transaction[\"type\"] == 4:\r\n                bans.remove(transaction[\"ip\"])\r\n\r\n                # AddAdminTransaction\r\n            elif transaction[\"type\"] == 5:\r\n                admins.append(transaction[\"ip\"])\r\n\r\n            # RemoveAdminTransaction\r\n            elif transaction[\"type\"] == 6:\r\n                admins.remove(transaction[\"ip\"])\r\n\r\n        # print(f\"Peers:{peers},Bans:{bans},Admins:{admins},Owners:{owner}\")\r\n        return peers, bans, admins, owner\r\n\r\n\r\nimport Networking\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/Blockchain.py b/Blockchain.py
---- a/Blockchain.py	(revision 6318741464290219269f85647dad53f456eab1ec)
-+++ b/Blockchain.py	(date 1650893215148)
-@@ -429,8 +429,12 @@
- 
-         for block in self.chain:
-             transaction = json.loads(block.transaction)
-+            print(peers,invites)
-+            print(transaction)
-+
-             #GenesisTransactio
-             if transaction["type"] == 0:
-+
-                 owner.append(transaction["ip"])
-                 admins.append(transaction["ip"])
-                 peers.append(transaction["ip"])
Index: .idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_41_AM__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_41_AM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_41_AM__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_41_AM__Changes_.xml	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_24-Apr-22_9_41_AM_[Changes]" date="1650782524032" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_41_AM_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 24-Apr-22 9:41 AM [Changes]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_14_AM__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_14_AM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_14_AM__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_14_AM__Changes_.xml	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_24-Apr-22_10_14_AM_[Changes]" date="1650784490377" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_14_AM_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 24-Apr-22 10:14 AM [Changes]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_26-Apr-22_1_06_PM__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_26-Apr-22_1_06_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_26-Apr-22_1_06_PM__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_26-Apr-22_1_06_PM__Changes_.xml	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_26-Apr-22_1_06_PM_[Changes]" date="1650967614315" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_26-Apr-22_1_06_PM_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 26-Apr-22 1:06 PM [Changes]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_4_03_PM_[Changes]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_4_03_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_4_03_PM_[Changes]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_4_03_PM_[Changes]/shelved.patch	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,261 +0,0 @@
-Index: Blockchain.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import os\r\nimport json\r\nfrom os import listdir\r\nimport rsa\r\nimport time\r\nfrom time import sleep\r\nimport threading\r\nfrom hashlib import sha256\r\nimport copy\r\nfrom pickle import dumps, loads\r\n\r\n\r\nclass Block:\r\n    def __init__(self, index, transaction, timestamp, previous_hash, signatures):\r\n        self.index = index\r\n\r\n        self.transaction = transaction\r\n\r\n        self.timestamp = timestamp\r\n\r\n        self.previous_hash = previous_hash\r\n\r\n        self.signatures = signatures\r\n\r\n    def compute_hash(self):\r\n        mycopy = copy.copy(self)\r\n        del mycopy.signatures\r\n        # print(mycopy.__dict__)\r\n        if hasattr(mycopy, 'hash'):\r\n            del mycopy.hash\r\n        block_string = json.dumps(mycopy.__dict__, sort_keys=True)\r\n        return sha256(block_string.encode()).hexdigest()\r\n\r\n\r\nclass UnconfirmedTransaction:\r\n    def __init__(self, transaction, signatures=[]):\r\n        self.transaction = transaction\r\n        self.signatures = signatures\r\n\r\n\r\nclass GenesisTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 0\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass InviteTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 1\r\n        self.ip = ip\r\n\r\n\r\nclass Blockchain:\r\n    def __init__(self, path, groupPeers, groupId):\r\n        self.BLOCKCHAIN_PATH = path\r\n        self.TRANSACTION_PATH = self.BLOCKCHAIN_PATH + \"\\\\Transactions\\\\\"\r\n        self.unconfirmed_transactions = []\r\n        self.chain = []\r\n        self.peers = groupPeers\r\n        self.groupId = groupId\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n            # Load Unconfirmed Transactions\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n\r\n        self.loadTransactions()\r\n\r\n        # print(self.unconfirmed_transactions)\r\n        # Load Blocks here\r\n        blockFiles = [f for f in listdir(self.BLOCKCHAIN_PATH) if os.path.isfile(os.path.join(self.BLOCKCHAIN_PATH, f))]\r\n        for blockFile in blockFiles:\r\n            self.loadBlock(blockFile)\r\n\r\n        # Start Casual Operations.\r\n        # Thread This.\r\n        miner = threading.Thread(target=self.mine, args=[])\r\n        miner.start()\r\n        # print(self.unconfirmed_transactions)\r\n        # for block in self.chain:\r\n        #     print(block)\r\n\r\n    def getDifficulty(self):\r\n        # Diffuculty of blockchain will be dependent on the users participating\r\n        # TODO refactor this for join ban unban\r\n        if len(self.peers) == 0:\r\n            return 1\r\n        else:\r\n            return len(self.peers)\r\n\r\n    def create_genesis_block(self, client):\r\n        transaction = GenesisTransaction(client.publicIP, client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        # this is string json format\r\n        # print(transactionStr)\r\n        # print(transactionStr.__class__)\r\n        # Genereate signature for Transaction\r\n\r\n        signature = rsa.sign(transactionStr.encode(), client.privateKey, 'SHA-1')\r\n\r\n        # Bytes\r\n        # print(signature)\r\n        # print(signature.__class__)\r\n\r\n        genesis_block = Block(0, transactionStr, str(time.time()), \"0\", [str(signature)])\r\n        genesis_block.hash = genesis_block.compute_hash()\r\n        self.saveBlock(genesis_block)\r\n        self.chain.append(genesis_block)\r\n\r\n    def saveBlock(self, block):\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Creating Blockchain Folder\")\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n        blockFile = open(self.BLOCKCHAIN_PATH + \"\\\\Block\" + str(block.index) + \".json\", \"w\")\r\n        # print(block.__dict__)\r\n        blockFile.write(json.dumps(block.__dict__))\r\n        blockFile.close()\r\n\r\n    def loadTransactions(self):\r\n        filePath = self.TRANSACTION_PATH + \"Transactions.json\"\r\n        if os.path.exists(filePath):\r\n            try:\r\n                file = open(filePath)\r\n                # print(file)\r\n                json_load_group = json.load(file)\r\n                file.close()\r\n            except Exception as e:\r\n                print(\"Error Opening Transaction file :\", e)\r\n            for x in json_load_group:\r\n                transaction = UnconfirmedTransaction(x[\"transaction\"], x[\"signatures\"])\r\n                # print(transaction)\r\n                self.unconfirmed_transactions.append(transaction)\r\n            # print(self.unconfirmed_transactions)\r\n\r\n    def loadBlock(self, blockFiles):\r\n        # print(blockFiles)\r\n        filePath = self.BLOCKCHAIN_PATH + \"\\\\\" + blockFiles\r\n        file = open(filePath)\r\n        # print(file)\r\n        block = json.load(file)\r\n        file.close()\r\n        # # print(block)\r\n        # transaction = json.loads(block[\"transaction\"])\r\n        # # print(transaction)\r\n        # # print(transaction.__class__)\r\n        # # Make transaction here\r\n        # if transaction[\"type\"] == 0:\r\n        #     # print(\"Genesis block\")\r\n        #     transactionObj = GenesisTransaction(transaction[\"ip\"], transaction[\"publicKey\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        blockObj = Block(block[\"index\"], block[\"transaction\"], block[\"timestamp\"], block[\"previous_hash\"],\r\n                         block[\"signatures\"])\r\n        blockObj.hash = block[\"hash\"]\r\n        # TODO Add all transactions here\r\n\r\n        # elif transaction[\"type\"] == 1:\r\n        #     # print(\"Genesis block\")\r\n        #     # print(transaction)\r\n        #     transactionObj = InviteTransaction(transaction[\"ip\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        #     blockObj = Block(block[\"index\"], transactionStr, block[\"timestamp\"], block[\"previous_hash\"],\r\n        #                      block[\"signatures\"])\r\n        #     blockObj.hash = block[\"hash\"]\r\n\r\n        self.chain.append(blockObj)\r\n        # print(blockObj.__dict__)\r\n\r\n    def add_new_transaction(self, transaction: str):\r\n        newUnconfirmedTransaction = UnconfirmedTransaction(transaction)\r\n        self.unconfirmed_transactions.append(newUnconfirmedTransaction)\r\n        self.save_unconfirmed_transactions()\r\n\r\n    def updateBlockchain(self):\r\n        for peer in self.peers:\r\n            # For each peer ask their max index of blockchain\r\n            updateBlockchainReq = Networking.UpdateBlockchainRequest(self.groupId)\r\n            res = Networking.sendRequest(peer[0], 6700, dumps(updateBlockchainReq))\r\n            if res is not False:\r\n                # if the response is bigger than me ask him for his block until we are at the same.\r\n                if res.answer > self.getLastBlockIndex():\r\n                    print(self.getLastBlockIndex().__class__, res.answer.__class__)\r\n                    while self.getLastBlockIndex() < res.answer:\r\n\r\n                        # Get block\r\n                        getBlockReq = Networking.GetBlockRequest(self.groupId, self.getLastBlockIndex() + 1)\r\n                        blockRes = Networking.sendRequest(peer[0], 6700, dumps(getBlockReq))\r\n                        if blockRes is not False:\r\n                            print(f\"Update BC Response:{blockRes}\")\r\n                            print(blockRes.answer)\r\n                            block = blockRes.answer\r\n                            block: Block\r\n                            print(block.index, block.transaction, block.signatures, block.timestamp,\r\n                                  block.previous_hash, block.hash)\r\n                            newBlock = Block(block.index, block.transaction, block.timestamp, block.previous_hash,\r\n                                  block.signatures)\r\n                            newBlock.hash = block.hash\r\n                            print(newBlock)\r\n                            # Save Block\r\n                            # Append to blockchain\r\n                        else:\r\n                            break\r\n\r\n    def getBlockWithIndex(self, index):\r\n        for block in self.chain:\r\n            block: Block\r\n            if block.index == index:\r\n                return block\r\n        return False\r\n\r\n    def mine(self):\r\n        # Load my public key.\r\n        keyLoc = self.BLOCKCHAIN_PATH + \"\\\\..\\\\..\\\\..\\\\PRIVATEKEY.json\"\r\n        # print(f\"key location = {keyLoc}\")\r\n        f = open(keyLoc, \"rb\")\r\n        data = f.read()\r\n        privateKey = rsa.PrivateKey.load_pkcs1(data)\r\n        # print(publicKey)\r\n        f.close()\r\n        while True:\r\n            # Update Blockchain.\r\n            self.updateBlockchain()\r\n\r\n            if not self.unconfirmed_transactions:\r\n                # If No Transaction sleep and check again soon.\r\n                sleep(30)\r\n            else:\r\n                diff = self.getDifficulty()\r\n                print(f\"Blockchain Difficulty :{diff}\")\r\n                print(f\"Unconfirmed Transactions:{len(self.unconfirmed_transactions)}\")\r\n                for transaction in self.unconfirmed_transactions:\r\n                    transaction: UnconfirmedTransaction\r\n                    # For Each Transaction if signatures < difficulty collect transactions\r\n                    if diff > len(transaction.signatures):\r\n                        if not len(transaction.signatures):\r\n                            # No Signatures add my signature\r\n                            signature = rsa.sign(transaction.transaction.encode(), privateKey, 'SHA-1')\r\n                            transaction.signatures.append(str(signature))\r\n                            self.save_unconfirmed_transactions()\r\n                        else:\r\n                            # Get Signatures from other persons.\r\n                            pass\r\n                    else:\r\n                        # We have the signatures number procede to make block and share.\r\n                        print(f\"Signature {transaction} ready to be made block.\")\r\n                        # Bytes\r\n                        lastBlock = self.getLastBlock()\r\n                        print(lastBlock)\r\n                        lastBlock: Block\r\n                        print(f\"Last Block Index :{lastBlock.index}\")\r\n                        newBlock = Block(lastBlock.index + 1, transaction.transaction, str(time.time()),\r\n                                         lastBlock.compute_hash(), transaction.signatures)\r\n                        newBlock.hash = newBlock.compute_hash()\r\n                        self.unconfirmed_transactions.remove(transaction)\r\n                        self.save_unconfirmed_transactions()\r\n                        self.saveBlock(newBlock)\r\n                        self.chain.append(newBlock)\r\n                sleep(30)\r\n\r\n    def getLastBlock(self):\r\n        lastBlockIndex = self.chain[0].index\r\n        # Find last Block and return it\r\n        lastBlock = self.chain[0]\r\n        for block in self.chain:\r\n            # print(block.index)\r\n            if block.index > lastBlockIndex:\r\n                lastBlock = block\r\n                lastBlockIndex = block.index\r\n        return lastBlock\r\n\r\n    def getLastBlockIndex(self):\r\n        if len(self.chain) == 0:\r\n            return -1\r\n        else:\r\n            lastBlockIndex = self.chain[0].index\r\n            # Find last Block and return it\r\n            lastBlock = self.chain[0]\r\n            for block in self.chain:\r\n                # print(block.index)\r\n                if block.index > lastBlockIndex:\r\n                    lastBlock = block\r\n                    lastBlockIndex = block.index\r\n            return lastBlock.index\r\n\r\n    def save_unconfirmed_transactions(self):\r\n        # print(self.TRANSACTION_PATH)\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Blockchain Folder\")\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n        json_file = open(self.TRANSACTION_PATH + \"Transactions\" + \".json\", \"w\")\r\n        json_file.write((json.dumps([ob.__dict__ for ob in self.unconfirmed_transactions])))\r\n        json_file.close()\r\n\r\n    def isUserAllowed(self, ip):\r\n        for block in self.chain:\r\n            block: Block\r\n            transaction = json.loads(block.transaction)\r\n            # From Create Genesis Block\r\n            if transaction[\"type\"] == 0:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n            # From Invite\r\n            if transaction[\"type\"] == 1:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n        # Didndt find user\r\n        return False\r\n\r\n\r\nimport Networking\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/Blockchain.py b/Blockchain.py
---- a/Blockchain.py	(revision 9bbfdef33dc53e171c51c996b292dedf27dd481f)
-+++ b/Blockchain.py	(date 1650545735854)
-@@ -22,7 +22,7 @@
- 
-         self.signatures = signatures
- 
--    def compute_hash(self):
-+    def computeHash(self):
-         mycopy = copy.copy(self)
-         del mycopy.signatures
-         # print(mycopy.__dict__)
-@@ -92,7 +92,7 @@
-         else:
-             return len(self.peers)
- 
--    def create_genesis_block(self, client):
-+    def createGenesisBlock(self, client):
-         transaction = GenesisTransaction(client.publicIP, client.publicKey.save_pkcs1(format='PEM').decode("utf-8"))
-         transactionStr = json.dumps(transaction.__dict__)
-         # this is string json format
-@@ -107,7 +107,7 @@
-         # print(signature.__class__)
- 
-         genesis_block = Block(0, transactionStr, str(time.time()), "0", [str(signature)])
--        genesis_block.hash = genesis_block.compute_hash()
-+        genesis_block.hash = genesis_block.computeHash()
-         self.saveBlock(genesis_block)
-         self.chain.append(genesis_block)
- 
-@@ -170,10 +170,10 @@
-         self.chain.append(blockObj)
-         # print(blockObj.__dict__)
- 
--    def add_new_transaction(self, transaction: str):
-+    def addNewTransaction(self, transaction: str):
-         newUnconfirmedTransaction = UnconfirmedTransaction(transaction)
-         self.unconfirmed_transactions.append(newUnconfirmedTransaction)
--        self.save_unconfirmed_transactions()
-+        self.saveUnconfirmedTransactions()
- 
-     def updateBlockchain(self):
-         for peer in self.peers:
-@@ -199,9 +199,9 @@
-                             newBlock = Block(block.index, block.transaction, block.timestamp, block.previous_hash,
-                                   block.signatures)
-                             newBlock.hash = block.hash
--                            print(newBlock)
--                            # Save Block
--                            # Append to blockchain
-+                            if self.validateNewBlock(newBlock):
-+                                self.saveBlock(newBlock)
-+                                self.chain.append(newBlock)
-                         else:
-                             break
- 
-@@ -212,6 +212,24 @@
-                 return block
-         return False
- 
-+    def validateNewBlock(self,newBlock):
-+        """This function is for new blocks that come from peers returns true if blocks checks out."""
-+        newBlock : Block
-+
-+
-+        if newBlock.index ==0:
-+            # Validation for genesis blocks
-+            transactionStr = newBlock.transaction
-+            transactionJSON = json.loads(transactionStr)
-+            print(transactionJSON)
-+            #Load Transaction
-+
-+
-+        else:
-+            #Validation for everything else
-+            pass
-+
-+
-     def mine(self):
-         # Load my public key.
-         keyLoc = self.BLOCKCHAIN_PATH + "\\..\\..\\..\\PRIVATEKEY.json"
-@@ -240,7 +258,7 @@
-                             # No Signatures add my signature
-                             signature = rsa.sign(transaction.transaction.encode(), privateKey, 'SHA-1')
-                             transaction.signatures.append(str(signature))
--                            self.save_unconfirmed_transactions()
-+                            self.saveUnconfirmedTransactions()
-                         else:
-                             # Get Signatures from other persons.
-                             pass
-@@ -253,10 +271,10 @@
-                         lastBlock: Block
-                         print(f"Last Block Index :{lastBlock.index}")
-                         newBlock = Block(lastBlock.index + 1, transaction.transaction, str(time.time()),
--                                         lastBlock.compute_hash(), transaction.signatures)
--                        newBlock.hash = newBlock.compute_hash()
-+                                         lastBlock.computeHash(), transaction.signatures)
-+                        newBlock.hash = newBlock.computeHash()
-                         self.unconfirmed_transactions.remove(transaction)
--                        self.save_unconfirmed_transactions()
-+                        self.saveUnconfirmedTransactions()
-                         self.saveBlock(newBlock)
-                         self.chain.append(newBlock)
-                 sleep(30)
-@@ -286,7 +304,7 @@
-                     lastBlockIndex = block.index
-             return lastBlock.index
- 
--    def save_unconfirmed_transactions(self):
-+    def saveUnconfirmedTransactions(self):
-         # print(self.TRANSACTION_PATH)
-         if not os.path.exists(self.TRANSACTION_PATH):
-             # Create a new directory because it does not exist
-Index: main.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import json\r\nimport logging\r\nimport threading\r\nfrom pickle import dumps, loads\r\nfrom flask import Flask, render_template, request, redirect\r\n\r\nimport Blockchain\r\nimport Compress\r\nfrom Networking import receiver, sendRequest, JoinRequest,SearchBundleRequest,receiveBundle,GetBundleRequest\r\nfrom Groups import GroupManager, Invite,Group\r\nfrom Client import Client\r\nimport easygui\r\nfrom Bundles import BundleManager\r\nfrom Downloads import DownloadManager\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = True\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    progress = downloadManager.getDownloadProgress()\r\n    return render_template(\"index.html\", groups=groupManager.groups,client=client,progress=progress)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    group = groupManager.getGroupWithName(group)\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    if downloadManager.STATUS:\r\n        downloadManager.STATUS = False\r\n        #downloadManager Off\r\n        print(\"Download Manager Not Active\")\r\n        return \"0\"\r\n    else:\r\n        downloadManager.STATUS = True\r\n        #downloadManager On\r\n        print(\"Download Manager Active\")\r\n        return \"1\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n        # TODO KEY SPECIFIC BLOCKCHAIN\r\n        ip = data[\"ip\"] #This is string\r\n        transaction = Blockchain.InviteTransaction(ip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.add_new_transaction(transactionStr)\r\n        # print(\"Generate Invite for :\", group)\r\n        # print(group)\r\n        invite = group.generateInvite()\r\n        return Compress.compress(invite.toJSON())\r\n\r\n@app.route('/deleteBundle', methods=['POST'])\r\ndef deleteBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupId = data[\"groupId\"]\r\n        bundleId = data[\"bundleId\"]\r\n        if groupManager.deleteBundle(groupId,bundleId):\r\n            return \"1\"\r\n        else:\r\n            return \"0\"\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        inviteDecomp = Compress.decompress(invite)\r\n        inviteLoad = json.loads(inviteDecomp)\r\n        invite = Invite(inviteLoad[\"id\"],inviteLoad[\"name\"], inviteLoad[\"timestamp\"], inviteLoad[\"peers\"])\r\n        joinReq = JoinRequest(invite.name, invite.timestamp)\r\n        print(invite.peers)\r\n        for peer in invite.peers:\r\n            print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq))\r\n            if res is not False:\r\n                group = res.group\r\n                group = Group(group.name,group.admins,group.peers,group.timestamp,blockchainPath=groupManager.DIR_PATH_GROUPS+group.name+\"\\\\Blockchain\")\r\n                groupManager.addGroup(group)\r\n        #Make thread to update blockhain and get up to date.\r\n        #TODO if fail do something.\r\n        return \"1\"\r\n\r\n\r\n@app.route('/shareBundle', methods=['POST'])\r\ndef shareBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"bundleName\"]\r\n        desc = data[\"bundleDescription\"]\r\n        groupName = data[\"groupName\"]\r\n        print(name)\r\n        print(desc)\r\n        print(groupName)\r\n        path = easygui.diropenbox(msg=\"Select folder to share as bundle\", title=\"Share Bundle\")\r\n        bundle = bundleManager.createBundle(name,desc,path=path)\r\n        groupManager.addBundle(bundle,groupName)\r\n        return \"0\"\r\n\r\n@app.route('/selectDownloadLocation', methods=['POST'])\r\ndef selectDownloadLocation():\r\n    if request.method == 'POST':\r\n        path = easygui.diropenbox(msg=\"Select folder to download bundles\", title=\"Select Bundle Download Location\")\r\n        print(path)\r\n        #Update Download Path in Config\r\n        client.DIR_PATH_DOWNLOADS=path\r\n        client.saveConfig()\r\n        #Return path to browser and update it in modal\r\n        return path\r\n\r\n@app.route('/searchBundles', methods=['POST'])\r\ndef searchBundles():\r\n    # print(\"Search Bundles Route\")\r\n    if request.method == 'POST':\r\n        data = request.form\r\n\r\n        #Get Keywords from search\r\n        keywords = data[\"searchKeyWords\"].split()\r\n        # print(\"Search for :\",keywords)\r\n\r\n        #Get Group\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n\r\n        searchReq = SearchBundleRequest(group.id,keywords)\r\n        responses = []\r\n        # SEND TO ALL PEERS COLLECT RESPONSES AND PRESENT\r\n        for peer in group.peers:\r\n            res = sendRequest(peer[0], 6700, dumps(searchReq))\r\n            #if other peer is responded.\r\n            if res is not False:\r\n                # print(res)\r\n                responses.append([peer[0],res])\r\n            else:\r\n                print(\"No Response from\",peer[0])\r\n        #Merge all responses to single list\r\n        # for x in responses:\r\n        #     print(\"Response:\",x[0],x[1],x[1].responseBundles)\r\n        #WITH RESPONSES DO STUFF.\r\n        #Respond\r\n        return render_template(\"search.html\", groups=groupManager.groups, group=group , responses = responses)\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n    if groupManager.createGroup(name, [client.publicIP]):\r\n        #Make First Block In Blockchain Append Admin\r\n        #Type 0 First Created\r\n        group = groupManager.getGroupWithName(name)\r\n        group.blockchain.create_genesis_block(client)\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n@app.route('/getBundle', methods=['POST'])\r\ndef getBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        bundleId = data[\"bundleId\"]\r\n        groupId = data[\"groupId\"]\r\n        userIp = data[\"userIp\"]\r\n        #TODO dynamic port on receiver for bundle\r\n        portForBundleReceiver = 6701\r\n        bundleReceiver = threading.Thread(target=receiveBundle, args=[portForBundleReceiver,client,groupManager,groupId,downloadManager])\r\n        bundleReceiver.start()\r\n        getBundleReq = GetBundleRequest(bundleId,groupId,portForBundleReceiver)\r\n        res = sendRequest(userIp, 6700, dumps(getBundleReq))\r\n        # if other peer is responded.\r\n        if res is not False:\r\n            #Responded decide what to do\r\n            pass\r\n        else:\r\n            # print(\"No Response from\", userIp)\r\n            pass\r\n    return \"1\"\r\n\r\n\r\n@app.route('/quitGroup', methods=['POST'])\r\ndef quitGroup():\r\n    # print('QUIT GROUP REQ')\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        if groupManager.quitGroup(group):\r\n            # True\r\n            return \"0\"\r\n        else:\r\n            # False\r\n            return \"1\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    groupManager = GroupManager()\r\n    bundleManager = BundleManager()\r\n    downloadManager = DownloadManager(groupManager,client)\r\n    #TODO Networking Thread To Receive From Internet\r\n    receiver = threading.Thread(target=receiver, args=[groupManager])\r\n    receiver.start()\r\n    app.run(host='', port=6969)\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/main.py b/main.py
---- a/main.py	(revision 9bbfdef33dc53e171c51c996b292dedf27dd481f)
-+++ b/main.py	(date 1650545818448)
-@@ -18,7 +18,7 @@
- # This Disables Logging
- app.logger.disabled = False
- log = logging.getLogger('werkzeug')
--log.disabled = True
-+log.disabled = False
- 
- 
- # Routes
-@@ -60,7 +60,7 @@
-         ip = data["ip"] #This is string
-         transaction = Blockchain.InviteTransaction(ip)
-         transactionStr = json.dumps(transaction.__dict__)
--        group.blockchain.add_new_transaction(transactionStr)
-+        group.blockchain.addNewTransaction(transactionStr)
-         # print("Generate Invite for :", group)
-         # print(group)
-         invite = group.generateInvite()
-@@ -167,7 +167,7 @@
-         #Make First Block In Blockchain Append Admin
-         #Type 0 First Created
-         group = groupManager.getGroupWithName(name)
--        group.blockchain.create_genesis_block(client)
-+        group.blockchain.createGenesisBlock(client)
-         # True
-         return "0"
-     else:
-Index: decap/files_small/crypt_and_hashing.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import rsa\r\n\r\n# https://stuvel.eu/python-rsa-doc/usage.html\r\npeer1pub, peer1prv = rsa.newkeys(512)\r\npeer2pub, peer2prv = rsa.newkeys(512)\r\npeer3pub, peer3prv = rsa.newkeys(512)\r\n\r\nmessage = \"Verify\".encode(\"utf8\")\r\n\r\ncrypto = rsa.encrypt(message, peer1pub)\r\nprint(crypto)\r\nmessage = rsa.decrypt(crypto, peer1prv)\r\nprint(message.decode('utf8'))\r\n\r\n\r\nhash = rsa.compute_hash(message, 'SHA-1')\r\n\r\npeer1signature = rsa.sign_hash(hash, peer1prv, 'SHA-1')\r\npeer2signature = rsa.sign_hash(hash, peer2prv, 'SHA-1')\r\npeer3signature = rsa.sign_hash(hash, peer3prv, 'SHA-1')\r\n\r\nprint(rsa.verify(message, peer1signature, peer1pub))\r\nprint(rsa.verify(message, peer2signature, peer2pub))\r\n#\r\n# message = 'Go right at the blue tree'.encode()\r\n# rsa.verify(message, signature, pubkey)\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/decap/files_small/crypt_and_hashing.py b/decap/files_small/crypt_and_hashing.py
---- a/decap/files_small/crypt_and_hashing.py	(revision 9bbfdef33dc53e171c51c996b292dedf27dd481f)
-+++ b/decap/files_small/crypt_and_hashing.py	(date 1650544946378)
-@@ -13,7 +13,7 @@
- print(message.decode('utf8'))
- 
- 
--hash = rsa.compute_hash(message, 'SHA-1')
-+hash = rsa.computeHash(message, 'SHA-1')
- 
- peer1signature = rsa.sign_hash(hash, peer1prv, 'SHA-1')
- peer2signature = rsa.sign_hash(hash, peer2prv, 'SHA-1')
-Index: decap/crypt_and_hashing.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import rsa\r\nimport base64\r\n# https://stuvel.eu/python-rsa-doc/usage.html\r\npeer1pub, peer1prv = rsa.newkeys(512)\r\npeer2pub, peer2prv = rsa.newkeys(512)\r\npeer3pub, peer3prv = rsa.newkeys(512)\r\n\r\nmessage = \"Verify\".encode(\"utf8\")\r\n\r\ncrypto = rsa.encrypt(message, peer1pub)\r\n# print(crypto)\r\nmessage = rsa.decrypt(crypto, peer1prv)\r\n# print(message.decode('utf8'))\r\n\r\n\r\nhash = rsa.compute_hash(message, 'SHA-1')\r\n\r\npeer1signature = rsa.sign_hash(hash, peer1prv, 'SHA-1')\r\npeer2signature = rsa.sign_hash(hash, peer2prv, 'SHA-1')\r\npeer3signature = rsa.sign_hash(hash, peer3prv, 'SHA-1')\r\nprint(peer3signature.encode())\r\n\r\n# print(rsa.verify(message, peer1signature, peer1pub))\r\n# print(rsa.verify(message, peer2signature, peer2pub))\r\n#\r\n# message = 'Go right at the blue tree'.encode()\r\n# rsa.verify(message, signature, pubkey)\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/decap/crypt_and_hashing.py b/decap/crypt_and_hashing.py
---- a/decap/crypt_and_hashing.py	(revision 9bbfdef33dc53e171c51c996b292dedf27dd481f)
-+++ b/decap/crypt_and_hashing.py	(date 1650544946351)
-@@ -13,7 +13,7 @@
- # print(message.decode('utf8'))
- 
- 
--hash = rsa.compute_hash(message, 'SHA-1')
-+hash = rsa.computeHash(message, 'SHA-1')
- 
- peer1signature = rsa.sign_hash(hash, peer1prv, 'SHA-1')
- peer2signature = rsa.sign_hash(hash, peer2prv, 'SHA-1')
-Index: decap/files_small/blockchain.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import time\r\nfrom hashlib import sha256\r\nimport json\r\n\r\n\r\nclass Block:\r\n    def __init__(self, index, transactions, timestamp, previous_hash, nonce=0):\r\n        self.index = index\r\n        self.transactions = transactions\r\n        self.timestamp = timestamp\r\n        self.previous_hash = previous_hash\r\n        self.nonce = nonce\r\n\r\n    def compute_hash(self):\r\n        block_string = json.dumps(self.__dict__, sort_keys=True)\r\n        return sha256(block_string.encode()).hexdigest()\r\n\r\nclass Blockchain:\r\n    difficulty = 6\r\n\r\n    def __init__(self):\r\n        self.unconfirmed_transactions = []\r\n        self.chain = []\r\n        self.create_genesis_block()\r\n\r\n    def create_genesis_block(self):\r\n        genesis_block = Block(0, [], time.time(), \"0\")\r\n        genesis_block.hash = genesis_block.compute_hash()\r\n        self.chain.append(genesis_block)\r\n\r\n    @property\r\n    def last_block(self):\r\n        return self.chain[-1]\r\n\r\n    def proof_of_work(self, block):\r\n        block.nonce = 0\r\n        computed_hash = block.compute_hash()\r\n        print(\"Starting Mining\")\r\n        while not computed_hash.startswith('0' * Blockchain.difficulty):\r\n            block.nonce += 1\r\n            computed_hash = block.compute_hash()\r\n        print(\"Mining Ended Nonce :\", block.nonce)\r\n        return computed_hash\r\n\r\n    def add_block(self, block, proof):\r\n        previous_hash = self.last_block.hash\r\n        if previous_hash != block.previous_hash:\r\n            return False\r\n        if not self.is_valid_proof(block, proof):\r\n            return False\r\n        block.hash = proof\r\n        self.chain.append(block)\r\n        return True\r\n\r\n    def is_valid_proof(self, block, block_hash):\r\n        return (block_hash.startswith('0' * Blockchain.difficulty) and\r\n                block_hash == block.compute_hash())\r\n\r\n    def add_new_transaction(self, transaction):\r\n        self.unconfirmed_transactions.append(transaction)\r\n\r\n    def mine(self):\r\n        if not self.unconfirmed_transactions:\r\n            return False\r\n\r\n        last_block = self.last_block\r\n\r\n        new_block = Block(index=last_block.index + 1,\r\n                          transactions=self.unconfirmed_transactions,\r\n                          timestamp=time.time(),\r\n                          previous_hash=last_block.hash)\r\n\r\n        proof = self.proof_of_work(new_block)\r\n        self.add_block(new_block, proof)\r\n        self.unconfirmed_transactions = []\r\n        return new_block.index\r\n\r\n\r\nif __name__ == '__main__':\r\n    blockchain = Blockchain()\r\n    blockchain.add_new_transaction(\"A INVITED 8.8.8.8\")\r\n    blockchain.add_new_transaction(\"8.8.8.8 Joined\")\r\n    mine_response = blockchain.mine()\r\n    print(mine_response)\r\n    print(blockchain.last_block.transactions)\r\n    blockchain.add_new_transaction(\"8.8.8.8 Joined\")\r\n    blockchain.add_new_transaction(\"8.8.8.8 Shared File asdasdasdasd\")\r\n    mine_response = blockchain.mine()\r\n    print(mine_response)\r\n    print(blockchain.last_block.transactions)\r\n    blockchain.add_new_transaction(\"B ivited 1.1.1.1\")\r\n    blockchain.add_new_transaction(\"8.8.8.8 Joined\")\r\n    blockchain.add_new_transaction(\"8.8.8.8 Joined\")\r\n    mine_response = blockchain.mine()\r\n    print(mine_response)\r\n    print(blockchain.last_block.transactions)\r\n    blockchain.add_new_transaction(\"8.8.8.8 Joined\")\r\n    blockchain.add_new_transaction(\"8.8.8.8 Joined\")\r\n    mine_response = blockchain.mine()\r\n    print(mine_response)\r\n    print(blockchain.last_block.transactions)\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/decap/files_small/blockchain.py b/decap/files_small/blockchain.py
---- a/decap/files_small/blockchain.py	(revision 9bbfdef33dc53e171c51c996b292dedf27dd481f)
-+++ b/decap/files_small/blockchain.py	(date 1650544946365)
-@@ -34,11 +34,11 @@
- 
-     def proof_of_work(self, block):
-         block.nonce = 0
--        computed_hash = block.compute_hash()
-+        computed_hash = block.computeHash()
-         print("Starting Mining")
-         while not computed_hash.startswith('0' * Blockchain.difficulty):
-             block.nonce += 1
--            computed_hash = block.compute_hash()
-+            computed_hash = block.computeHash()
-         print("Mining Ended Nonce :", block.nonce)
-         return computed_hash
- 
-@@ -54,7 +54,7 @@
- 
-     def is_valid_proof(self, block, block_hash):
-         return (block_hash.startswith('0' * Blockchain.difficulty) and
--                block_hash == block.compute_hash())
-+                block_hash == block.computeHash())
- 
-     def add_new_transaction(self, transaction):
-         self.unconfirmed_transactions.append(transaction)
-Index: decap/blockchain.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import time\r\nfrom hashlib import sha256\r\nimport json\r\n\r\n\r\nclass Block:\r\n    def __init__(self, index, transactions, timestamp, previous_hash, nonce=0):\r\n        self.index = index\r\n        self.transactions = transactions\r\n        self.timestamp = timestamp\r\n        self.previous_hash = previous_hash\r\n        self.nonce = nonce\r\n\r\n    def compute_hash(self):\r\n        block_string = json.dumps(self.__dict__, sort_keys=True)\r\n        return sha256(block_string.encode()).hexdigest()\r\n\r\nclass Blockchain:\r\n    difficulty = 5\r\n\r\n    def __init__(self):\r\n        self.unconfirmed_transactions = []\r\n        self.chain = []\r\n        self.create_genesis_block()\r\n\r\n    def create_genesis_block(self):\r\n        genesis_block = Block(0, [], time.time(), \"0\")\r\n        genesis_block.hash = genesis_block.compute_hash()\r\n        self.chain.append(genesis_block)\r\n\r\n    @property\r\n    def last_block(self):\r\n        return self.chain[-1]\r\n\r\n    def proof_of_work(self, block):\r\n        block.nonce = 0\r\n        computed_hash = block.compute_hash()\r\n        print(\"Starting Mining\")\r\n        while not computed_hash.startswith('0' * Blockchain.difficulty):\r\n            block.nonce += 1\r\n            computed_hash = block.compute_hash()\r\n        print(\"Mining Ended Nonce :\", block.nonce)\r\n        return computed_hash\r\n\r\n    def add_block(self, block, proof):\r\n        previous_hash = self.last_block.hash\r\n        if previous_hash != block.previous_hash:\r\n            return False\r\n        if not self.is_valid_proof(block, proof):\r\n            return False\r\n        block.hash = proof\r\n        self.chain.append(block)\r\n        return True\r\n\r\n    def is_valid_proof(self, block, block_hash):\r\n        return (block_hash.startswith('0' * Blockchain.difficulty) and\r\n                block_hash == block.compute_hash())\r\n\r\n    def add_new_transaction(self, transaction):\r\n        self.unconfirmed_transactions.append(transaction)\r\n\r\n    def mine(self):\r\n        if not self.unconfirmed_transactions:\r\n            return False\r\n\r\n        last_block = self.last_block\r\n\r\n        new_block = Block(index=last_block.index + 1,\r\n                          transactions=self.unconfirmed_transactions,\r\n                          timestamp=time.time(),\r\n                          previous_hash=last_block.hash)\r\n\r\n        proof = self.proof_of_work(new_block)\r\n        self.add_block(new_block, proof)\r\n        self.unconfirmed_transactions = []\r\n        return new_block.index\r\n\r\n\r\nif __name__ == '__main__':\r\n    blockchain = Blockchain()\r\n    blockchain.add_new_transaction(\"A INVITED 8.8.8.8\")\r\n    blockchain.add_new_transaction(\"8.8.8.8 Joined\")\r\n    mine_response = blockchain.mine()\r\n    print(mine_response)\r\n    print(blockchain.last_block.transactions)\r\n    blockchain.add_new_transaction(\"8.8.8.8 Joined\")\r\n    blockchain.add_new_transaction(\"8.8.8.8 Shared File asdasdasdasd\")\r\n    mine_response = blockchain.mine()\r\n    print(mine_response)\r\n    print(blockchain.last_block.transactions)\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/decap/blockchain.py b/decap/blockchain.py
---- a/decap/blockchain.py	(revision 9bbfdef33dc53e171c51c996b292dedf27dd481f)
-+++ b/decap/blockchain.py	(date 1650544946339)
-@@ -34,11 +34,11 @@
- 
-     def proof_of_work(self, block):
-         block.nonce = 0
--        computed_hash = block.compute_hash()
-+        computed_hash = block.computeHash()
-         print("Starting Mining")
-         while not computed_hash.startswith('0' * Blockchain.difficulty):
-             block.nonce += 1
--            computed_hash = block.compute_hash()
-+            computed_hash = block.computeHash()
-         print("Mining Ended Nonce :", block.nonce)
-         return computed_hash
- 
-@@ -54,7 +54,7 @@
- 
-     def is_valid_proof(self, block, block_hash):
-         return (block_hash.startswith('0' * Blockchain.difficulty) and
--                block_hash == block.compute_hash())
-+                block_hash == block.computeHash())
- 
-     def add_new_transaction(self, transaction):
-         self.unconfirmed_transactions.append(transaction)
Index: .idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_53_AM_[Changes]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_53_AM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_53_AM_[Changes]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_53_AM_[Changes]/shelved.patch	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,46 +0,0 @@
-Index: main.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import json\r\nimport logging\r\nimport threading\r\nfrom pickle import dumps, loads\r\nfrom flask import Flask, render_template, request, redirect\r\n\r\nimport Blockchain\r\nimport Compress\r\nfrom Networking import receiver, sendRequest, JoinRequest, SearchBundleRequest, receiveBundle, GetBundleRequest\r\nfrom Groups import GroupManager, Invite, Group\r\nfrom Client import Client\r\nimport easygui\r\nfrom Bundles import BundleManager\r\nfrom Downloads import DownloadManager\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = False\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    progress = downloadManager.getDownloadProgress()\r\n    return render_template(\"index.html\", groups=groupManager.groups, client=client, progress=progress)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    group = groupManager.getGroupWithName(group)\r\n    # Check if user should see admin panels.\r\n    peers, bans, admins, owner = group.blockchain.parseBlockchain()\r\n    # Check privs what to show on group page.\r\n    adminPriv = False\r\n    for admin in group.admins:\r\n        if admin[0] == client.publicIP:\r\n            adminPriv = True\r\n            admins.remove([client.publicIP])\r\n            peers.remove([client.publicIP])\r\n\r\n    ownerPriv = False\r\n    if group.blockchain.getOwner() == client.publicIP:\r\n        ownerPriv = True\r\n\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group, client=client, adminPriv=adminPriv,\r\n                           ownerPriv=ownerPriv, peers=peers, bans=bans, admins=admins)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    if downloadManager.STATUS:\r\n        downloadManager.STATUS = False\r\n        # downloadManager Off\r\n        print(\"Download Manager Not Active\")\r\n        return \"0\"\r\n    else:\r\n        downloadManager.STATUS = True\r\n        # downloadManager On\r\n        print(\"Download Manager Active\")\r\n        return \"1\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n        # TODO KEY SPECIFIC BLOCKCHAIN\r\n        ip = data[\"ip\"]  # This is string\r\n        transaction = Blockchain.InviteTransaction(ip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        # print(\"Generate Invite for :\", group)\r\n        # print(group)\r\n        invite = group.generateInvite()\r\n        return Compress.compress(invite.toJSON())\r\n\r\n\r\n@app.route('/deleteBundle', methods=['POST'])\r\ndef deleteBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupId = data[\"groupId\"]\r\n        bundleId = data[\"bundleId\"]\r\n        if groupManager.deleteBundle(groupId, bundleId):\r\n            return \"1\"\r\n        else:\r\n            return \"0\"\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        inviteDecomp = Compress.decompress(invite)\r\n        inviteLoad = json.loads(inviteDecomp)\r\n        invite = Invite(inviteLoad[\"id\"], inviteLoad[\"name\"], inviteLoad[\"timestamp\"], inviteLoad[\"peers\"])\r\n        joinReq = JoinRequest(invite.name, invite.timestamp)\r\n        print(invite.peers)\r\n        for peer in invite.peers:\r\n            print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq))\r\n            if res is not False:\r\n                # Response from user with group data.\r\n                group = res.group\r\n                group = Group(group.name, group.admins, group.peers, group.timestamp,\r\n                              blockchainPath=groupManager.DIR_PATH_GROUPS + group.name + \"\\\\Blockchain\", client=client)\r\n                groupManager.addGroup(group)\r\n                # Make Join Transaction.\r\n                transaction = Blockchain.JoinTransaction(client.publicIP,\r\n                                                         client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n                transactionStr = json.dumps(transaction.__dict__)\r\n                group.blockchain.addNewTransaction(transactionStr)\r\n                # transactionStr = json.dumps(transaction.__dict__)\r\n                # this is string json format\r\n                # print(transactionStr)\r\n                # print(transactionStr.__class__)\r\n                # Genereate signature for Transaction\r\n                # signature = rsa.sign(transactionStr.encode(), client.privateKey, 'SHA-1')\r\n                # genesis_block = Block(0, transactionStr, str(time.time()), \"0\", [str(signature)])\r\n                # genesis_block.hash = genesis_block.computeHash()\r\n                # self.saveBlock(genesis_block)\r\n                # self.chain.append(genesis_block)\r\n                return \"1\"\r\n        # No responses.\r\n        return \"0\"\r\n\r\n\r\n@app.route('/shareBundle', methods=['POST'])\r\ndef shareBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"bundleName\"]\r\n        desc = data[\"bundleDescription\"]\r\n        groupName = data[\"groupName\"]\r\n        print(name)\r\n        print(desc)\r\n        print(groupName)\r\n        path = easygui.diropenbox(msg=\"Select folder to share as bundle\", title=\"Share Bundle\")\r\n        bundle = bundleManager.createBundle(name, desc, path=path)\r\n        groupManager.addBundle(bundle, groupName)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/selectDownloadLocation', methods=['POST'])\r\ndef selectDownloadLocation():\r\n    if request.method == 'POST':\r\n        path = easygui.diropenbox(msg=\"Select folder to download bundles\", title=\"Select Bundle Download Location\")\r\n        print(path)\r\n        # Update Download Path in Config\r\n        client.DIR_PATH_DOWNLOADS = path\r\n        client.saveConfig()\r\n        # Return path to browser and update it in modal\r\n        return path\r\n\r\n\r\n@app.route('/searchBundles', methods=['POST'])\r\ndef searchBundles():\r\n    # print(\"Search Bundles Route\")\r\n    if request.method == 'POST':\r\n        data = request.form\r\n\r\n        # Get Keywords from search\r\n        keywords = data[\"searchKeyWords\"].split()\r\n        # print(\"Search for :\",keywords)\r\n\r\n        # Get Group\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n\r\n        searchReq = SearchBundleRequest(group.id, keywords)\r\n        responses = []\r\n        # SEND TO ALL PEERS COLLECT RESPONSES AND PRESENT\r\n        for peer in group.peers:\r\n            res = sendRequest(peer[0], 6700, dumps(searchReq))\r\n            # if other peer is responded.\r\n            if res is not False:\r\n                # print(res)\r\n                responses.append([peer[0], res])\r\n            else:\r\n                print(\"No Response from\", peer[0])\r\n        # Merge all responses to single list\r\n        # for x in responses:\r\n        #     print(\"Response:\",x[0],x[1],x[1].responseBundles)\r\n        # WITH RESPONSES DO STUFF.\r\n        # Respond\r\n        return render_template(\"search.html\", groups=groupManager.groups, group=group, responses=responses)\r\n\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n    if groupManager.createGroup(name, [client.publicIP]):\r\n        # Make First Block In Blockchain Append Admin\r\n        # Type 0 First Created\r\n        group = groupManager.getGroupWithName(name)\r\n        group.blockchain.createGenesisBlock(client)\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n\r\n@app.route('/getBundle', methods=['POST'])\r\ndef getBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        bundleId = data[\"bundleId\"]\r\n        groupId = data[\"groupId\"]\r\n        userIp = data[\"userIp\"]\r\n        # TODO dynamic port on receiver for bundle\r\n        portForBundleReceiver = 6701\r\n        bundleReceiver = threading.Thread(target=receiveBundle,\r\n                                          args=[portForBundleReceiver, client, groupManager, groupId, downloadManager])\r\n        bundleReceiver.start()\r\n        getBundleReq = GetBundleRequest(bundleId, groupId, portForBundleReceiver)\r\n        res = sendRequest(userIp, 6700, dumps(getBundleReq))\r\n        # if other peer is responded.\r\n        if res is not False:\r\n            # Responded decide what to do\r\n            pass\r\n        else:\r\n            # print(\"No Response from\", userIp)\r\n            pass\r\n    return \"1\"\r\n\r\n\r\n@app.route('/quitGroup', methods=['POST'])\r\ndef quitGroup():\r\n    # print('QUIT GROUP REQ')\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        if groupManager.quitGroup(group):\r\n            # True\r\n            return \"0\"\r\n        else:\r\n            # False\r\n            return \"1\"\r\n\r\n\r\n@app.route('/banUser', methods=['POST'])\r\ndef banUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.BanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/unbanUser', methods=['POST'])\r\ndef unbanUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.UnbanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/addAdmin', methods=['POST'])\r\ndef addAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.AddAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/removeAdmin', methods=['POST'])\r\ndef removeAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.RemoveAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    groupManager = GroupManager(client)\r\n    bundleManager = BundleManager()\r\n    downloadManager = DownloadManager(groupManager, client)\r\n    # TODO Networking Thread To Receive From Internet\r\n    receiver = threading.Thread(target=receiver, args=[groupManager])\r\n    receiver.start()\r\n    app.run(host='', port=6969)\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/main.py b/main.py
---- a/main.py	(revision aa5d56535dd16c161bafffe2e4dabf760c8bd003)
-+++ b/main.py	(date 1650781638122)
-@@ -118,16 +118,6 @@
-                                                          client.publicKey.save_pkcs1(format='PEM').decode("utf-8"))
-                 transactionStr = json.dumps(transaction.__dict__)
-                 group.blockchain.addNewTransaction(transactionStr)
--                # transactionStr = json.dumps(transaction.__dict__)
--                # this is string json format
--                # print(transactionStr)
--                # print(transactionStr.__class__)
--                # Genereate signature for Transaction
--                # signature = rsa.sign(transactionStr.encode(), client.privateKey, 'SHA-1')
--                # genesis_block = Block(0, transactionStr, str(time.time()), "0", [str(signature)])
--                # genesis_block.hash = genesis_block.computeHash()
--                # self.saveBlock(genesis_block)
--                # self.chain.append(genesis_block)
-                 return "1"
-         # No responses.
-         return "0"
-Index: static/assets/js/torrentApp.js
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>function start() {\r\n    const xhttp = new XMLHttpRequest();\r\n    xhttp.onload = function() {\r\n        if (this.responseText == \"1\"){\r\n        alert(\"Download Manager Active\");\r\n        }\r\n        else{\r\n        alert(\"Download Manager Not Active\");\r\n        }\r\n\r\n        }\r\n    xhttp.open(\"POST\", \"/start\", true);\r\n    xhttp.send();\r\n\r\n}\r\n\r\nfunction addGroup() {\r\n    var modal = document.getElementById(\"myModal\");\r\n    modal.style.display = \"block\";\r\n}\r\n\r\nfunction closeGroup() {\r\n    var modal = document.getElementById(\"myModal\");\r\n    modal.style.display = \"none\";\r\n}\r\n\r\nfunction createInvite() {\r\n    var modal = document.getElementById(\"createInviteModal\");\r\n    modal.style.display = \"block\";\r\n}\r\n\r\nfunction closeInvite() {\r\n    var modal = document.getElementById(\"createInviteModal\");\r\n    modal.style.display = \"none\";\r\n}\r\n\r\nfunction ValidateIp(ipaddress){\r\n if (/^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(ipaddress))\r\n  {\r\n    return (true)\r\n  }\r\nreturn (false)\r\n}\r\n\r\nfunction generateInvite(groupName) {\r\n    var ip = document.getElementById(\"ip\").value;\r\n    var inviteTextArea = document.getElementById(\"invite\");\r\n    if (ValidateIp(ip)==true){\r\n     $.ajax({\r\n                data: {group:groupName,ip:ip}\r\n                , type: 'post'\r\n                , url: '/generateInvite'\r\n                , success: function (response) {\r\n                    inviteTextArea.value=response;\r\n                }\r\n            });\r\n    }\r\n    else{\r\nalert(\"You have entered an invalid IP address!\")\r\n    }\r\n}\r\n\r\nfunction deleteBundle(bundleId,groupId) {\r\n    $.ajax({\r\n                data: {bundleId:bundleId, groupId:groupId}\r\n                , type: 'post'\r\n                , url: '/deleteBundle'\r\n                , success: function (response) {\r\n Swal.fire({\r\n                          title: \"Bundle Deleted!\",\r\n                            icon: 'success'\r\n                        }).then(function() {\r\n                        window.location.reload();\r\n                    });\r\n                }\r\n            });\r\n\r\n}\r\n\r\nfunction quitGroup(groupName) {\r\n    $.ajax({\r\n                data: {group:groupName}\r\n                , type: 'post'\r\n                , url: '/quitGroup'\r\n                , success: function (response) {\r\n                    if (response==0){\r\n                                    window.location.replace(\"/\");\r\n                                    }\r\n\r\n                }\r\n            });\r\n\r\n}\r\n\r\nfunction joinGroupModal() {\r\n    var modal = document.getElementById(\"joinGroupModal\");\r\n    modal.style.display = \"block\";\r\n}\r\n\r\nfunction openShareModal() {\r\n    var modal = document.getElementById(\"shareModal\");\r\n    modal.style.display = \"block\";\r\n}\r\n\r\nfunction openSettingsModal() {\r\n    var modal = document.getElementById(\"settingsModal\");\r\n    modal.style.display = \"block\";\r\n}\r\n\r\nfunction closeSettingsModal() {\r\n    var modal = document.getElementById(\"settingsModal\");\r\n    modal.style.display = \"none\";\r\n}\r\n\r\nfunction closeGroupModal() {\r\n    var modal = document.getElementById(\"joinGroupModal\");\r\n    modal.style.display = \"none\";\r\n}\r\n\r\nfunction closeShareBundle() {\r\n    var modal = document.getElementById(\"shareModal\");\r\n    modal.style.display = \"none\";\r\n}\r\n\r\nfunction joinGroup() {\r\n    var invite = document.getElementById(\"inviteHash\").value;\r\n    $.ajax({\r\n                data: {invite: invite}\r\n                , type: 'post'\r\n                , url: '/joinGroup'\r\n                , success: function (response) {\r\n                    if (response==\"1\"){\r\n                    window.location.replace(\"/groups?group=\"+name);\r\n                    }else{\r\n                    alert(\"No responses , try again later.\")\r\n                    }\r\n                }\r\n            });\r\n}\r\n\r\nfunction createGroup() {\r\n    var name = document.getElementById(\"name\").value;\r\n    $.ajax({\r\n                data: {name:name}\r\n                , type: 'post'\r\n                , url: '/createGroup'\r\n                , success: function (response) {\r\n                    if (response==0){\r\n                    window.location.replace(\"/groups?group=\"+name);\r\n                    }else{\r\n                    //TODO FAILED ALERT\r\n                    alert(\"Failed to Create Group\")\r\n                    }\r\n                }\r\n            });\r\n\r\n}\r\n\r\nfunction shareBundle(groupName) {\r\n    var bundleName = document.getElementById(\"bundleName\").value;\r\n    var bundleDescription = document.getElementById(\"bundleDescription\").value;\r\n    alert(\"Select Folder Window is opened.\");\r\n    $.ajax({\r\n                data: {\r\n                        bundleName:bundleName,\r\n                        bundleDescription:bundleDescription,\r\n                        groupName:groupName\r\n                      }\r\n                , type: 'post'\r\n                , url: '/shareBundle'\r\n                , success: function (response) {\r\n                    if (response==0){\r\n                    closeShareBundle();\r\n                        Swal.fire({\r\n                          title: \"Bundle Shared!\",\r\n                            icon: 'success'\r\n                        }).then(function() {\r\n                        window.location.reload();\r\n                    });\r\n\r\n                    }else{\r\n                    //TODO FAILED ALERT\r\n                    alert(\"Failed to Create Group\");\r\n                    }\r\n                }\r\n            });\r\n\r\n}\r\n\r\nfunction getBundle(bundleId,groupId,userIp) {\r\nalert(\"JS OK\");\r\n    $.ajax({\r\n                data: {\r\n                        bundleId:bundleId,\r\n                        groupId:groupId,\r\n                        userIp:userIp\r\n                      }\r\n                , type: 'post'\r\n                , url: '/getBundle'\r\n                , success: function (response) {\r\n                    if (response==0){\r\n                    alert(\"0\");\r\n                    }else{\r\n                    //TODO FAILED ALERT\r\n                  alert(\"not 0\");\r\n                    }\r\n                }\r\n            });\r\n\r\n}\r\n\r\nfunction selectDownloadLocation() {\r\n    var downloadLocationElement = document.getElementById(\"downloadLocation\");\r\n    alert(\"Select Folder Window is opened.\");\r\n    $.ajax({\r\n                data: {\r\n                      }\r\n                , type: 'post'\r\n                , url: '/selectDownloadLocation'\r\n                , success: function (response) {\r\n                    if (response==0){\r\n                    alert(\"0\");\r\n                    }else{\r\n                        downloadLocationElement.value = response;\r\n                    }\r\n                }\r\n            });\r\n\r\n}\r\n\r\nfunction banUser(groupId,userIp){\r\n//alert(\"ban from group\"+groupId+\" ,user :\"+userIp);\r\nSwal.fire({\r\n  title: 'Are you sure you want to ban '+userIp+' ?',\r\n  showCancelButton: true,\r\n  confirmButtonText: 'Confirm',\r\n}).then((result) => {\r\n  /* Read more about isConfirmed, isDenied below */\r\n  if (result.isConfirmed) {\r\n      $.ajax({\r\n                data: {\r\n                        group:groupId,\r\n                        userip:userIp\r\n                      }\r\n                , type: 'post'\r\n                , url: '/banUser'\r\n                , success: function (response) {\r\n                    if (response==0){\r\n                        Swal.fire('Success!', 'Change will appear shortly.', 'success');\r\n                    }else{\r\n                    //TODO FAILED ALERT\r\n                    alert(\"Failed\");\r\n                    }\r\n                }\r\n            });\r\n\r\n  }\r\n});\r\n}\r\n\r\nfunction unbanUser(groupId,userIp){\r\n//alert(\"unban from group\"+groupId+\" ,user :\"+userIp);\r\nSwal.fire({\r\n  title: 'Are you sure you want to unban '+userIp+' ?',\r\n  showCancelButton: true,\r\n  confirmButtonText: 'Confirm',\r\n}).then((result) => {\r\n  /* Read more about isConfirmed, isDenied below */\r\n  if (result.isConfirmed) {\r\n      $.ajax({\r\n                data: {\r\n                        group:groupId,\r\n                        userip:userIp\r\n                      }\r\n                , type: 'post'\r\n                , url: '/unbanUser'\r\n                , success: function (response) {\r\n                    if (response==0){\r\n                        Swal.fire('Success!', 'Change will appear shortly.', 'success');\r\n                    }else{\r\n                    //TODO FAILED ALERT\r\n                    alert(\"Failed\");\r\n                    }\r\n                }\r\n            });\r\n  }\r\n});\r\n}\r\n\r\nfunction addAdmin(groupId,userIp){\r\n//alert(\"addAdmin from group\"+groupId+\" ,user :\"+userIp);\r\nSwal.fire({\r\n  title: 'Are you sure you want to add  '+userIp+' as admin ?',\r\n  showCancelButton: true,\r\n  confirmButtonText: 'Confirm',\r\n}).then((result) => {\r\n  /* Read more about isConfirmed, isDenied below */\r\n  if (result.isConfirmed) {\r\n      $.ajax({\r\n                data: {\r\n                        group:groupId,\r\n                        userip:userIp\r\n                      }\r\n                , type: 'post'\r\n                , url: '/addAdmin'\r\n                , success: function (response) {\r\n                    if (response==0){\r\n                        Swal.fire('Success!', 'Change will appear shortly.', 'success');\r\n                    }else{\r\n                    //TODO FAILED ALERT\r\n                    alert(\"Failed\");\r\n                    }\r\n                }\r\n            });\r\n  }\r\n});\r\n}\r\n\r\nfunction removeAdmin(groupId,userIp){\r\n//alert(\"removeAdmin from group\"+groupId+\" ,user :\"+userIp);\r\nSwal.fire({\r\n  title: 'Are you sure you want to remove '+userIp+' from admins ?',\r\n  showCancelButton: true,\r\n  confirmButtonText: 'Confirm',\r\n}).then((result) => {\r\n  /* Read more about isConfirmed, isDenied below */\r\n  if (result.isConfirmed) {\r\n      $.ajax({\r\n                data: {\r\n                        group:groupId,\r\n                        userip:userIp\r\n                      }\r\n                , type: 'post'\r\n                , url: '/removeAdmin'\r\n                , success: function (response) {\r\n                    if (response==0){\r\n                        Swal.fire('Success!', 'Change will appear shortly.', 'success');\r\n                    }else{\r\n                    //TODO FAILED ALERT\r\n                    alert(\"Failed\");\r\n                    }\r\n                }\r\n            });\r\n  }\r\n});\r\n}
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/static/assets/js/torrentApp.js b/static/assets/js/torrentApp.js
---- a/static/assets/js/torrentApp.js	(revision aa5d56535dd16c161bafffe2e4dabf760c8bd003)
-+++ b/static/assets/js/torrentApp.js	(date 1650781680452)
-@@ -130,7 +130,7 @@
-                 , url: '/joinGroup'
-                 , success: function (response) {
-                     if (response=="1"){
--                    window.location.replace("/groups?group="+name);
-+                    window.location.reload()
-                     }else{
-                     alert("No responses , try again later.")
-                     }
Index: .idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_3_18_PM_[Changes]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_3_18_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_3_18_PM_[Changes]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_3_18_PM_[Changes]/shelved.patch	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,730 +0,0 @@
-Index: Blockchain.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import math\r\nimport os\r\nimport json\r\nfrom os import listdir\r\nimport rsa\r\nimport time\r\nfrom time import sleep\r\nimport threading\r\nfrom hashlib import sha256\r\nimport copy\r\nfrom pickle import dumps, loads\r\n\r\n\r\nclass Block:\r\n    def __init__(self, index, transaction, timestamp, previous_hash, signatures):\r\n        self.index = index\r\n\r\n        self.transaction = transaction\r\n\r\n        self.timestamp = timestamp\r\n\r\n        self.previous_hash = previous_hash\r\n\r\n        self.signatures = signatures\r\n\r\n    def computeHash(self):\r\n        mycopy = copy.copy(self)\r\n        del mycopy.signatures\r\n        # print(mycopy.__dict__)\r\n        if hasattr(mycopy, 'hash'):\r\n            del mycopy.hash\r\n        block_string = json.dumps(mycopy.__dict__, sort_keys=True)\r\n        return sha256(block_string.encode()).hexdigest()\r\n\r\n\r\nclass UnconfirmedTransaction:\r\n    def __init__(self, transaction, signatures=[]):\r\n        self.transaction = transaction\r\n        self.signatures = signatures\r\n\r\n\r\nclass GenesisTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 0\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass InviteTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 1\r\n        self.ip = ip\r\n\r\n\r\nclass JoinTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 2\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass BanTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 3\r\n        self.ip = ip\r\n\r\n\r\nclass UnbanTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 4\r\n        self.ip = ip\r\n\r\n\r\nclass AddAdminTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 5\r\n        self.ip = ip\r\n\r\n\r\nclass RemoveAdminTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 6\r\n        self.ip = ip\r\n\r\n\r\nclass Blockchain:\r\n    def __init__(self, path, groupPeers, groupAdmins, groupId, client):\r\n        self.BLOCKCHAIN_PATH = path\r\n        self.TRANSACTION_PATH = self.BLOCKCHAIN_PATH + \"\\\\Transactions\\\\\"\r\n        self.unconfirmed_transactions = []\r\n        self.chain = []\r\n        self.peers = groupPeers\r\n        self.groupId = groupId\r\n        self.groupAdmins = groupAdmins\r\n        self.client = client\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n            # Load Unconfirmed Transactions\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n\r\n        self.loadTransactions()\r\n\r\n        # print(self.unconfirmed_transactions)\r\n        # Load Blocks here\r\n        blockFiles = [f for f in listdir(self.BLOCKCHAIN_PATH) if os.path.isfile(os.path.join(self.BLOCKCHAIN_PATH, f))]\r\n        for blockFile in blockFiles:\r\n            self.loadBlock(blockFile)\r\n\r\n        # Start Casual Operations.\r\n        # Thread This.\r\n        miner = threading.Thread(target=self.mine, args=[client])\r\n        miner.start()\r\n        # print(self.unconfirmed_transactions)\r\n        # for block in self.chain:\r\n        #     print(block)\r\n\r\n    def getDifficulty(self):\r\n        # Diffuculty of blockchain will be dependent on the users participating\r\n        # TODO refactor this for join ban unban\r\n        if len(self.peers) == 0:\r\n            return 1\r\n        else:\r\n            peers, bans, admins, owner = self.parseBlockchain()\r\n            return math.floor(math.log2(len(peers)))\r\n\r\n    def createGenesisBlock(self, client):\r\n        transaction = GenesisTransaction(client.publicIP, client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        # this is string json format\r\n        # print(transactionStr)\r\n        # print(transactionStr.__class__)\r\n        # Genereate signature for Transaction\r\n        signature = rsa.sign(transactionStr.encode(), client.privateKey, 'SHA-1')\r\n        genesis_block = Block(0, transactionStr, str(time.time()), \"0\", [str(signature)])\r\n        genesis_block.hash = genesis_block.computeHash()\r\n        self.saveBlock(genesis_block)\r\n        self.chain.append(genesis_block)\r\n\r\n    def saveBlock(self, block):\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Creating Blockchain Folder\")\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n        blockFile = open(self.BLOCKCHAIN_PATH + \"\\\\Block\" + str(block.index) + \".json\", \"w\")\r\n        # print(block.__dict__)\r\n        blockFile.write(json.dumps(block.__dict__))\r\n        blockFile.close()\r\n\r\n    def loadTransactions(self):\r\n        filePath = self.TRANSACTION_PATH + \"Transactions.json\"\r\n        if os.path.exists(filePath):\r\n            try:\r\n                file = open(filePath)\r\n                # print(file)\r\n                json_load_group = json.load(file)\r\n                file.close()\r\n            except Exception as e:\r\n                print(\"Error Opening Transaction file :\", e)\r\n            for x in json_load_group:\r\n                transaction = UnconfirmedTransaction(x[\"transaction\"], x[\"signatures\"])\r\n                # print(transaction)\r\n                self.unconfirmed_transactions.append(transaction)\r\n            # print(self.unconfirmed_transactions)\r\n\r\n    def loadBlock(self, blockFiles):\r\n        # print(blockFiles)\r\n        filePath = self.BLOCKCHAIN_PATH + \"\\\\\" + blockFiles\r\n        file = open(filePath)\r\n        # print(file)\r\n        block = json.load(file)\r\n        file.close()\r\n        # # print(block)\r\n        # transaction = json.loads(block[\"transaction\"])\r\n        # # print(transaction)\r\n        # # print(transaction.__class__)\r\n        # # Make transaction here\r\n        # if transaction[\"type\"] == 0:\r\n        #     # print(\"Genesis block\")\r\n        #     transactionObj = GenesisTransaction(transaction[\"ip\"], transaction[\"publicKey\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        blockObj = Block(block[\"index\"], block[\"transaction\"], block[\"timestamp\"], block[\"previous_hash\"],\r\n                         block[\"signatures\"])\r\n        blockObj.hash = block[\"hash\"]\r\n        # TODO Add all transactions here\r\n\r\n        # elif transaction[\"type\"] == 1:\r\n        #     # print(\"Genesis block\")\r\n        #     # print(transaction)\r\n        #     transactionObj = InviteTransaction(transaction[\"ip\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        #     blockObj = Block(block[\"index\"], transactionStr, block[\"timestamp\"], block[\"previous_hash\"],\r\n        #                      block[\"signatures\"])\r\n        #     blockObj.hash = block[\"hash\"]\r\n\r\n        self.chain.append(blockObj)\r\n        # print(blockObj.__dict__)\r\n\r\n    def addNewTransaction(self, transaction: str):\r\n        newUnconfirmedTransaction = UnconfirmedTransaction(transaction)\r\n        self.unconfirmed_transactions.append(newUnconfirmedTransaction)\r\n        self.saveUnconfirmedTransactions()\r\n\r\n    def updateBlockchain(self, client):\r\n        for peer in self.peers:\r\n            # Dont send to self\r\n            if peer[0] != client.publicIP:\r\n                # For each peer ask their max index of blockchain\r\n                updateBlockchainReq = Networking.UpdateBlockchainRequest(self.groupId)\r\n                res = Networking.sendRequest(peer[0], 6700, dumps(updateBlockchainReq))\r\n                if res is not False:\r\n                    # if the response is bigger than me ask him for his block until we are at the same.\r\n                    if res.answer > self.getLastBlockIndex():\r\n                        print(self.getLastBlockIndex().__class__, res.answer.__class__)\r\n                        while self.getLastBlockIndex() < res.answer:\r\n                            # Get block\r\n                            getBlockReq = Networking.GetBlockRequest(self.groupId, self.getLastBlockIndex() + 1)\r\n                            blockRes = Networking.sendRequest(peer[0], 6700, dumps(getBlockReq))\r\n                            if blockRes is not False:\r\n                                print(f\"Update BC Response:{blockRes}\")\r\n                                # print(blockRes.answer)\r\n                                block = blockRes.answer\r\n                                block: Block\r\n                                print(block.index, block.transaction, block.signatures, block.timestamp,\r\n                                      block.previous_hash, block.hash)\r\n                                newBlock = Block(block.index, block.transaction, block.timestamp, block.previous_hash,\r\n                                                 block.signatures)\r\n                                newBlock.hash = block.hash\r\n                                if self.validateNewBlock(newBlock):\r\n                                    self.saveBlock(newBlock)\r\n                                    self.chain.append(newBlock)\r\n                            else:\r\n                                break\r\n                    else:\r\n                        # print(\"Up-to-date.\")\r\n                        pass\r\n\r\n    def getBlockWithIndex(self, index):\r\n        for block in self.chain:\r\n            block: Block\r\n            if block.index == index:\r\n                return block\r\n        return False\r\n\r\n    def validateNewBlock(self, newBlock):\r\n        \"\"\"This function is for new blocks that come from peers returns true if blocks checks out.\"\"\"\r\n        newBlock: Block\r\n\r\n        # If hash ok.\r\n        if newBlock.computeHash() == newBlock.hash:\r\n            # Validation for genesis block\r\n            if newBlock.index == 0:\r\n                if self.getLastBlockIndex() == -1:\r\n                    # No other blocks accept it.\r\n                    return True\r\n                else:\r\n                    return False\r\n            else:\r\n                # Check if new block is made with the same previous block.\r\n                # TODO if not resolve ?\r\n                if newBlock.previous_hash == self.getLastBlock().computeHash():\r\n                    # TODO check if signatures okay.\r\n                    # TODO check timestamp.\r\n                    # TODO check difficulty based on blockchain etc.\r\n                    return True\r\n\r\n    def mine(self, client):\r\n        # Load my public key.\r\n        # keyLoc = self.BLOCKCHAIN_PATH + \"\\\\..\\\\..\\\\..\\\\PRIVATEKEY.json\"\r\n        # # print(f\"key location = {keyLoc}\")\r\n        # f = open(keyLoc, \"rb\")\r\n        # data = f.read()\r\n        # privateKey = rsa.PrivateKey.load_pkcs1(data)\r\n        # # print(publicKey)\r\n        # f.close()\r\n        while True:\r\n            # Update Blockchain.\r\n            self.updateBlockchain(client)\r\n            if not self.unconfirmed_transactions:\r\n                # If No Transaction sleep and check again soon.\r\n                sleep(30)\r\n            else:\r\n                diff = self.getDifficulty()\r\n                print(f\"Blockchain Difficulty :{diff}\")\r\n                print(f\"Unconfirmed Transactions:{len(self.unconfirmed_transactions)}\")\r\n                for transaction in self.unconfirmed_transactions:\r\n                    transaction: UnconfirmedTransaction\r\n                    # For Each Transaction if signatures < difficulty collect transactions\r\n                    if diff > len(transaction.signatures):\r\n                        if not len(transaction.signatures):\r\n                            # No Signatures add my signature\r\n                            signature = rsa.sign(transaction.transaction.encode(), client.privateKey, 'SHA-1')\r\n                            transaction.signatures.append(str(signature))\r\n                            self.saveUnconfirmedTransactions()\r\n                        else:\r\n                            # Get Signatures from other persons.\r\n                            pass\r\n                    else:\r\n                        # We have the signatures number procede to make block and share.\r\n                        print(f\"Signature {transaction} ready to be made block.\")\r\n                        # Bytes\r\n                        lastBlock = self.getLastBlock()\r\n                        print(lastBlock)\r\n                        lastBlock: Block\r\n                        print(f\"Last Block Index :{lastBlock.index}\")\r\n                        newBlock = Block(lastBlock.index + 1, transaction.transaction, str(time.time()),\r\n                                         lastBlock.computeHash(), transaction.signatures)\r\n                        newBlock.hash = newBlock.computeHash()\r\n                        self.unconfirmed_transactions.remove(transaction)\r\n                        self.saveUnconfirmedTransactions()\r\n                        self.saveBlock(newBlock)\r\n                        self.chain.append(newBlock)\r\n                sleep(30)\r\n\r\n    def getLastBlock(self) -> Block:\r\n        lastBlockIndex = self.chain[0].index\r\n        # Find last Block and return it\r\n        lastBlock = self.chain[0]\r\n        for block in self.chain:\r\n            # print(block.index)\r\n            if block.index > lastBlockIndex:\r\n                lastBlock = block\r\n                lastBlockIndex = block.index\r\n        return lastBlock\r\n\r\n    def getLastBlockIndex(self):\r\n        if len(self.chain) == 0:\r\n            return -1\r\n        else:\r\n            lastBlockIndex = self.chain[0].index\r\n            # Find last Block and return it\r\n            lastBlock = self.chain[0]\r\n            for block in self.chain:\r\n                # print(block.index)\r\n                if block.index > lastBlockIndex:\r\n                    lastBlock = block\r\n                    lastBlockIndex = block.index\r\n            return lastBlock.index\r\n\r\n    def saveUnconfirmedTransactions(self):\r\n        # print(self.TRANSACTION_PATH)\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Blockchain Folder\")\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n        json_file = open(self.TRANSACTION_PATH + \"Transactions\" + \".json\", \"w\")\r\n        json_file.write((json.dumps([ob.__dict__ for ob in self.unconfirmed_transactions])))\r\n        json_file.close()\r\n\r\n    def isUserAllowed(self, ip):\r\n        for block in self.chain:\r\n            block: Block\r\n            transaction = json.loads(block.transaction)\r\n            # From Create Genesis Block\r\n            if transaction[\"type\"] == 0:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n            # From Invite\r\n            if transaction[\"type\"] == 1:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n        # Didndt find user\r\n        return False\r\n\r\n    def getOwner(self):\r\n        for block in self.chain:\r\n            transaction = json.loads(block.transaction)\r\n            if transaction[\"type\"] == 0:\r\n                return transaction[\"ip\"]\r\n\r\n    def parseBlockchain(self):\r\n        \"\"\"\r\n        Parses Blockchain and returns 5 list of user types.\r\n        Peers that are in the blockchain and allowed.\r\n        Banned peers, Invites ,Admins and, Owner . All are lists.\r\n        \"\"\"\r\n        peers = []\r\n        bans = []\r\n        admins = []\r\n        invites = []\r\n        owner = []\r\n\r\n        for block in self.chain:\r\n            transaction = json.loads(block.transaction)\r\n            #GenesisTransactio\r\n            if transaction[\"type\"] == 0:\r\n                owner.append(transaction[\"ip\"])\r\n                admins.append(transaction[\"ip\"])\r\n                peers.append(transaction[\"ip\"])\r\n\r\n            #InviteTransaction\r\n            elif transaction[\"type\"] == 1:\r\n                invites.append(transaction[\"ip\"])\r\n\r\n            #JoinTransaction\r\n            elif transaction[\"type\"] == 2:\r\n                peers.append(transaction[\"ip\"])\r\n                invites.remove(transaction[\"ip\"])\r\n\r\n            #BanTransaction\r\n            elif transaction[\"type\"] == 3:\r\n                peers.remove(transaction[\"ip\"])\r\n                bans.append(transaction[\"ip\"])\r\n\r\n            # UnbanTransaction\r\n            elif transaction[\"type\"] == 4:\r\n                bans.remove(transaction[\"ip\"])\r\n\r\n                # AddAdminTransaction\r\n            elif transaction[\"type\"] == 5:\r\n                admins.append(transaction[\"ip\"])\r\n\r\n            # RemoveAdminTransaction\r\n            elif transaction[\"type\"] == 6:\r\n                admins.remove(transaction[\"ip\"])\r\n\r\n        # print(f\"Peers:{peers},Bans:{bans},Admins:{admins},Owners:{owner}\")\r\n        return peers, bans, admins, owner\r\n\r\n\r\nimport Networking\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/Blockchain.py b/Blockchain.py
---- a/Blockchain.py	(revision 397da46c4b816e67fbbc1f8b78f311f5a70ab115)
-+++ b/Blockchain.py	(date 1650889080313)
-@@ -386,8 +386,12 @@
- 
-         for block in self.chain:
-             transaction = json.loads(block.transaction)
-+            print(peers,invites)
-+            print(transaction)
-+
-             #GenesisTransactio
-             if transaction["type"] == 0:
-+
-                 owner.append(transaction["ip"])
-                 admins.append(transaction["ip"])
-                 peers.append(transaction["ip"])
-Index: main.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import json\r\nimport logging\r\nimport threading\r\nfrom pickle import dumps, loads\r\nfrom flask import Flask, render_template, request, redirect\r\n\r\nimport Blockchain\r\nimport Compress\r\nfrom Networking import receiver, sendRequest, JoinRequest, SearchBundleRequest, receiveBundle, GetBundleRequest\r\nfrom Groups import GroupManager, Invite, Group\r\nfrom Client import Client\r\nimport easygui\r\nfrom Bundles import BundleManager\r\nfrom Downloads import DownloadManager\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = False\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    progress = downloadManager.getDownloadProgress()\r\n    return render_template(\"index.html\", groups=groupManager.groups, client=client, progress=progress)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    group = groupManager.getGroupWithName(group)\r\n    # Check if user should see admin panels.\r\n    peers, bans, admins, owner = group.blockchain.parseBlockchain()\r\n    print(peers,admins,bans)\r\n    # Check privs what to show on group page.\r\n    adminPriv = False\r\n    for admin in group.admins:\r\n        if admin[0] == client.publicIP:\r\n            adminPriv = True\r\n\r\n    ownerPriv = False\r\n    if group.blockchain.getOwner() == client.publicIP:\r\n        ownerPriv = True\r\n\r\n    if client.publicIP in admins:\r\n        admins.remove(client.publicIP)\r\n    if client.publicIP in peers:\r\n        peers.remove(client.publicIP)\r\n\r\n\r\n\r\n\r\n\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group, client=client, adminPriv=adminPriv,\r\n                           ownerPriv=ownerPriv, peers=peers, bans=bans, admins=admins)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    if downloadManager.STATUS:\r\n        downloadManager.STATUS = False\r\n        # downloadManager Off\r\n        print(\"Download Manager Not Active\")\r\n        return \"0\"\r\n    else:\r\n        downloadManager.STATUS = True\r\n        # downloadManager On\r\n        print(\"Download Manager Active\")\r\n        return \"1\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n        # TODO KEY SPECIFIC BLOCKCHAIN\r\n        ip = data[\"ip\"]  # This is string\r\n        transaction = Blockchain.InviteTransaction(ip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        # print(\"Generate Invite for :\", group)\r\n        # print(group)\r\n        invite = group.generateInvite()\r\n        return Compress.compress(invite.toJSON())\r\n\r\n\r\n\r\n@app.route('/deleteBundle', methods=['POST'])\r\ndef deleteBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupId = data[\"groupId\"]\r\n        bundleId = data[\"bundleId\"]\r\n        if groupManager.deleteBundle(groupId, bundleId):\r\n            return \"1\"\r\n        else:\r\n            return \"0\"\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        inviteDecomp = Compress.decompress(invite)\r\n        inviteLoad = json.loads(inviteDecomp)\r\n        invite = Invite(inviteLoad[\"id\"], inviteLoad[\"name\"], inviteLoad[\"timestamp\"], inviteLoad[\"peers\"])\r\n        joinReq = JoinRequest(invite.name, invite.timestamp)\r\n        print(invite.peers)\r\n        for peer in invite.peers:\r\n            print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq))\r\n            if res is not False:\r\n                # Response from user with group data.\r\n                group = res.group\r\n                group = Group(group.name, group.admins, group.peers, group.timestamp,\r\n                              blockchainPath=groupManager.DIR_PATH_GROUPS + group.name + \"\\\\Blockchain\", client=client)\r\n                groupManager.addGroup(group)\r\n                # Make Join Transaction.\r\n                transaction = Blockchain.JoinTransaction(client.publicIP,\r\n                                                         client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n                transactionStr = json.dumps(transaction.__dict__)\r\n                group.blockchain.addNewTransaction(transactionStr)\r\n                return \"1\"\r\n        # No responses.\r\n        return \"0\"\r\n\r\n\r\n@app.route('/shareBundle', methods=['POST'])\r\ndef shareBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"bundleName\"]\r\n        desc = data[\"bundleDescription\"]\r\n        groupName = data[\"groupName\"]\r\n        print(name)\r\n        print(desc)\r\n        print(groupName)\r\n        path = easygui.diropenbox(msg=\"Select folder to share as bundle\", title=\"Share Bundle\")\r\n        bundle = bundleManager.createBundle(name, desc, path=path)\r\n        groupManager.addBundle(bundle, groupName)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/selectDownloadLocation', methods=['POST'])\r\ndef selectDownloadLocation():\r\n    if request.method == 'POST':\r\n        path = easygui.diropenbox(msg=\"Select folder to download bundles\", title=\"Select Bundle Download Location\")\r\n        print(path)\r\n        # Update Download Path in Config\r\n        client.DIR_PATH_DOWNLOADS = path\r\n        client.saveConfig()\r\n        # Return path to browser and update it in modal\r\n        return path\r\n\r\n\r\n@app.route('/searchBundles', methods=['POST'])\r\ndef searchBundles():\r\n    # print(\"Search Bundles Route\")\r\n    if request.method == 'POST':\r\n        data = request.form\r\n\r\n        # Get Keywords from search\r\n        keywords = data[\"searchKeyWords\"].split()\r\n        # print(\"Search for :\",keywords)\r\n\r\n        # Get Group\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n\r\n        searchReq = SearchBundleRequest(group.id, keywords)\r\n        responses = []\r\n        # SEND TO ALL PEERS COLLECT RESPONSES AND PRESENT\r\n        for peer in group.peers:\r\n            res = sendRequest(peer[0], 6700, dumps(searchReq))\r\n            # if other peer is responded.\r\n            if res is not False:\r\n                # print(res)\r\n                responses.append([peer[0], res])\r\n            else:\r\n                print(\"No Response from\", peer[0])\r\n        # Merge all responses to single list\r\n        # for x in responses:\r\n        #     print(\"Response:\",x[0],x[1],x[1].responseBundles)\r\n        # WITH RESPONSES DO STUFF.\r\n        # Respond\r\n        return render_template(\"search.html\", groups=groupManager.groups, group=group, responses=responses)\r\n\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n    if groupManager.createGroup(name, [client.publicIP]):\r\n        # Make First Block In Blockchain Append Admin\r\n        # Type 0 First Created\r\n        group = groupManager.getGroupWithName(name)\r\n        group.blockchain.createGenesisBlock(client)\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n\r\n@app.route('/getBundle', methods=['POST'])\r\ndef getBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        bundleId = data[\"bundleId\"]\r\n        groupId = data[\"groupId\"]\r\n        userIp = data[\"userIp\"]\r\n        # TODO dynamic port on receiver for bundle\r\n        portForBundleReceiver = 6701\r\n        bundleReceiver = threading.Thread(target=receiveBundle,\r\n                                          args=[portForBundleReceiver, client, groupManager, groupId, downloadManager])\r\n        bundleReceiver.start()\r\n        getBundleReq = GetBundleRequest(bundleId, groupId, portForBundleReceiver)\r\n        res = sendRequest(userIp, 6700, dumps(getBundleReq))\r\n        # if other peer is responded.\r\n        if res is not False:\r\n            # Responded decide what to do\r\n            pass\r\n        else:\r\n            # print(\"No Response from\", userIp)\r\n            pass\r\n    return \"1\"\r\n\r\n\r\n@app.route('/quitGroup', methods=['POST'])\r\ndef quitGroup():\r\n    # print('QUIT GROUP REQ')\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        if groupManager.quitGroup(group):\r\n            # True\r\n            return \"0\"\r\n        else:\r\n            # False\r\n            return \"1\"\r\n\r\n\r\n@app.route('/banUser', methods=['POST'])\r\ndef banUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.BanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/unbanUser', methods=['POST'])\r\ndef unbanUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.UnbanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/addAdmin', methods=['POST'])\r\ndef addAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.AddAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/removeAdmin', methods=['POST'])\r\ndef removeAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.RemoveAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    groupManager = GroupManager(client)\r\n    bundleManager = BundleManager()\r\n    downloadManager = DownloadManager(groupManager, client)\r\n    # TODO Networking Thread To Receive From Internet\r\n    receiver = threading.Thread(target=receiver, args=[groupManager])\r\n    receiver.start()\r\n    app.run(host='', port=6969)\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/main.py b/main.py
---- a/main.py	(revision 397da46c4b816e67fbbc1f8b78f311f5a70ab115)
-+++ b/main.py	(date 1650888313838)
-@@ -34,7 +34,7 @@
-     group = groupManager.getGroupWithName(group)
-     # Check if user should see admin panels.
-     peers, bans, admins, owner = group.blockchain.parseBlockchain()
--    print(peers,admins,bans)
-+    print(peers, admins, bans)
-     # Check privs what to show on group page.
-     adminPriv = False
-     for admin in group.admins:
-@@ -50,10 +50,6 @@
-     if client.publicIP in peers:
-         peers.remove(client.publicIP)
- 
--
--
--
--
-     return render_template("groups.html", groups=groupManager.groups, group=group, client=client, adminPriv=adminPriv,
-                            ownerPriv=ownerPriv, peers=peers, bans=bans, admins=admins)
- 
-@@ -90,7 +86,6 @@
-         return Compress.compress(invite.toJSON())
- 
- 
--
- @app.route('/deleteBundle', methods=['POST'])
- def deleteBundle():
-     if request.method == 'POST':
-Index: .idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM_[Changes]/shelved.patch
-===================================================================
-diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM_[Changes]/shelved.patch
-deleted file mode 100644
---- a/.idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM_[Changes]/shelved.patch	(revision 397da46c4b816e67fbbc1f8b78f311f5a70ab115)
-+++ /dev/null	(revision 397da46c4b816e67fbbc1f8b78f311f5a70ab115)
-@@ -1,650 +0,0 @@
--Index: .idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM_[Changes]/shelved.patch
--===================================================================
--diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM_[Changes]/shelved.patch
--deleted file mode 100644
----- a/.idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM_[Changes]/shelved.patch	(revision e93e724ace85a4e7a5d706e587d82e895584bb85)
--+++ /dev/null	(revision e93e724ace85a4e7a5d706e587d82e895584bb85)
--@@ -1,631 +0,0 @@
---Index: .idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM_[Changes]/shelved.patch
---===================================================================
---diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM_[Changes]/shelved.patch
---deleted file mode 100644
------ a/.idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM_[Changes]/shelved.patch	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---@@ -1,253 +0,0 @@
----Index: .idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM_[Changes]/shelved.patch
----===================================================================
----diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM_[Changes]/shelved.patch
----deleted file mode 100644
------- a/.idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM_[Changes]/shelved.patch	(revision b2a6e34799d5eb81b092421737b71d713c796f3a)
----+++ /dev/null	(revision b2a6e34799d5eb81b092421737b71d713c796f3a)
----@@ -1,234 +0,0 @@
-----Index: .idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM__Changes_1.xml
-----===================================================================
-----diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM__Changes_1.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM__Changes_1.xml
-----deleted file mode 100644
-------- a/.idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM__Changes_1.xml	(revision af1ab55a3550b7c7081ff28c3debc5801fd1458b)
-----+++ /dev/null	(revision af1ab55a3550b7c7081ff28c3debc5801fd1458b)
-----@@ -1,4 +0,0 @@
------<changelist name="Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM_[Changes]1" date="1644986804180" recycled="true" deleted="true">
------  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM_[Changes]1/shelved.patch" />
------  <option name="DESCRIPTION" value="Uncommitted changes before Update at 16-Feb-22 6:46 AM [Changes]" />
------</changelist>
-----\ No newline at end of file
-----Index: .idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM_[Changes]1/shelved.patch
-----===================================================================
-----diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM_[Changes]1/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM_[Changes]1/shelved.patch
-----deleted file mode 100644
-------- a/.idea/shelf/Uncommitted_changes_before_Update_at_16-Feb-22_6_46_AM_[Changes]1/shelved.patch	(revision af1ab55a3550b7c7081ff28c3debc5801fd1458b)
-----+++ /dev/null	(revision af1ab55a3550b7c7081ff28c3debc5801fd1458b)
-----@@ -1,215 +0,0 @@
------Index: p2p.py
------===================================================================
------diff --git a/p2p.py b/p2p.py
------deleted file mode 100644
--------- a/p2p.py	
------+++ /dev/null	
------@@ -1,27 +0,0 @@
-------from socket import socket, AF_INET, SOCK_DGRAM
-------
-------
-------def server():
-------    UDP_PORT = 56700
-------    sock = socket(AF_INET, SOCK_DGRAM)
-------    sock.bind(("0.0.0.0", UDP_PORT))
-------    print(sock.getsockname())
-------
-------    while True:
-------        print("Ready to receive")
-------        data, addr = sock.recvfrom(1024)  # buffer size is 1024 bytes
-------        print("Received", data, "from", addr)
-------
-------
-------def send():
-------
-------
-------
-------if __name__ == "__main__":
-------    server()
-------
-------if __name__ == "__main__":
-------    listen()
-------
-------if __name__ == "__main__":
-------    listen()
------Index: .idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM__Changes_.xml
------===================================================================
------diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM__Changes_.xml
------deleted file mode 100644
--------- a/.idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM__Changes_.xml	
------+++ /dev/null	
------@@ -1,4 +0,0 @@
-------<changelist name="Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM_[Changes]" date="1644302304744" recycled="true" deleted="true">
-------  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM_[Changes]/shelved.patch" />
-------  <option name="DESCRIPTION" value="Uncommitted changes before Update at 08-Feb-22 8:38 AM [Changes]" />
-------</changelist>
------\ No newline at end of file
------Index: .idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM_[Changes]/shelved.patch
------===================================================================
------diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM_[Changes]/shelved.patch
------deleted file mode 100644
--------- a/.idea/shelf/Uncommitted_changes_before_Update_at_08-Feb-22_8_38_AM_[Changes]/shelved.patch	
------+++ /dev/null	
------@@ -1,144 +0,0 @@
-------Index: .idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM_[Changes]/shelved.patch
-------===================================================================
-------diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM_[Changes]/shelved.patch
-------deleted file mode 100644
---------- a/.idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM_[Changes]/shelved.patch	(revision 204d08569dda605f981bf96b435bdf1dcd148dab)
-------+++ /dev/null	(revision 204d08569dda605f981bf96b435bdf1dcd148dab)
-------@@ -1,125 +0,0 @@
--------Index: static/index.css
--------IDEA additional info:
--------Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
--------<+>html, body{height: 100%;overflow: hidden;}\r\nbody{\r\n  margin: 0;\r\n  background-image: linear-gradient(to right, #141e30, #243b55);\r\n}
--------Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
--------<+>UTF-8
--------===================================================================
--------diff --git a/static/index.css b/static/index.css
----------- a/static/index.css	(revision 4a4d56f622e247ef187bdf310782755e8ce34f5b)
--------+++ b/static/index.css	(date 1643194007877)
--------@@ -1,5 +1,76 @@
-------- html, body{height: 100%;overflow: hidden;}
-------- body{
---------  margin: 0;
--------+  overflow: hidden;
--------   background-image: linear-gradient(to right, #141e30, #243b55);
--------+}
--------+* {
--------+  margin: 0;
--------+  padding: 0;
--------+  list-style: none;
--------+  font-family: "Lato", sans-serif;
--------+  line-height: 1;
--------+}
--------+
--------+body {
--------+  background-color: #f5f6f8;
--------+  overflow: hidden;
--------+}
--------+
--------+.sidebar-navigation {
--------+  display: inline-block;
--------+  min-height: 100vh;
--------+  width: 80px;
--------+  background-color: #313443;
--------+  float: left;
--------+}
--------+.sidebar-navigation ul {
--------+  text-align: center;
--------+  color: white;
--------+}
--------+.sidebar-navigation ul li {
--------+  padding: 28px 0;
--------+  cursor: pointer;
--------+  transition: all ease-out 120ms;
--------+}
--------+.sidebar-navigation ul li i {
--------+  display: block;
--------+  font-size: 24px;
--------+  transition: all ease 450ms;
--------+}
--------+.sidebar-navigation ul li .tooltip {
--------+  display: inline-block;
--------+  position: absolute;
--------+  background-color: #313443;
--------+  padding: 8px 15px;
--------+  border-radius: 3px;
--------+  margin-top: -26px;
--------+  left: 90px;
--------+  opacity: 0;
--------+  visibility: hidden;
--------+  font-size: 13px;
--------+  letter-spacing: 0.5px;
--------+}
--------+.sidebar-navigation ul li .tooltip:before {
--------+  content: "";
--------+  display: block;
--------+  position: absolute;
--------+  left: -4px;
--------+  top: 10px;
--------+  transform: rotate(45deg);
--------+  width: 10px;
--------+  height: 10px;
--------+  background-color: inherit;
--------+}
--------+.sidebar-navigation ul li:hover {
--------+  background-color: #22252e;
--------+}
--------+.sidebar-navigation ul li:hover .tooltip {
--------+  visibility: visible;
--------+  opacity: 1;
--------+}
--------+.sidebar-navigation ul li.active {
--------+  background-color: #22252e;
--------+}
--------+.sidebar-navigation ul li.active i {
--------+  color: #98d7ec;
-------- }
--------\ No newline at end of file
--------Index: templates/index.html
--------IDEA additional info:
--------Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
--------<+><!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <!--TODO-->\r\n    <title>p2p toreent app title</title>\r\n    <!--CSS FOR INDEX PAGE-->\r\n    <link rel=\"stylesheet\" href=\"../static/index.css\">\r\n</head>\r\n\r\n<body>\r\n\r\n</body>\r\n\r\n</html>
--------Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
--------<+>UTF-8
--------===================================================================
--------diff --git a/templates/index.html b/templates/index.html
----------- a/templates/index.html	(revision 4a4d56f622e247ef187bdf310782755e8ce34f5b)
--------+++ b/templates/index.html	(date 1643192853872)
--------@@ -7,10 +7,23 @@
--------     <title>p2p toreent app title</title>
--------     <!--CSS FOR INDEX PAGE-->
--------     <link rel="stylesheet" href="../static/index.css">
--------+	<!--ICONS-->
--------+	<script src="https://kit.fontawesome.com/c5cd512f5f.js" crossorigin="anonymous"></script>
-------- </head>
-------- 
-------- <body>
---------
--------+	<nav class="sidebar-navigation">
--------+		<ul>
--------+			<li class="active">
--------+				<i class="fa fa-share-alt"></i>
--------+				<span class="tooltip">Connections</span>
--------+			</li>
--------+			<li>
--------+				<i class="fa fa-sliders"></i>
--------+				<span class="tooltip">Settings</span>
--------+			</li>
--------+		</ul>
--------+	</nav>
-------- </body>
-------- 
-------- </html>
--------\ No newline at end of file
-------Index: .idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM__Changes_.xml
-------===================================================================
-------diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM__Changes_.xml
-------deleted file mode 100644
---------- a/.idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM__Changes_.xml	(revision 204d08569dda605f981bf96b435bdf1dcd148dab)
-------+++ /dev/null	(revision 204d08569dda605f981bf96b435bdf1dcd148dab)
-------@@ -1,4 +0,0 @@
--------<changelist name="Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM_[Changes]" date="1643261345007" recycled="true" deleted="true">
--------  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_27-Jan-22_7_28_AM_[Changes]/shelved.patch" />
--------  <option name="DESCRIPTION" value="Uncommitted changes before Update at 27-Jan-22 7:28 AM [Changes]" />
--------</changelist>
-------\ No newline at end of file
------Index: main.py
------IDEA additional info:
------Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
------<+>import json\r\nimport logging\r\nimport threading\r\n\r\nfrom flask import Flask, render_template, request, redirect\r\nimport compress\r\n\r\nfrom Receiver import receiver\r\nfrom Groups import GroupManager\r\nfrom Client import Client\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = False\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    return render_template(\"index.html\", groups=groupManager.groups)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    print(\"Group page request :\", group)\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    return \"fuck\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        print(\"Generate Invite for :\", group)\r\n        # TODO generate group invite\r\n        group = groupManager.getGroup(group)\r\n        jsonPeers = json.dumps(group.peers)\r\n        return compress.compress(jsonPeers)\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        print(\"Join group with Invite:\", invite)\r\n        inviteDecomp = compress.decompress(invite)\r\n        print(\"Peers to try:\", inviteDecomp)\r\n\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n        if data[\"private\"]:\r\n            private = 1\r\n        else:\r\n            private = 0\r\n    if groupManager.createGroup(name, private, [client.publicIP]):\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    # x = threading.Thread(target=receiver)\r\n    # x.start()\r\n    groupManager = GroupManager()\r\n    app.run(host='127.0.0.1', port=6969)\r\n
------Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
------<+>UTF-8
------===================================================================
------diff --git a/main.py b/main.py
--------- a/main.py	
------+++ b/main.py	
------@@ -5,7 +5,6 @@
------ from flask import Flask, render_template, request, redirect
------ import compress
------ 
-------from Receiver import receiver
------ from Groups import GroupManager
------ from Client import Client
------ 
----Index: .idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM__Changes_.xml
----===================================================================
----diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM__Changes_.xml
----deleted file mode 100644
------- a/.idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM__Changes_.xml	(revision b2a6e34799d5eb81b092421737b71d713c796f3a)
----+++ /dev/null	(revision b2a6e34799d5eb81b092421737b71d713c796f3a)
----@@ -1,4 +0,0 @@
-----<changelist name="Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM_[Changes]" date="1646725875130" recycled="true" deleted="true">
-----  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_08-Mar-22_9_51_AM_[Changes]/shelved.patch" />
-----  <option name="DESCRIPTION" value="Uncommitted changes before Update at 08-Mar-22 9:51 AM [Changes]" />
-----</changelist>
----\ No newline at end of file
---Index: .idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM__Changes_.xml
---===================================================================
---diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM__Changes_.xml
---deleted file mode 100644
------ a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM__Changes_.xml	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---@@ -1,4 +0,0 @@
----<changelist name="Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM_[Changes]" date="1648480562716" recycled="true" deleted="true">
----  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM_[Changes]/shelved.patch" />
----  <option name="DESCRIPTION" value="Uncommitted changes before Update at 28-Mar-22 6:15 PM [Changes]" />
----</changelist>
---\ No newline at end of file
---Index: .idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM__Changes_.xml
---===================================================================
---diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM__Changes_.xml
---deleted file mode 100644
------ a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM__Changes_.xml	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---@@ -1,4 +0,0 @@
----<changelist name="Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM_[Changes]" date="1648484286020" recycled="true" deleted="true">
----  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM_[Changes]/shelved.patch" />
----  <option name="DESCRIPTION" value="Uncommitted changes before Update at 28-Mar-22 7:18 PM [Changes]" />
----</changelist>
---\ No newline at end of file
---Index: .idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM_[Changes]/shelved.patch
---===================================================================
---diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM_[Changes]/shelved.patch
---deleted file mode 100644
------ a/.idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM_[Changes]/shelved.patch	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---@@ -1,58 +0,0 @@
----Index: Networking.py
----IDEA additional info:
----Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
----<+>import socket\r\nfrom socket import *\r\nimport pickle\r\nimport copy\r\nimport Groups\r\nfrom threading import Thread\r\nfrom Groups import Group\r\nimport threading\r\n\r\n\r\nclass Request:\r\n    def __init__(self, type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self, name, timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self, group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\n\r\nclass SearchBundleRequest(Request):\r\n    def __init__(self, groupId, keyword):\r\n        super().__init__(2)\r\n        self.groupID = groupId\r\n        self.keywords = keyword\r\n\r\n\r\nclass SearchBundleResponse(Request):\r\n    def __init__(self, responseBundles):\r\n        super().__init__(2)\r\n        self.responseBundles = responseBundles\r\n\r\nclass GetBundleRequest(Request):\r\n    def __init__(self, bundleId,groupId,portForBundleReceiver):\r\n        super().__init__(3)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.portForBundleReceiver = portForBundleReceiver\r\n\r\n\r\nclass GetBundleResponse(Request):\r\n    def __init__(self,answer):\r\n        super().__init__(3)\r\n        self.answer = answer\r\n\r\n\r\n\r\ndef requestHandler(data, addr, groupManager: Groups.GroupManager):\r\n    req = pickle.loads(data)\r\n    # Response to JoinRequest\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name, req.timestamp)\r\n        # TODO If this is allowed add peer and respond\r\n        # TODO Peer Port\r\n        groupManager.addPeerGroup(req.name, [addr[0]])\r\n        group = groupManager.getGroup(req.name)\r\n        groupCpy = copy.copy(group)\r\n        del groupCpy.bundles\r\n        joinResponse = JoinResponse(groupCpy)\r\n        return pickle.dumps(joinResponse)\r\n\r\n    #Response to search req\r\n    elif req.type == 2:\r\n        # Create The Request again for local use\r\n        req = SearchBundleRequest(req.groupID, req.keywords)\r\n        # Get All Bundles User has\r\n        bundlesOfGroup = groupManager.getGroupWithID(req.groupID).bundles\r\n        # Bundles to reply\r\n        responseBundles = []\r\n        print(responseBundles)\r\n        for bundle in bundlesOfGroup:\r\n            # For each bundle make a single list (bundleKeywords) and search if any of the keywords other user send are in there then send back\r\n            name = bundle.name.split()\r\n            desc = bundle.description.split()\r\n            bundleKeywords = name + desc\r\n            # print(\"Bundle Keywords : \",bundleKeywords)\r\n            # print(\"Request Keywords : \",req.keywords)\r\n            if any(keyword in req.keywords for keyword in bundleKeywords):\r\n                # print(\"HIT\")\r\n                responseBundles.append({\"id\": bundle.id, \"name\": bundle.name, \"description\": bundle.description})\r\n        # Create Response and return it to be used as answer\r\n        # print(responseBundles)\r\n        searchResponse = SearchBundleResponse(responseBundles)\r\n        # print(\"Search Response :\",searchResponse)\r\n        return pickle.dumps(searchResponse)\r\n\r\n    elif req.type == 3:\r\n        req = GetBundleRequest(req.bundleId,req.groupId,req.portForBundleReceiver)\r\n        bundle = groupManager.getGroupWithID(req.groupId).getBundleWithId(req.bundleId)\r\n        bundleReceiver = threading.Thread(target=sendBundle, args=[addr,req.portForBundleReceiver,bundle])\r\n        bundleReceiver.start()\r\n        #TODO refactor use it to determine if user ok to send bundle\r\n        return GetBundleResponse(1)\r\n\r\ndef responseHandler(data, groupManager):\r\n    res = pickle.loads(data)\r\n\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        return res\r\n\r\n    elif res.type == 2:\r\n        res = SearchBundleResponse(res.responseBundles)\r\n        return res\r\n\r\n    elif res.type == 3:\r\n        res = SearchBundleResponse(res.answer)\r\n        return res\r\n\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        # RECEIVE AND RESPOND.\r\n        data, addr = sock.recvfrom(65537)\r\n        # data, addr = sock.recvfrom(65507)\r\n        print(\"Received from :\",addr, \" data:\",data)\r\n        response = requestHandler(data, addr, groupManager)\r\n        sock.sendto(response, addr)\r\n\r\n\r\ndef sendRequest(address, port, request, groupManager):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.settimeout(1)\r\n    try:\r\n        clientSocket.sendto(request, (address, port))\r\n        data, addr = clientSocket.recvfrom(65537)\r\n        # data, addr = clientSocket.recvfrom(65507)\r\n        res = responseHandler(data, groupManager)\r\n        return res\r\n    # TODO except socket.timeout\r\n    # TODO for better exception handling fix later.\r\n    except Exception as exception:\r\n        print(\"Exception on SendRequest:\",exception)\r\n        return False\r\n\r\ndef receiveBundle(port):\r\n    print(\"RECEIVING BUNDLE THREAD\")\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.bind((\"0.0.0.0\", port))\r\n        print(\"Bundle Receiver Ready\")\r\n        s.listen()\r\n        conn, addr = s.accept()\r\n        with conn:\r\n            print(f\"Connected by {addr}\")\r\n            while True:\r\n                data = conn.recv(1024)\r\n                if not data:\r\n                    break\r\n                conn.sendall(data)\r\n\r\ndef sendBundle(addr,port,bundle):\r\n    print(\"SENDING BUNDLE THREAD\")\r\n    with socket(AF_INET,SOCK_STREAM) as s:\r\n        s.bind((addr, port))\r\n        print(\"Bundle Receiver Ready\")\r\n        s.listen()\r\n        conn, addr = s.accept()\r\n        with conn:\r\n            print(f\"Connected by {addr}\")\r\n            while True:\r\n                data = conn.recv(1024)\r\n                if not data:\r\n                    break\r\n                conn.sendall(data)
----Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
----<+>UTF-8
----===================================================================
----diff --git a/Networking.py b/Networking.py
------- a/Networking.py	(revision ae247badae8c55d3e507e1fa37f4599871c48816)
----+++ b/Networking.py	(date 1648747293775)
----@@ -101,7 +101,7 @@
----         bundleReceiver = threading.Thread(target=sendBundle, args=[addr,req.portForBundleReceiver,bundle])
----         bundleReceiver.start()
----         #TODO refactor use it to determine if user ok to send bundle
-----        return GetBundleResponse(1)
----+        return pickle.dumps(GetBundleResponse(1))
---- 
---- def responseHandler(data, groupManager):
----     res = pickle.loads(data)
----@@ -115,7 +115,7 @@
----         return res
---- 
----     elif res.type == 3:
-----        res = SearchBundleResponse(res.answer)
----+        res = GetBundleResponse(res.answer)
----         return res
---- 
---- 
----@@ -167,15 +167,15 @@
---- 
---- def sendBundle(addr,port,bundle):
----     print("SENDING BUNDLE THREAD")
-----    with socket(AF_INET,SOCK_STREAM) as s:
-----        s.bind((addr, port))
-----        print("Bundle Receiver Ready")
-----        s.listen()
-----        conn, addr = s.accept()
-----        with conn:
-----            print(f"Connected by {addr}")
-----            while True:
-----                data = conn.recv(1024)
-----                if not data:
-----                    break
-----                conn.sendall(data)
----\ No newline at end of file
----+    # with socket(AF_INET,SOCK_STREAM) as s:
----+    #     s.bind(addr, port)
----+    #     print("Bundle Receiver Ready")
----+    #     s.listen()
----+    #     conn, addr = s.accept()
----+    #     with conn:
----+    #         print(f"Connected by {addr}")
----+    #         while True:
----+    #             data = conn.recv(1024)
----+    #             if not data:
----+    #                 break
----+    #             conn.sendall(data)
----\ No newline at end of file
---Index: .idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM__Changes_.xml
---===================================================================
---diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM__Changes_.xml
---deleted file mode 100644
------ a/.idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM__Changes_.xml	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---@@ -1,4 +0,0 @@
----<changelist name="Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM_[Changes]" date="1648290013718" recycled="true" deleted="true">
----  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_26-Mar-22_12_20_PM_[Changes]/shelved.patch" />
----  <option name="DESCRIPTION" value="Uncommitted changes before Update at 26-Mar-22 12:20 PM [Changes]" />
----</changelist>
---\ No newline at end of file
---Index: .idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM__Changes_.xml
---===================================================================
---diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM__Changes_.xml
---deleted file mode 100644
------ a/.idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM__Changes_.xml	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---@@ -1,4 +0,0 @@
----<changelist name="Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM_[Changes]" date="1648817514293" recycled="true" deleted="true">
----  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_01-Apr-22_3_51_PM_[Changes]/shelved.patch" />
----  <option name="DESCRIPTION" value="Uncommitted changes before Update at 01-Apr-22 3:51 PM [Changes]" />
----</changelist>
---\ No newline at end of file
---Index: .idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM_[Changes]/shelved.patch
---===================================================================
---diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM_[Changes]/shelved.patch
---deleted file mode 100644
------ a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_18_PM_[Changes]/shelved.patch	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---@@ -1,20 +0,0 @@
----Index: Networking.py
----IDEA additional info:
----Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
----<+>import socket\r\nfrom socket import *\r\nimport pickle\r\nimport copy\r\nimport Groups\r\nfrom Groups import Group\r\n\r\n\r\nclass Request:\r\n    def __init__(self,type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self,name,timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self,group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\nclass SearchBundleRequest(Request):\r\n    def __init__(self, groupId, keyword):\r\n        super().__init__(2)\r\n        self.groupID = groupId\r\n        self.keywords = keyword\r\n\r\nclass SearchBundleResponse(Request):\r\n    def __init__(self,groups):\r\n        super().__init__(2)\r\n        self.responseBundles = groups\r\n\r\ndef requestHandler(data, addr, groupManager: Groups.GroupManager):\r\n    req = pickle.loads(data)\r\n    # Response to JoinRequest\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name,req.timestamp)\r\n        #TODO If this is allowed add peer and respond\r\n        #TODO Peer Port\r\n        groupManager.addPeerGroup(req.name,[addr[0]])\r\n        group = groupManager.getGroup(req.name)\r\n        groupCpy = copy.copy(group)\r\n        del groupCpy.bundles\r\n        joinResponse = JoinResponse(groupCpy)\r\n        return pickle.dumps(joinResponse)\r\n\r\n    elif req.type == 2:\r\n        #Create The Request again for local use\r\n        req = SearchBundleRequest(req.groupID,req.keywords)\r\n        #Get All Bundles User has\r\n        bundlesOfGroup = groupManager.getGroupWithID(req.groupID).bundles\r\n        #Bundles to reply\r\n        responseBundles = []\r\n        for bundle in bundlesOfGroup:\r\n            #For each bundle make a single list (bundleKeywords) and search if any of the keywords other user send are in there then send back\r\n            name = bundle.name.split()\r\n            desc = bundle.description.split()\r\n            bundleKeywords = name + desc\r\n            if any(keyword in req.keywords for keyword in bundleKeywords):\r\n                responseBundles.append({\"id\":bundle.id,\"name\":bundle.name,\"description\":bundle.description})\r\n        #Create Response and return it to be used as answer\r\n        searchResponse = SearchBundleResponse(responseBundles)\r\n        return addr,pickle.dumps(searchResponse)\r\n\r\ndef responseHandler(data, groupManager):\r\n    res = pickle.loads(data)\r\n\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        return res\r\n\r\n    elif res.type == 2:\r\n        res = SearchBundleResponse(res.responseBundles)\r\n        return res\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        #RECEIVE AND RESPOND.\r\n        data, addr = sock.recvfrom(65507)\r\n        print(addr,data)\r\n        response = requestHandler(data,addr,groupManager)\r\n        sock.sendto(response,addr)\r\n\r\ndef sendRequest(address, port, request,groupManager):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.settimeout(1)\r\n    try:\r\n        clientSocket.sendto(request, (address, port))\r\n        data, addr = clientSocket.recvfrom(65507)\r\n        res =  responseHandler(data, addr, groupManager)\r\n    #TODO except socket.timeout\r\n    #TODO for better exception handling fix later.\r\n    except:\r\n        return False\r\n\r\n\r\n\r\n\r\n\r\n\r\n
----Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
----<+>UTF-8
----===================================================================
----diff --git a/Networking.py b/Networking.py
------- a/Networking.py	(revision eb1af266a92df274ea941fc2d7650a768d83cbcb)
----+++ b/Networking.py	(date 1648483944905)
----@@ -101,7 +101,8 @@
----         res =  responseHandler(data, addr, groupManager)
----     #TODO except socket.timeout
----     #TODO for better exception handling fix later.
-----    except:
----+    except Exception as e:
----+        print(e)
----         return False
---- 
---- 
---Index: .idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM_[Changes]/shelved.patch
---===================================================================
---diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM_[Changes]/shelved.patch
---deleted file mode 100644
------ a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM_[Changes]/shelved.patch	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---@@ -1,119 +0,0 @@
----Index: main.py
----IDEA additional info:
----Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
----<+>import json\r\nfrom json import *\r\nimport logging\r\nimport threading\r\nfrom pickle import dumps, loads\r\nfrom flask import Flask, render_template, request, redirect\r\nimport compress\r\nfrom Networking import receiver, sendRequest, JoinRequest\r\nfrom Groups import GroupManager, Invite\r\nfrom Client import Client\r\nimport easygui\r\nfrom bundles import BundleManager\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = False\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    return render_template(\"index.html\", groups=groupManager.groups)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    print(\"Group page request :\", group)\r\n    group = groupManager.getGroup(group)\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    # TODO Start downloading\r\n    return \"alright\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        print(str(group))\r\n        # TODO IP SPECIFIC BLOCKCHAIN\r\n        ip = data[\"ip\"]\r\n        print(\"Generate Invite for :\", group)\r\n        group = groupManager.getGroup(group)\r\n        print(group)\r\n        invite = group.generateInvite()\r\n        return compress.compress(invite.toJSON())\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        inviteDecomp = compress.decompress(invite)\r\n        inviteLoad = json.loads(inviteDecomp)\r\n        invite = Invite(inviteLoad[\"id\"],inviteLoad[\"name\"], inviteLoad[\"timestamp\"], inviteLoad[\"peers\"])\r\n        joinReq = JoinRequest(invite.name, invite.timestamp)\r\n        # TODO PORTS\r\n        print(invite.peers)\r\n        for peer in invite.peers:\r\n            print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq), groupManager)\r\n            group = res.group\r\n            group = Groups.Group(group.name,group.private,group.admins,group.peers,group.timestamp)\r\n            groupManager.addGroup(group)\r\n        return \"1\"\r\n\r\n\r\n@app.route('/shareBundle', methods=['POST'])\r\ndef shareBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"bundleName\"]\r\n        desc = data[\"bundleDescription\"]\r\n        groupName = data[\"groupName\"]\r\n        print(name)\r\n        print(desc)\r\n        print(groupName)\r\n        path = easygui.diropenbox(msg=\"Select folder to share as bundle\", title=\"Share Bundle\")\r\n        bundle = bundleManager.createBundle(name,desc,path=path)\r\n        groupManager.addBundle(bundle,groupName)\r\n        return \"0\"\r\n\r\n@app.route('/searchBundles', methods=['POST'])\r\ndef searchBundles():\r\n    print(\"Search Bundles Route\")\r\n    if request.method == 'POST':\r\n        data = request.form\r\n\r\n        #Get Keywords from search\r\n        keywords = data[\"searchKeyWords\"].split()\r\n        print(keywords)\r\n\r\n        #Get Group\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroup(group)\r\n        print(group)\r\n\r\n        joinReq = SearchBundleRequest(group.id,keywords)\r\n        responses = []\r\n        for peer in group.peers:\r\n            print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq), groupManager)\r\n            responses.append(res)\r\n        #WITH RESPONSES DO STUFF.\r\n        for x in responses:\r\n            print(x)\r\n\r\n\r\n\r\n\r\n        #Respond\r\n        return render_template(\"search.html\", groups=groupManager.groups, group=group)\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n        if data[\"private\"]:\r\n            private = 1\r\n        else:\r\n            private = 0\r\n    if groupManager.createGroup(name, private, [client.publicIP]):\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n\r\n@app.route('/quitGroup', methods=['POST'])\r\ndef quitGroup():\r\n    print('QUIT GROUP REQ')\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        if groupManager.quitGroup(group):\r\n            # True\r\n            return \"0\"\r\n        else:\r\n            # False\r\n            return \"1\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    groupManager = GroupManager()\r\n    bundleManager = BundleManager()\r\n    receiver = threading.Thread(target=receiver, args=[groupManager])\r\n    receiver.start()\r\n    app.run(host='', port=6969)\r\n
----Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
----<+>UTF-8
----===================================================================
----diff --git a/main.py b/main.py
------- a/main.py	(revision f0294b2ecb648f959712af555b1864294106d67c)
----+++ b/main.py	(date 1648481256246)
----@@ -5,8 +5,8 @@
---- from pickle import dumps, loads
---- from flask import Flask, render_template, request, redirect
---- import compress
-----from Networking import receiver, sendRequest, JoinRequest
-----from Groups import GroupManager, Invite
----+from Networking import receiver, sendRequest, JoinRequest, SearchBundleRequest
----+from Groups import GroupManager, Invite, Group
---- from Client import Client
---- import easygui
---- from bundles import BundleManager
----@@ -62,7 +62,7 @@
----         invite = data["invite"]
----         inviteDecomp = compress.decompress(invite)
----         inviteLoad = json.loads(inviteDecomp)
-----        invite = Invite(inviteLoad["id"],inviteLoad["name"], inviteLoad["timestamp"], inviteLoad["peers"])
----+        invite = Invite(inviteLoad["id"], inviteLoad["name"], inviteLoad["timestamp"], inviteLoad["peers"])
----         joinReq = JoinRequest(invite.name, invite.timestamp)
----         # TODO PORTS
----         print(invite.peers)
----@@ -70,7 +70,7 @@
----             print(peer[0])
----             res = sendRequest(peer[0], 6700, dumps(joinReq), groupManager)
----             group = res.group
-----            group = Groups.Group(group.name,group.private,group.admins,group.peers,group.timestamp)
----+            group = Group(group.name, group.private, group.admins, group.peers, group.timestamp)
----             groupManager.addGroup(group)
----         return "1"
---- 
----@@ -86,41 +86,40 @@
----         print(desc)
----         print(groupName)
----         path = easygui.diropenbox(msg="Select folder to share as bundle", title="Share Bundle")
-----        bundle = bundleManager.createBundle(name,desc,path=path)
-----        groupManager.addBundle(bundle,groupName)
----+        bundle = bundleManager.createBundle(name, desc, path=path)
----+        groupManager.addBundle(bundle, groupName)
----         return "0"
---- 
----+
---- @app.route('/searchBundles', methods=['POST'])
---- def searchBundles():
----     print("Search Bundles Route")
----     if request.method == 'POST':
----         data = request.form
---- 
-----        #Get Keywords from search
----+        # Get Keywords from search
----         keywords = data["searchKeyWords"].split()
----         print(keywords)
---- 
-----        #Get Group
----+        # Get Group
----         group = data["group"]
----         group = groupManager.getGroup(group)
----         print(group)
---- 
-----        joinReq = SearchBundleRequest(group.id,keywords)
----+        joinReq = SearchBundleRequest(group.id, keywords)
----         responses = []
----         for peer in group.peers:
----             print(peer[0])
----             res = sendRequest(peer[0], 6700, dumps(joinReq), groupManager)
----             responses.append(res)
-----        #WITH RESPONSES DO STUFF.
----+        # WITH RESPONSES DO STUFF.
----         for x in responses:
-----            print(x)
-----
-----
-----
----+            print("Response:",x)
---- 
-----        #Respond
----+        # Respond
----         return render_template("search.html", groups=groupManager.groups, group=group)
---- 
----+
---- @app.route('/createGroup', methods=['POST'])
---- def createGroup():
----     if request.method == 'POST':
----Index: Networking.py
----IDEA additional info:
----Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
----<+>import socket\r\nfrom socket import *\r\nimport pickle\r\nimport copy\r\nimport Groups\r\nfrom Groups import Group\r\n\r\n\r\nclass Request:\r\n    def __init__(self,type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self,name,timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self,group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\nclass SearchBundleRequest(Request):\r\n    def __init__(self, groupId, keyword):\r\n        super().__init__(2)\r\n        self.groupID = groupId\r\n        self.keywords = keyword\r\n\r\nclass SearchBundleResponse(Request):\r\n    def __init__(self,groups):\r\n        super().__init__(2)\r\n        self.responseBundles = responseBundles\r\n\r\ndef requestHandler(data, addr, groupManager: Groups.GroupManager):\r\n    req = pickle.loads(data)\r\n    # Response to JoinRequest\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name,req.timestamp)\r\n        #TODO If this is allowed add peer and respond\r\n        #TODO Peer Port\r\n        groupManager.addPeerGroup(req.name,[addr[0]])\r\n        group = groupManager.getGroup(req.name)\r\n        groupCpy = copy.copy(group)\r\n        del groupCpy.bundles\r\n        joinResponse = JoinResponse(groupCpy)\r\n        return pickle.dumps(joinResponse)\r\n\r\n    elif req.type == 2:\r\n        #Create The Request again for local use\r\n        req = SearchBundleRequest(req.groupID,req.keywords)\r\n        #Get All Bundles User has\r\n        bundlesOfGroup = groupManager.getGroupWithID(req.groupID).bundles\r\n        #Bundles to reply\r\n        responseBundles = []\r\n        for bundle in bundlesOfGroup:\r\n            #For each bundle make a single list (bundleKeywords) and search if any of the keywords other user send are in there then send back\r\n            name = bundle.name.split()\r\n            desc = bundle.description.split()\r\n            bundleKeywords = name + desc\r\n            if any(keyword in req.keywords for keyword in bundleKeywords):\r\n                responseBundles.append({\"id\":bundle.id,\"name\":bundle.name,\"description\":bundle.description})\r\n        #Create Response and return it to be used as answer\r\n        searchResponse = SearchBundleResponse(responseBundles)\r\n        return pickle.dumps(joinResponse)\r\n\r\ndef responseHandler(data, groupManager):\r\n    res = pickle.loads(data)\r\n\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        # group = res.group\r\n        # group = Groups.Group(group.name,group.private,group.admins,group.peers,group.timestamp)\r\n        # groupManager.addGroup(group)\r\n        return res\r\n\r\n    elif res.type == 2:\r\n        res = SearchBundleResponse(res.responseBundles)\r\n        return res\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        #RECEIVE AND RESPOND.\r\n        data, addr = sock.recvfrom(65507)\r\n        print(addr,data)\r\n        response = requestHandler(data,addr,groupManager)\r\n        sock.sendto(response,addr)\r\n\r\ndef sendRequest(address, port, request,groupManager):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.sendto(request, (address, port))\r\n    data, addr = clientSocket.recvfrom(65507)\r\n    return responseHandler(data, groupManager)\r\n\r\n\r\n\r\n
----Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
----<+>UTF-8
----===================================================================
----diff --git a/Networking.py b/Networking.py
------- a/Networking.py	(revision f0294b2ecb648f959712af555b1864294106d67c)
----+++ b/Networking.py	(date 1648481013611)
----@@ -31,7 +31,7 @@
----         self.keywords = keyword
---- 
---- class SearchBundleResponse(Request):
-----    def __init__(self,groups):
----+    def __init__(self,responseBundles):
----         super().__init__(2)
----         self.responseBundles = responseBundles
---- 
----@@ -65,7 +65,7 @@
----                 responseBundles.append({"id":bundle.id,"name":bundle.name,"description":bundle.description})
----         #Create Response and return it to be used as answer
----         searchResponse = SearchBundleResponse(responseBundles)
-----        return pickle.dumps(joinResponse)
----+        return pickle.dumps(searchResponse)
---- 
---- def responseHandler(data, groupManager):
----     res = pickle.loads(data)
---Index: .idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM__Changes_.xml
---===================================================================
---diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM__Changes_.xml
---deleted file mode 100644
------ a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM__Changes_.xml	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---@@ -1,4 +0,0 @@
----<changelist name="Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM_[Changes]" date="1648483827008" recycled="true" deleted="true">
----  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_7_10_PM_[Changes]/shelved.patch" />
----  <option name="DESCRIPTION" value="Uncommitted changes before Update at 28-Mar-22 7:10 PM [Changes]" />
----</changelist>
---\ No newline at end of file
---Index: .idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM_[Changes]/shelved.patch
---===================================================================
---diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM_[Changes]/shelved.patch
---deleted file mode 100644
------ a/.idea/shelf/Uncommitted_changes_before_Update_at_28-Mar-22_6_15_PM_[Changes]/shelved.patch	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---+++ /dev/null	(revision f923bc18abd1900d5712eebbcacf1d827f299b62)
---@@ -1,86 +0,0 @@
----Index: Networking.py
----IDEA additional info:
----Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
----<+>import socket\r\nfrom socket import *\r\nimport pickle\r\n\r\nimport Groups\r\n\r\n\r\nclass Request:\r\n    def __init__(self,type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self,name,timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self,group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\ndef requestHandler(data,addr,groupManager):\r\n    req = pickle.loads(data)\r\n    # Response to JoinRequest\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name,req.timestamp)\r\n        #TODO If this is allowed add peer and respond\r\n        #TODO Peer Port\r\n        groupManager.addPeerGroup(req.name,[addr[0]])\r\n        group = groupManager.getGroup(req.name)\r\n        return pickle.dumps(JoinResponse(group))\r\n\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        #RECEIVE AND RESPOND.\r\n        data, addr = sock.recvfrom(65507)\r\n        print(addr,data)\r\n        response = requestHandler(data,addr,groupManager)\r\n        sock.sendto(response,addr)\r\n\r\ndef sendRequest(address, port, request,groupManager):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.sendto(request, (address, port))\r\n    data, addr = clientSocket.recvfrom(65507)\r\n    responseHandler(data, groupManager)\r\n\r\ndef responseHandler(data, groupManager):\r\n    res = pickle.loads(data)\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        group = res.group\r\n        group = Groups.Group(group.name,group.private,group.admins,group.peers,group.timestamp)\r\n        groupManager.addGroup(group)\r\n\r\n
----Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
----<+>UTF-8
----===================================================================
----diff --git a/Networking.py b/Networking.py
------- a/Networking.py	(revision ab00bc1ff0d34c4135e74773e70cb04511a4b41c)
----+++ b/Networking.py	(date 1648291091876)
----@@ -6,31 +6,34 @@
---- 
---- 
---- class Request:
-----    def __init__(self,type):
----+    def __init__(self, type):
----         self.type = type
---- 
----     def toJSON(self):
----         return json.dumps(self.__dict__)
---- 
----+
---- class JoinRequest(Request):
-----    def __init__(self,name,timestamp):
----+    def __init__(self, name, timestamp):
----         super().__init__(1)
----         self.name = name
----         self.timestamp = timestamp
---- 
----+
---- class JoinResponse(Request):
-----    def __init__(self,group):
----+    def __init__(self, group):
----         super().__init__(1)
----         self.group = group
---- 
-----def requestHandler(data,addr,groupManager):
----+
----+def requestHandler(data, addr, groupManager):
----     req = pickle.loads(data)
----     # Response to JoinRequest
----     if req.type == 1:
-----        req = JoinRequest(req.name,req.timestamp)
-----        #TODO If this is allowed add peer and respond
-----        #TODO Peer Port
-----        groupManager.addPeerGroup(req.name,[addr[0]])
----+        req = JoinRequest(req.name, req.timestamp)
----+        # TODO If this is allowed add peer and respond
----+        # TODO Peer Port
----+        groupManager.addPeerGroup(req.name, [addr[0]])
----         group = groupManager.getGroup(req.name)
----         return pickle.dumps(JoinResponse(group))
---- 
----@@ -42,24 +45,25 @@
----     sock.bind((UDP_IP, UDP_PORT))
----     print("Listening on ", UDP_IP, ":", UDP_PORT)
----     while True:
-----        #RECEIVE AND RESPOND.
----+        # RECEIVE AND RESPOND.
----         data, addr = sock.recvfrom(65507)
-----        print(addr,data)
-----        response = requestHandler(data,addr,groupManager)
-----        sock.sendto(response,addr)
----+        print(addr, data)
----+        response = requestHandler(data, addr, groupManager)
----+        sock.sendto(response, addr)
---- 
-----def sendRequest(address, port, request,groupManager):
----+
----+def sendRequest(address, port, request, groupManager):
----     # Create a socket for sending files
----     clientSocket = socket(AF_INET, SOCK_DGRAM)
----     clientSocket.sendto(request, (address, port))
----     data, addr = clientSocket.recvfrom(65507)
----     responseHandler(data, groupManager)
---- 
----+
---- def responseHandler(data, groupManager):
----     res = pickle.loads(data)
----     if res.type == 1:
----         res = JoinResponse(res.group)
----         group = res.group
-----        group = Groups.Group(group.name,group.private,group.admins,group.peers,group.timestamp)
----+        group = Groups.Group(group.name, group.private, group.admins, group.peers, group.timestamp)
----         groupManager.addGroup(group)
-----
--Index: .idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM__Changes_.xml
--===================================================================
--diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM__Changes_.xml
--deleted file mode 100644
----- a/.idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM__Changes_.xml	(revision e93e724ace85a4e7a5d706e587d82e895584bb85)
--+++ /dev/null	(revision e93e724ace85a4e7a5d706e587d82e895584bb85)
--@@ -1,4 +0,0 @@
---<changelist name="Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM_[Changes]" date="1649508066242" recycled="true" deleted="true">
---  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_09-Apr-22_3_41_PM_[Changes]/shelved.patch" />
---  <option name="DESCRIPTION" value="Uncommitted changes before Update at 09-Apr-22 3:41 PM [Changes]" />
---</changelist>
--\ No newline at end of file
-Index: .idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM__Changes_.xml
-===================================================================
-diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM__Changes_.xml
-deleted file mode 100644
---- a/.idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM__Changes_.xml	(revision 397da46c4b816e67fbbc1f8b78f311f5a70ab115)
-+++ /dev/null	(revision 397da46c4b816e67fbbc1f8b78f311f5a70ab115)
-@@ -1,4 +0,0 @@
--<changelist name="Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM_[Changes]" date="1650197252334" recycled="true" deleted="true">
--  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_17-Apr-22_3_07_PM_[Changes]/shelved.patch" />
--  <option name="DESCRIPTION" value="Uncommitted changes before Update at 17-Apr-22 3:07 PM [Changes]" />
--</changelist>
-\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_39_AM__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_39_AM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_39_AM__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_39_AM__Changes_.xml	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_21-Apr-22_11_39_AM_[Changes]" date="1650530386349" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_39_AM_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 21-Apr-22 11:39 AM [Changes]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_53_AM__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_53_AM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_53_AM__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_53_AM__Changes_.xml	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_24-Apr-22_9_53_AM_[Changes]" date="1650783186142" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_9_53_AM_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 24-Apr-22 9:53 AM [Changes]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_48_PM__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_48_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_48_PM__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_48_PM__Changes_.xml	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_25-Apr-22_4_48_PM_[Changes]" date="1650894524533" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_25-Apr-22_4_48_PM_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 25-Apr-22 4:48 PM [Changes]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_39_AM_[Changes]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_39_AM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_39_AM_[Changes]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_11_39_AM_[Changes]/shelved.patch	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,262 +0,0 @@
-Index: .idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_28_PM__Changes_.xml
-===================================================================
-diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_28_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_28_PM__Changes_.xml
-deleted file mode 100644
---- a/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_28_PM__Changes_.xml	(revision 365212bf76cc9c06ecdb230b24205915feb26c24)
-+++ /dev/null	(revision 365212bf76cc9c06ecdb230b24205915feb26c24)
-@@ -1,4 +0,0 @@
--<changelist name="Uncommitted_changes_before_Update_at_10-Apr-22_6_28_PM_[Changes]" date="1649604533606" recycled="true" deleted="true">
--  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_28_PM_[Changes]/shelved.patch" />
--  <option name="DESCRIPTION" value="Uncommitted changes before Update at 10-Apr-22 6:28 PM [Changes]" />
--</changelist>
-\ No newline at end of file
-Index: .idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_5_28_PM_[Changes]/shelved.patch
-===================================================================
-diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_5_28_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_5_28_PM_[Changes]/shelved.patch
-deleted file mode 100644
---- a/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_5_28_PM_[Changes]/shelved.patch	(revision 365212bf76cc9c06ecdb230b24205915feb26c24)
-+++ /dev/null	(revision 365212bf76cc9c06ecdb230b24205915feb26c24)
-@@ -1,159 +0,0 @@
--Index: Networking.py
--IDEA additional info:
--Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
--<+>import copy\r\nimport json\r\nimport pickle\r\nimport socket\r\nimport threading\r\nfrom socket import *\r\nfrom Bundles import Bundle\r\nimport Client\r\nfrom Groups import GroupManager, Group\r\n\r\n\r\nclass Request:\r\n    def __init__(self, type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\n#All Classes extended Request even Response Classes just for type and toJSON method.\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self, name, timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self, group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\n\r\nclass SearchBundleRequest(Request):\r\n    def __init__(self, groupId, keyword):\r\n        super().__init__(2)\r\n        self.groupID = groupId\r\n        self.keywords = keyword\r\n\r\n\r\nclass SearchBundleResponse(Request):\r\n    def __init__(self, responseBundles):\r\n        super().__init__(2)\r\n        self.responseBundles = responseBundles\r\n\r\n\r\nclass GetBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId, portForBundleReceiver):\r\n        super().__init__(3)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.portForBundleReceiver = portForBundleReceiver\r\n\r\n\r\nclass GetBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(3)\r\n        self.answer = answer\r\n\r\n\r\nclass CheckBundleAvailabilityRequest(Request):\r\n    def __init__(self,bundleId, groupId):\r\n        super().__init__(4)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n\r\nclass CheckBundleAvailabilityResponse(Request):\r\n    def __init__(self,answer):\r\n        super().__init__(4)\r\n        self.answer = answer\r\n\r\n\r\nclass DownloadBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId,file, port):\r\n        super().__init__(5)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.file = file\r\n        self.port = port\r\n\r\n\r\nclass DownloadBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(5)\r\n        self.answer = answer\r\n\r\n\r\n\r\ndef requestHandler(data, addr, groupManager: GroupManager):\r\n    req = pickle.loads(data)\r\n    print(req)\r\n\r\n    # Response to JoinRequest\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name, req.timestamp)\r\n        # TODO If this is allowed add peer and respond\r\n        # TODO Peer Port\r\n        groupManager.addPeerGroup(req.name, [addr[0]])\r\n        group = groupManager.getGroupWithName(req.name)\r\n        groupCpy = copy.copy(group)\r\n        del groupCpy.bundles\r\n        joinResponse = JoinResponse(groupCpy)\r\n        return pickle.dumps(joinResponse)\r\n\r\n    # Response to search req\r\n    elif req.type == 2:\r\n        # Create The Request again for local use\r\n        req = SearchBundleRequest(req.groupID, req.keywords)\r\n        # Get All Bundles User has\r\n        bundlesOfGroup = groupManager.getGroupWithId(req.groupID).bundles\r\n        # Bundles to reply\r\n        responseBundles = []\r\n        print(responseBundles)\r\n        for bundle in bundlesOfGroup:\r\n            # For each bundle make a single list (bundleKeywords) and search if any of the keywords other user send are in there then send back\r\n            name = bundle.name.split()\r\n            desc = bundle.description.split()\r\n            bundleKeywords = name + desc\r\n            # print(\"Bundle Keywords : \",bundleKeywords)\r\n            # print(\"Request Keywords : \",req.keywords)\r\n            if any(keyword in req.keywords for keyword in bundleKeywords):\r\n                # print(\"HIT\")\r\n                responseBundles.append({\"id\": bundle.id, \"name\": bundle.name, \"description\": bundle.description})\r\n        # Create Response and return it to be used as answer\r\n        # print(responseBundles)\r\n        searchResponse = SearchBundleResponse(responseBundles)\r\n        # print(\"Search Response :\",searchResponse)\r\n        return pickle.dumps(searchResponse)\r\n\r\n    elif req.type == 3:\r\n        req = GetBundleRequest(req.bundleId, req.groupId, req.portForBundleReceiver)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        bundle = group.getBundleWithId(req.bundleId)\r\n        bundleReceiver = threading.Thread(target=sendBundle,\r\n                                          args=[addr, req.portForBundleReceiver, groupManager, group, bundle])\r\n        bundleReceiver.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        #TODO 9/4 ????\r\n        return pickle.dumps(GetBundleResponse(1))\r\n\r\n    elif req.type == 4:\r\n        req = CheckBundleAvailabilityRequest(req.bundleId, req.groupId)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        bundle = group.getBundleWithId(req.bundleId)\r\n        if bundle is False:\r\n            #Not Found\r\n            return pickle.dumps(CheckBundleAvailabilityResponse(0))\r\n        else :\r\n            #Found\r\n            return pickle.dumps(CheckBundleAvailabilityResponse(1))\r\n\r\n    elif req.type == 5:\r\n        print(\"Received Request To Send File\")\r\n        req = DownloadBundleRequest(req.bundleId, req.groupId, req.file,req.port)\r\n        uploadThread = threading.Thread(target=uploadBundle,\r\n                                          args=[addr, req.port,])\r\n        uploadThread.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        #TODO 9/4 ????\r\n        return pickle.dumps(DownloadBundleResponse(1))\r\n\r\ndef responseHandler(data, groupManager):\r\n    res = pickle.loads(data)\r\n\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        return res\r\n\r\n    elif res.type == 2:\r\n        res = SearchBundleResponse(res.responseBundles)\r\n        return res\r\n\r\n    elif res.type == 3:\r\n        res = SearchBundleResponse(res.answer)\r\n        return res\r\n\r\n    elif res.type == 4:\r\n        res = CheckBundleAvailabilityResponse(res.answer)\r\n        return res\r\n\r\n    elif res.type == 5:\r\n        res = DownloadBundleResponse(res.answer)\r\n        return res\r\n\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        # RECEIVE AND RESPOND.\r\n        data, addr = sock.recvfrom(65537)\r\n        # data, addr = sock.recvfrom(65507)\r\n        print(\"Received from :\", addr)\r\n        response = requestHandler(data, addr, groupManager)\r\n        sock.sendto(response, addr)\r\n\r\n\r\ndef sendRequest(address, port, request, groupManager):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.settimeout(1)\r\n    try:\r\n        clientSocket.sendto(request, (address, port))\r\n        data, addr = clientSocket.recvfrom(65537)\r\n        # data, addr = clientSocket.recvfrom(65507)\r\n        res = responseHandler(data, groupManager)\r\n        return res\r\n    # TODO except socket.timeout\r\n    # TODO for better exception handling fix later.\r\n    except Exception as exception:\r\n        # print(\"Exception on SendRequest:\", exception)\r\n        return False\r\n\r\n\r\ndef receiveBundle(port,client,groupManager,groupId,downloadManager):\r\n    print(\"RECEIVING BUNDLE THREAD\")\r\n    bundleBytes = b\"\"\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.bind((\"0.0.0.0\", port))\r\n        print(\"Bundle Receiver Ready\")\r\n        s.listen()\r\n        conn, addr = s.accept()\r\n        with conn:\r\n            print(f\"Connected by {addr}\")\r\n            while True:\r\n                data = conn.recv(1024)\r\n                # print(data)\r\n                bundleBytes = bundleBytes + data\r\n                #TODO save Bytes to group and downloads also start downloading.\r\n                if not data:\r\n                    # print(\"Break\")\r\n                    break\r\n            # print(\"Break3\")\r\n    # print(\"Bundle Str\",bundleBytes.decode())\r\n    bundleObj = json.loads(bundleBytes.decode())\r\n    #Fix Bundle Root to be downloaded and location\r\n    client : Client.Client\r\n    bundleObj[\"root\"] =client.DIR_PATH_DOWNLOADS\r\n    bundle = Bundle(bundleObj[\"name\"],bundleObj[\"description\"],bundleObj[\"id\"],bundleObj[\"timestamp\"],bundleObj[\"root\"],bundleObj[\"pieceSize\"],bundleObj[\"files\"])\r\n    group = groupManager.getGroupWithId(groupId)\r\n    groupManager.addBundle(bundle,group.name)\r\n    downloadManager.downloadBundle(bundle,group)\r\n\r\n\r\ndef sendBundle(addr, port, groupManager, group, bundle):\r\n    print(\"SENDING BUNDLE THREAD\")\r\n    group: Group\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.connect((addr[0], port))\r\n        print(\"SENDING DATA\")\r\n        groupManager: GroupManager\r\n        json_file_name = bundle.name + \".json\"\r\n        bundleDir = groupManager.DIR_PATH_GROUPS + group.name + \"\\\\\" + \"Bundles\" + \"\\\\\" + json_file_name\r\n        print(bundleDir)\r\n        print(json_file_name)\r\n        with open(bundleDir) as f:\r\n            bundleContent = f.read()\r\n            bundleObj = json.loads(bundleContent)\r\n            bundleObj[\"root\"] = \"\"\r\n            bundleStr = json.dumps(bundleObj)\r\n\r\n        s.sendall(bundleStr.encode())\r\n\r\ndef is_port_in_use(port: int) -> bool:\r\n    import socket\r\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\r\n        return s.connect_ex(('localhost', port)) == 0\r\n\r\n\r\ndef downloadBundle(port, peer,file,bundle,usedPeers,freeFiles):\r\n    print(\"DOWNLOADING BUNDLE THREAD\")\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.bind((\"0.0.0.0\", port))\r\n        print(\"Bundle Receiver Ready\")\r\n        s.listen()\r\n        conn, addr = s.accept()\r\n        with conn:\r\n            print(f\"Connected by {addr} to download file.\")\r\n            while True:\r\n                data = conn.recv(1024)\r\n\r\n\r\n\r\ndef uploadBundle(addr, port):\r\n    print(\"SENDING BUNDLE THREAD\")\r\n    group: Group\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.connect((addr[0], port))\r\n        print(\"SENDING DATA\")\r\n        s.sendall(\"Test Sent\".encode())
--Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
--<+>UTF-8
--===================================================================
--diff --git a/Networking.py b/Networking.py
----- a/Networking.py	(revision beb9fd7da096846436c5d953789c54e431ddaf25)
--+++ b/Networking.py	(date 1649597627838)
--@@ -16,7 +16,8 @@
--     def toJSON(self):
--         return json.dumps(self.__dict__)
-- 
---#All Classes extended Request even Response Classes just for type and toJSON method.
--+
--+# All Classes extended Request even Response Classes just for type and toJSON method.
-- 
-- class JoinRequest(Request):
--     def __init__(self, name, timestamp):
--@@ -59,19 +60,20 @@
-- 
-- 
-- class CheckBundleAvailabilityRequest(Request):
---    def __init__(self,bundleId, groupId):
--+    def __init__(self, bundleId, groupId):
--         super().__init__(4)
--         self.bundleId = bundleId
--         self.groupId = groupId
-- 
--+
-- class CheckBundleAvailabilityResponse(Request):
---    def __init__(self,answer):
--+    def __init__(self, answer):
--         super().__init__(4)
--         self.answer = answer
-- 
-- 
-- class DownloadBundleRequest(Request):
---    def __init__(self, bundleId, groupId,file, port):
--+    def __init__(self, bundleId, groupId, file, port):
--         super().__init__(5)
--         self.bundleId = bundleId
--         self.groupId = groupId
--@@ -85,7 +87,6 @@
--         self.answer = answer
-- 
-- 
---
-- def requestHandler(data, addr, groupManager: GroupManager):
--     req = pickle.loads(data)
--     print(req)
--@@ -135,7 +136,7 @@
--                                           args=[addr, req.portForBundleReceiver, groupManager, group, bundle])
--         bundleReceiver.start()
--         # TODO refactor use it to determine if user ok to send bundle
---        #TODO 9/4 ????
--+        # TODO 9/4 ????
--         return pickle.dumps(GetBundleResponse(1))
-- 
--     elif req.type == 4:
--@@ -143,22 +144,23 @@
--         group = groupManager.getGroupWithId(req.groupId)
--         bundle = group.getBundleWithId(req.bundleId)
--         if bundle is False:
---            #Not Found
--+            # Not Found
--             return pickle.dumps(CheckBundleAvailabilityResponse(0))
---        else :
---            #Found
--+        else:
--+            # Found
--             return pickle.dumps(CheckBundleAvailabilityResponse(1))
-- 
--     elif req.type == 5:
--         print("Received Request To Send File")
---        req = DownloadBundleRequest(req.bundleId, req.groupId, req.file,req.port)
--+        req = DownloadBundleRequest(req.bundleId, req.groupId, req.file, req.port)
--         uploadThread = threading.Thread(target=uploadBundle,
---                                          args=[addr, req.port,])
--+                                        args=[addr, req.port, ])
--         uploadThread.start()
--         # TODO refactor use it to determine if user ok to send bundle
---        #TODO 9/4 ????
--+        # TODO 9/4 ????
--         return pickle.dumps(DownloadBundleResponse(1))
-- 
--+
-- def responseHandler(data, groupManager):
--     res = pickle.loads(data)
-- 
--@@ -215,7 +217,7 @@
--         return False
-- 
-- 
---def receiveBundle(port,client,groupManager,groupId,downloadManager):
--+def receiveBundle(port, client, groupManager, groupId, downloadManager):
--     print("RECEIVING BUNDLE THREAD")
--     bundleBytes = b""
--     with socket(AF_INET, SOCK_STREAM) as s:
--@@ -229,20 +231,21 @@
--                 data = conn.recv(1024)
--                 # print(data)
--                 bundleBytes = bundleBytes + data
---                #TODO save Bytes to group and downloads also start downloading.
--+                # TODO save Bytes to group and downloads also start downloading.
--                 if not data:
--                     # print("Break")
--                     break
--             # print("Break3")
--     # print("Bundle Str",bundleBytes.decode())
--     bundleObj = json.loads(bundleBytes.decode())
---    #Fix Bundle Root to be downloaded and location
---    client : Client.Client
---    bundleObj["root"] =client.DIR_PATH_DOWNLOADS
---    bundle = Bundle(bundleObj["name"],bundleObj["description"],bundleObj["id"],bundleObj["timestamp"],bundleObj["root"],bundleObj["pieceSize"],bundleObj["files"])
--+    # Fix Bundle Root to be downloaded and location
--+    client: Client.Client
--+    bundleObj["root"] = client.DIR_PATH_DOWNLOADS
--+    bundle = Bundle(bundleObj["name"], bundleObj["description"], bundleObj["id"], bundleObj["timestamp"],
--+                    bundleObj["root"], bundleObj["pieceSize"], bundleObj["files"])
--     group = groupManager.getGroupWithId(groupId)
---    groupManager.addBundle(bundle,group.name)
---    downloadManager.downloadBundle(bundle,group)
--+    groupManager.addBundle(bundle, group.name)
--+    downloadManager.downloadBundle(bundle, group)
-- 
-- 
-- def sendBundle(addr, port, groupManager, group, bundle):
--@@ -264,13 +267,14 @@
-- 
--         s.sendall(bundleStr.encode())
-- 
--+
-- def is_port_in_use(port: int) -> bool:
--     import socket
--     with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
--         return s.connect_ex(('localhost', port)) == 0
-- 
-- 
---def downloadBundle(port, peer,file,bundle,usedPeers,freeFiles):
--+def downloadBundle(port, peer, file, bundle, usedPeers, freeFiles):
--     print("DOWNLOADING BUNDLE THREAD")
--     with socket(AF_INET, SOCK_STREAM) as s:
--         s.bind(("0.0.0.0", port))
--@@ -283,11 +287,10 @@
--                 data = conn.recv(1024)
-- 
-- 
---
-- def uploadBundle(addr, port):
--     print("SENDING BUNDLE THREAD")
--     group: Group
--     with socket(AF_INET, SOCK_STREAM) as s:
--         s.connect((addr[0], port))
--         print("SENDING DATA")
---        s.sendall("Test Sent".encode())
--\ No newline at end of file
--+        s.sendall("Test Sent".encode())
-Index: .idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_03_PM_[Changes]/shelved.patch
-===================================================================
-diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_03_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_03_PM_[Changes]/shelved.patch
-deleted file mode 100644
---- a/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_03_PM_[Changes]/shelved.patch	(revision 365212bf76cc9c06ecdb230b24205915feb26c24)
-+++ /dev/null	(revision 365212bf76cc9c06ecdb230b24205915feb26c24)
-@@ -1,19 +0,0 @@
--Index: Networking.py
--IDEA additional info:
--Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
--<+>import copy\r\nimport json\r\nimport pickle\r\nimport socket\r\nimport threading\r\nfrom socket import *\r\nfrom Bundles import Bundle\r\nimport Client\r\nfrom Groups import GroupManager, Group\r\nimport os\r\n\r\n\r\nclass Request:\r\n    def __init__(self, type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\n\r\n# All Classes extended Request even Response Classes just for type and toJSON method.\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self, name, timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self, group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\n\r\nclass SearchBundleRequest(Request):\r\n    def __init__(self, groupId, keyword):\r\n        super().__init__(2)\r\n        self.groupID = groupId\r\n        self.keywords = keyword\r\n\r\n\r\nclass SearchBundleResponse(Request):\r\n    def __init__(self, responseBundles):\r\n        super().__init__(2)\r\n        self.responseBundles = responseBundles\r\n\r\n\r\nclass GetBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId, portForBundleReceiver):\r\n        super().__init__(3)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.portForBundleReceiver = portForBundleReceiver\r\n\r\n\r\nclass GetBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(3)\r\n        self.answer = answer\r\n\r\n\r\nclass CheckBundleAvailabilityRequest(Request):\r\n    def __init__(self, bundleId, groupId):\r\n        super().__init__(4)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n\r\n\r\nclass CheckBundleAvailabilityResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(4)\r\n        self.answer = answer\r\n\r\n\r\nclass DownloadBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId, file, port):\r\n        super().__init__(5)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.file = file\r\n        self.port = port\r\n\r\n\r\nclass DownloadBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(5)\r\n        self.answer = answer\r\n\r\n\r\ndef requestHandler(data, addr, groupManager: GroupManager):\r\n    req = pickle.loads(data)\r\n    print(req)\r\n\r\n    # Response to JoinRequest\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name, req.timestamp)\r\n        # TODO If this is allowed add peer and respond\r\n        # TODO Peer Port\r\n        groupManager.addPeerGroup(req.name, [addr[0]])\r\n        group = groupManager.getGroupWithName(req.name)\r\n        groupCpy = copy.copy(group)\r\n        del groupCpy.bundles\r\n        joinResponse = JoinResponse(groupCpy)\r\n        return pickle.dumps(joinResponse)\r\n\r\n    # Response to search req\r\n    elif req.type == 2:\r\n        # Create The Request again for local use\r\n        req = SearchBundleRequest(req.groupID, req.keywords)\r\n        # Get All Bundles User has\r\n        bundlesOfGroup = groupManager.getGroupWithId(req.groupID).bundles\r\n        # Bundles to reply\r\n        responseBundles = []\r\n        print(responseBundles)\r\n        for bundle in bundlesOfGroup:\r\n            # For each bundle make a single list (bundleKeywords) and search if any of the keywords other user send are in there then send back\r\n            name = bundle.name.split()\r\n            desc = bundle.description.split()\r\n            bundleKeywords = name + desc\r\n            # print(\"Bundle Keywords : \",bundleKeywords)\r\n            # print(\"Request Keywords : \",req.keywords)\r\n            if any(keyword in req.keywords for keyword in bundleKeywords):\r\n                # print(\"HIT\")\r\n                responseBundles.append({\"id\": bundle.id, \"name\": bundle.name, \"description\": bundle.description})\r\n        # Create Response and return it to be used as answer\r\n        # print(responseBundles)\r\n        searchResponse = SearchBundleResponse(responseBundles)\r\n        # print(\"Search Response :\",searchResponse)\r\n        return pickle.dumps(searchResponse)\r\n\r\n    elif req.type == 3:\r\n        req = GetBundleRequest(req.bundleId, req.groupId, req.portForBundleReceiver)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        bundle = group.getBundleWithId(req.bundleId)\r\n        bundleReceiver = threading.Thread(target=sendBundle,\r\n                                          args=[addr, req.portForBundleReceiver, groupManager, group, bundle])\r\n        bundleReceiver.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        # TODO 9/4 ????\r\n        return pickle.dumps(GetBundleResponse(1))\r\n\r\n    elif req.type == 4:\r\n        req = CheckBundleAvailabilityRequest(req.bundleId, req.groupId)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        bundle = group.getBundleWithId(req.bundleId)\r\n        if bundle is False:\r\n            # Not Found\r\n            return pickle.dumps(CheckBundleAvailabilityResponse(0))\r\n        else:\r\n            # Found\r\n            return pickle.dumps(CheckBundleAvailabilityResponse(1))\r\n\r\n    elif req.type == 5:\r\n        print(\"Received Request To Send File\")\r\n        req = DownloadBundleRequest(req.bundleId, req.groupId, req.file, req.port)\r\n        uploadThread = threading.Thread(target=uploadBundle,\r\n                                        args=[addr, req.port, req.bundleId, req.groupId, req.file, groupManager])\r\n        uploadThread.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        # TODO 9/4 ????\r\n        return pickle.dumps(DownloadBundleResponse(1))\r\n\r\n\r\ndef responseHandler(data, groupManager):\r\n    res = pickle.loads(data)\r\n\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        return res\r\n\r\n    elif res.type == 2:\r\n        res = SearchBundleResponse(res.responseBundles)\r\n        return res\r\n\r\n    elif res.type == 3:\r\n        res = SearchBundleResponse(res.answer)\r\n        return res\r\n\r\n    elif res.type == 4:\r\n        res = CheckBundleAvailabilityResponse(res.answer)\r\n        return res\r\n\r\n    elif res.type == 5:\r\n        res = DownloadBundleResponse(res.answer)\r\n        return res\r\n\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        # RECEIVE AND RESPOND.\r\n        data, addr = sock.recvfrom(65537)\r\n        # data, addr = sock.recvfrom(65507)\r\n        print(\"Received from :\", addr)\r\n        response = requestHandler(data, addr, groupManager)\r\n        sock.sendto(response, addr)\r\n\r\n\r\ndef sendRequest(address, port, request, groupManager):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.settimeout(1)\r\n    try:\r\n        clientSocket.sendto(request, (address, port))\r\n        data, addr = clientSocket.recvfrom(65537)\r\n        # data, addr = clientSocket.recvfrom(65507)\r\n        res = responseHandler(data, groupManager)\r\n        return res\r\n    # TODO except socket.timeout\r\n    # TODO for better exception handling fix later.\r\n    except Exception as exception:\r\n        # print(\"Exception on SendRequest:\", exception)\r\n        return False\r\n\r\n\r\ndef receiveBundle(port, client, groupManager, groupId, downloadManager):\r\n    print(\"RECEIVING BUNDLE THREAD\")\r\n    bundleBytes = b\"\"\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.bind((\"0.0.0.0\", port))\r\n        print(\"Bundle Receiver Ready\")\r\n        s.listen()\r\n        conn, addr = s.accept()\r\n        with conn:\r\n            print(f\"Connected by {addr}\")\r\n            while True:\r\n                data = conn.recv(1024)\r\n                # print(data)\r\n                bundleBytes = bundleBytes + data\r\n                # TODO save Bytes to group and downloads also start downloading.\r\n                if not data:\r\n                    # print(\"Break\")\r\n                    break\r\n            # print(\"Break3\")\r\n    # print(\"Bundle Str\",bundleBytes.decode())\r\n    bundleObj = json.loads(bundleBytes.decode())\r\n    # Fix Bundle Root to be downloaded and location\r\n    client: Client.Client\r\n    bundleObj[\"root\"] = client.DIR_PATH_DOWNLOADS\r\n    bundle = Bundle(bundleObj[\"name\"], bundleObj[\"description\"], bundleObj[\"id\"], bundleObj[\"timestamp\"],\r\n                    bundleObj[\"root\"], bundleObj[\"pieceSize\"], bundleObj[\"files\"])\r\n    group = groupManager.getGroupWithId(groupId)\r\n    groupManager.addBundle(bundle, group.name)\r\n    downloadManager.downloadBundle(bundle, group)\r\n\r\n\r\ndef sendBundle(addr, port, groupManager, group, bundle):\r\n    print(\"SENDING BUNDLE THREAD\")\r\n    group: Group\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.connect((addr[0], port))\r\n        print(\"SENDING DATA\")\r\n        groupManager: GroupManager\r\n        json_file_name = bundle.name + \".json\"\r\n        bundleDir = groupManager.DIR_PATH_GROUPS + group.name + \"\\\\\" + \"Bundles\" + \"\\\\\" + json_file_name\r\n        print(bundleDir)\r\n        print(json_file_name)\r\n        with open(bundleDir) as f:\r\n            bundleContent = f.read()\r\n            bundleObj = json.loads(bundleContent)\r\n            bundleObj[\"root\"] = \"\"\r\n            bundleStr = json.dumps(bundleObj)\r\n\r\n        s.sendall(bundleStr.encode())\r\n\r\n\r\ndef is_port_in_use(port: int) -> bool:\r\n    import socket\r\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\r\n        return s.connect_ex(('localhost', port)) == 0\r\n\r\n\r\ndef downloadBundle(port, peer, file, bundle, usedPeers, freeFiles):\r\n    bundle: BundleToDownload\r\n    pieceList = []\r\n    #Find pieces missing\r\n    for x in bundle.files:\r\n        if x[\"path\"] == file[0]:\r\n            pieceList = x[\"pieces\"]\r\n            break\r\n    # pieceList = [[0, '5920572cf97d3711a77a9b7a3469a5fd03bb2a8a', 0]]\r\n    print(\"DOWNLOADING BUNDLE THREAD\")\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.bind((\"0.0.0.0\", port))\r\n        print(\"Bundle Receiver Ready\")\r\n        s.listen()\r\n        conn, addr = s.accept()\r\n        with conn:\r\n            print(f\"Connected by {addr} to download file.\")\r\n            data = conn.recv(1024)\r\n            if data.decode() == \"OK\":\r\n                for piece in pieceList:\r\n                    if piece[2]==0:\r\n                        s.sendall(piece[0])\r\n                        data = s.recv(100000)\r\n                        print(data)\r\n\r\n\r\n\r\n\r\ndef uploadBundle(addr, port, bundleId, groupId, file, groupManager):\r\n    print(\"SENDING BUNDLE THREAD\")\r\n    group = groupManager.getGroupWithId(groupId)\r\n    bundle = group.getBundleWithId(bundleId)\r\n    with open(bundle.root+file, 'rb') as openfileobject:\r\n        with socket(AF_INET, SOCK_STREAM) as s:\r\n            s.connect((addr[0], port))\r\n            print(\"SENDING DATA\")\r\n            s.sendall(\"OK\".encode())\r\n            while True:\r\n                piece = s.recv(1024).decode()\r\n                print(piece)\r\n                if piece!=b'':\r\n                    openfileobject.seek(piece*bundle.pieceSize)\r\n                    readData = openfileobject.read(bundle.pieceSize)\r\n                    s.sendall(readData)\r\n
--Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
--<+>UTF-8
--===================================================================
--diff --git a/Networking.py b/Networking.py
----- a/Networking.py	(revision 971f74aed81397ad98183790da0421e5392b5968)
--+++ b/Networking.py	(date 1649602709167)
--@@ -296,7 +296,7 @@
--             if data.decode() == "OK":
--                 for piece in pieceList:
--                     if piece[2]==0:
---                        s.sendall(piece[0])
--+                        s.sendall(str(piece[0]).encode())
--                         data = s.recv(100000)
--                         print(data)
-- 
-Index: .idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_28_PM_[Changes]/shelved.patch
-===================================================================
-diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_28_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_28_PM_[Changes]/shelved.patch
-deleted file mode 100644
---- a/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_28_PM_[Changes]/shelved.patch	(revision 365212bf76cc9c06ecdb230b24205915feb26c24)
-+++ /dev/null	(revision 365212bf76cc9c06ecdb230b24205915feb26c24)
-@@ -1,27 +0,0 @@
--Index: Networking.py
--IDEA additional info:
--Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
--<+>import copy\r\nimport json\r\nimport pickle\r\nimport socket\r\nimport threading\r\nfrom socket import *\r\nfrom Bundles import Bundle\r\nimport Client\r\nfrom Groups import GroupManager, Group\r\nimport os\r\n\r\n\r\nclass Request:\r\n    def __init__(self, type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\n\r\n# All Classes extended Request even Response Classes just for type and toJSON method.\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self, name, timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self, group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\n\r\nclass SearchBundleRequest(Request):\r\n    def __init__(self, groupId, keyword):\r\n        super().__init__(2)\r\n        self.groupID = groupId\r\n        self.keywords = keyword\r\n\r\n\r\nclass SearchBundleResponse(Request):\r\n    def __init__(self, responseBundles):\r\n        super().__init__(2)\r\n        self.responseBundles = responseBundles\r\n\r\n\r\nclass GetBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId, portForBundleReceiver):\r\n        super().__init__(3)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.portForBundleReceiver = portForBundleReceiver\r\n\r\n\r\nclass GetBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(3)\r\n        self.answer = answer\r\n\r\n\r\nclass CheckBundleAvailabilityRequest(Request):\r\n    def __init__(self, bundleId, groupId):\r\n        super().__init__(4)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n\r\n\r\nclass CheckBundleAvailabilityResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(4)\r\n        self.answer = answer\r\n\r\n\r\nclass DownloadBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId, file, port):\r\n        super().__init__(5)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.file = file\r\n        self.port = port\r\n\r\n\r\nclass DownloadBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(5)\r\n        self.answer = answer\r\n\r\n\r\ndef requestHandler(data, addr, groupManager: GroupManager):\r\n    req = pickle.loads(data)\r\n    print(req)\r\n\r\n    # Response to JoinRequest\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name, req.timestamp)\r\n        # TODO If this is allowed add peer and respond\r\n        # TODO Peer Port\r\n        groupManager.addPeerGroup(req.name, [addr[0]])\r\n        group = groupManager.getGroupWithName(req.name)\r\n        groupCpy = copy.copy(group)\r\n        del groupCpy.bundles\r\n        joinResponse = JoinResponse(groupCpy)\r\n        return pickle.dumps(joinResponse)\r\n\r\n    # Response to search req\r\n    elif req.type == 2:\r\n        # Create The Request again for local use\r\n        req = SearchBundleRequest(req.groupID, req.keywords)\r\n        # Get All Bundles User has\r\n        bundlesOfGroup = groupManager.getGroupWithId(req.groupID).bundles\r\n        # Bundles to reply\r\n        responseBundles = []\r\n        print(responseBundles)\r\n        for bundle in bundlesOfGroup:\r\n            # For each bundle make a single list (bundleKeywords) and search if any of the keywords other user send are in there then send back\r\n            name = bundle.name.split()\r\n            desc = bundle.description.split()\r\n            bundleKeywords = name + desc\r\n            # print(\"Bundle Keywords : \",bundleKeywords)\r\n            # print(\"Request Keywords : \",req.keywords)\r\n            if any(keyword in req.keywords for keyword in bundleKeywords):\r\n                # print(\"HIT\")\r\n                responseBundles.append({\"id\": bundle.id, \"name\": bundle.name, \"description\": bundle.description})\r\n        # Create Response and return it to be used as answer\r\n        # print(responseBundles)\r\n        searchResponse = SearchBundleResponse(responseBundles)\r\n        # print(\"Search Response :\",searchResponse)\r\n        return pickle.dumps(searchResponse)\r\n\r\n    elif req.type == 3:\r\n        req = GetBundleRequest(req.bundleId, req.groupId, req.portForBundleReceiver)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        bundle = group.getBundleWithId(req.bundleId)\r\n        bundleReceiver = threading.Thread(target=sendBundle,\r\n                                          args=[addr, req.portForBundleReceiver, groupManager, group, bundle])\r\n        bundleReceiver.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        # TODO 9/4 ????\r\n        return pickle.dumps(GetBundleResponse(1))\r\n\r\n    elif req.type == 4:\r\n        req = CheckBundleAvailabilityRequest(req.bundleId, req.groupId)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        bundle = group.getBundleWithId(req.bundleId)\r\n        if bundle is False:\r\n            # Not Found\r\n            return pickle.dumps(CheckBundleAvailabilityResponse(0))\r\n        else:\r\n            # Found\r\n            return pickle.dumps(CheckBundleAvailabilityResponse(1))\r\n\r\n    elif req.type == 5:\r\n        print(\"Received Request To Send File\")\r\n        req = DownloadBundleRequest(req.bundleId, req.groupId, req.file, req.port)\r\n        uploadThread = threading.Thread(target=uploadBundle,\r\n                                        args=[addr, req.port, req.bundleId, req.groupId, req.file, groupManager])\r\n        uploadThread.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        # TODO 9/4 ????\r\n        return pickle.dumps(DownloadBundleResponse(1))\r\n\r\n\r\ndef responseHandler(data, groupManager):\r\n    res = pickle.loads(data)\r\n\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        return res\r\n\r\n    elif res.type == 2:\r\n        res = SearchBundleResponse(res.responseBundles)\r\n        return res\r\n\r\n    elif res.type == 3:\r\n        res = SearchBundleResponse(res.answer)\r\n        return res\r\n\r\n    elif res.type == 4:\r\n        res = CheckBundleAvailabilityResponse(res.answer)\r\n        return res\r\n\r\n    elif res.type == 5:\r\n        res = DownloadBundleResponse(res.answer)\r\n        return res\r\n\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        # RECEIVE AND RESPOND.\r\n        data, addr = sock.recvfrom(65537)\r\n        # data, addr = sock.recvfrom(65507)\r\n        print(\"Received from :\", addr)\r\n        response = requestHandler(data, addr, groupManager)\r\n        sock.sendto(response, addr)\r\n\r\n\r\ndef sendRequest(address, port, request, groupManager):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.settimeout(1)\r\n    try:\r\n        clientSocket.sendto(request, (address, port))\r\n        data, addr = clientSocket.recvfrom(65537)\r\n        # data, addr = clientSocket.recvfrom(65507)\r\n        res = responseHandler(data, groupManager)\r\n        return res\r\n    # TODO except socket.timeout\r\n    # TODO for better exception handling fix later.\r\n    except Exception as exception:\r\n        # print(\"Exception on SendRequest:\", exception)\r\n        return False\r\n\r\n\r\ndef receiveBundle(port, client, groupManager, groupId, downloadManager):\r\n    print(\"RECEIVING BUNDLE THREAD\")\r\n    bundleBytes = b\"\"\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.bind((\"0.0.0.0\", port))\r\n        print(\"Bundle Receiver Ready\")\r\n        s.listen()\r\n        conn, addr = s.accept()\r\n        with conn:\r\n            print(f\"Connected by {addr}\")\r\n            while True:\r\n                data = conn.recv(1024)\r\n                # print(data)\r\n                bundleBytes = bundleBytes + data\r\n                # TODO save Bytes to group and downloads also start downloading.\r\n                if not data:\r\n                    # print(\"Break\")\r\n                    break\r\n            # print(\"Break3\")\r\n    # print(\"Bundle Str\",bundleBytes.decode())\r\n    bundleObj = json.loads(bundleBytes.decode())\r\n    # Fix Bundle Root to be downloaded and location\r\n    client: Client.Client\r\n    bundleObj[\"root\"] = client.DIR_PATH_DOWNLOADS\r\n    bundle = Bundle(bundleObj[\"name\"], bundleObj[\"description\"], bundleObj[\"id\"], bundleObj[\"timestamp\"],\r\n                    bundleObj[\"root\"], bundleObj[\"pieceSize\"], bundleObj[\"files\"])\r\n    group = groupManager.getGroupWithId(groupId)\r\n    groupManager.addBundle(bundle, group.name)\r\n    downloadManager.downloadBundle(bundle, group)\r\n\r\n\r\ndef sendBundle(addr, port, groupManager, group, bundle):\r\n    print(\"SENDING BUNDLE THREAD\")\r\n    group: Group\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.connect((addr[0], port))\r\n        print(\"SENDING DATA\")\r\n        groupManager: GroupManager\r\n        json_file_name = bundle.name + \".json\"\r\n        bundleDir = groupManager.DIR_PATH_GROUPS + group.name + \"\\\\\" + \"Bundles\" + \"\\\\\" + json_file_name\r\n        print(bundleDir)\r\n        print(json_file_name)\r\n        with open(bundleDir) as f:\r\n            bundleContent = f.read()\r\n            bundleObj = json.loads(bundleContent)\r\n            bundleObj[\"root\"] = \"\"\r\n            bundleStr = json.dumps(bundleObj)\r\n\r\n        s.sendall(bundleStr.encode())\r\n\r\n\r\ndef is_port_in_use(port: int) -> bool:\r\n    import socket\r\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\r\n        return s.connect_ex(('localhost', port)) == 0\r\n\r\n\r\ndef downloadBundle(port, peer, file, bundle, usedPeers, freeFiles):\r\n    bundle: BundleToDownload\r\n    pieceList = []\r\n    # Find pieces missing\r\n    for x in bundle.files:\r\n        if x[\"path\"] == file[0]:\r\n            pieceList = x[\"pieces\"]\r\n            break\r\n    # pieceList = [[0, '5920572cf97d3711a77a9b7a3469a5fd03bb2a8a', 0]]\r\n    print(\"DOWNLOADING BUNDLE THREAD\")\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.bind((\"0.0.0.0\", port))\r\n        print(\"Bundle Receiver Ready\")\r\n        s.listen()\r\n        conn, addr = s.accept()\r\n        with conn:\r\n            print(f\"Connected by {addr} to download file.\")\r\n            data = conn.recv(1024)\r\n            if data.decode() == \"OK\":\r\n                for piece in pieceList:\r\n                    if piece[2] == 0:\r\n                        s.sendall(piece[0])\r\n                        data = s.recv(100000)\r\n                        print(data)\r\n\r\n\r\ndef uploadBundle(addr, port, bundleId, groupId, file, groupManager):\r\n    print(\"SENDING BUNDLE THREAD\")\r\n    group = groupManager.getGroupWithId(groupId)\r\n    bundle = group.getBundleWithId(bundleId)\r\n    with open(bundle.root + file, 'rb') as openfileobject:\r\n        with socket(AF_INET, SOCK_STREAM) as s:\r\n            s.connect((addr[0], port))\r\n            print(\"SENDING DATA\")\r\n            s.sendall(\"OK\".encode())\r\n            while True:\r\n                piece = s.recv(1024).decode()\r\n                if piece != b'':\r\n                    print(piece)\r\n                    openfileobject.seek(piece * bundle.pieceSize)\r\n                    readData = openfileobject.read(bundle.pieceSize)\r\n                    s.sendall(readData)\r\n
--Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
--<+>UTF-8
--===================================================================
--diff --git a/Networking.py b/Networking.py
----- a/Networking.py	(revision 7cbd428dd666a0befbaca5d31c0a5c9e2642708a)
--+++ b/Networking.py	(date 1649604043756)
--@@ -294,11 +294,13 @@
--             print(f"Connected by {addr} to download file.")
--             data = conn.recv(1024)
--             if data.decode() == "OK":
--+                print("Received Ok")
--                 for piece in pieceList:
--                     if piece[2] == 0:
---                        s.sendall(piece[0])
---                        data = s.recv(100000)
---                        print(data)
--+                        print(f"Sending Piece num {piece[0]} ")
--+                        conn.sendall(str(piece[0]).encode())
--+                        data = conn.recv(100000)
--+                        print(f"Received {data}")
-- 
-- 
-- def uploadBundle(addr, port, bundleId, groupId, file, groupManager):
-Index: .idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_5_28_PM__Changes_.xml
-===================================================================
-diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_5_28_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_5_28_PM__Changes_.xml
-deleted file mode 100644
---- a/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_5_28_PM__Changes_.xml	(revision 365212bf76cc9c06ecdb230b24205915feb26c24)
-+++ /dev/null	(revision 365212bf76cc9c06ecdb230b24205915feb26c24)
-@@ -1,4 +0,0 @@
--<changelist name="Uncommitted_changes_before_Update_at_10-Apr-22_5_28_PM_[Changes]" date="1649600927107" recycled="true" deleted="true">
--  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_5_28_PM_[Changes]/shelved.patch" />
--  <option name="DESCRIPTION" value="Uncommitted changes before Update at 10-Apr-22 5:28 PM [Changes]" />
--</changelist>
-\ No newline at end of file
-Index: .idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_03_PM__Changes_.xml
-===================================================================
-diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_03_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_03_PM__Changes_.xml
-deleted file mode 100644
---- a/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_03_PM__Changes_.xml	(revision 365212bf76cc9c06ecdb230b24205915feb26c24)
-+++ /dev/null	(revision 365212bf76cc9c06ecdb230b24205915feb26c24)
-@@ -1,4 +0,0 @@
--<changelist name="Uncommitted_changes_before_Update_at_10-Apr-22_6_03_PM_[Changes]" date="1649602982469" recycled="true" deleted="true">
--  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_10-Apr-22_6_03_PM_[Changes]/shelved.patch" />
--  <option name="DESCRIPTION" value="Uncommitted changes before Update at 10-Apr-22 6:03 PM [Changes]" />
--</changelist>
-\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_26-Apr-22_1_06_PM_[Changes]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_26-Apr-22_1_06_PM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_26-Apr-22_1_06_PM_[Changes]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_26-Apr-22_1_06_PM_[Changes]/shelved.patch	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,70 +0,0 @@
-Index: Blockchain.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import math\r\nimport os\r\nimport json\r\nfrom os import listdir\r\nimport rsa\r\nimport time\r\nfrom time import sleep\r\nimport threading\r\nfrom hashlib import sha256\r\nimport copy\r\nfrom pickle import dumps, loads\r\n\r\n\r\nclass Block:\r\n    def __init__(self, index, transaction, timestamp, previous_hash, signatures):\r\n        self.index = index\r\n\r\n        self.transaction = transaction\r\n\r\n        self.timestamp = timestamp\r\n\r\n        self.previous_hash = previous_hash\r\n\r\n        self.signatures = signatures\r\n\r\n    def computeHash(self):\r\n        mycopy = copy.copy(self)\r\n        del mycopy.signatures\r\n        # print(mycopy.__dict__)\r\n        if hasattr(mycopy, 'hash'):\r\n            del mycopy.hash\r\n        block_string = json.dumps(mycopy.__dict__, sort_keys=True)\r\n        return sha256(block_string.encode()).hexdigest()\r\n\r\n\r\nclass UnconfirmedTransaction:\r\n    def __init__(self, transaction, signatures=[]):\r\n        self.transaction = transaction\r\n        self.signatures = signatures\r\n\r\n\r\nclass GenesisTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 0\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass InviteTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 1\r\n        self.ip = ip\r\n\r\n\r\nclass JoinTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 2\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass BanTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 3\r\n        self.ip = ip\r\n\r\n\r\nclass UnbanTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 4\r\n        self.ip = ip\r\n\r\n\r\nclass AddAdminTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 5\r\n        self.ip = ip\r\n\r\n\r\nclass RemoveAdminTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 6\r\n        self.ip = ip\r\n\r\n\r\nclass Blockchain:\r\n    def __init__(self, path, groupPeers, groupAdmins, groupId, client):\r\n        self.BLOCKCHAIN_PATH = path\r\n        self.TRANSACTION_PATH = self.BLOCKCHAIN_PATH + \"\\\\Transactions\\\\\"\r\n        self.unconfirmed_transactions = []\r\n        self.chain = []\r\n        self.peers = groupPeers\r\n        self.groupId = groupId\r\n        self.groupAdmins = groupAdmins\r\n        self.client = client\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n            # Load Unconfirmed Transactions\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n\r\n        self.loadTransactions()\r\n\r\n        # print(self.unconfirmed_transactions)\r\n        # Load Blocks here\r\n        blockFiles = [f for f in listdir(self.BLOCKCHAIN_PATH) if os.path.isfile(os.path.join(self.BLOCKCHAIN_PATH, f))]\r\n        for blockFile in blockFiles:\r\n            self.loadBlock(blockFile)\r\n\r\n        # Start Casual Operations.\r\n        # Thread This.\r\n        miner = threading.Thread(target=self.mine, args=[client])\r\n        miner.start()\r\n        # print(self.unconfirmed_transactions)\r\n        # for block in self.chain:\r\n        #     print(block)\r\n\r\n    def getDifficulty(self):\r\n        # Diffuculty of blockchain will be dependent on the users participating in  --->log2(peers)\r\n        return 2\r\n        if len(self.peers) == 0:\r\n            return 1\r\n        else:\r\n            peers, bans, admins, owner = self.parseBlockchain()\r\n            return math.floor(math.log2(len(peers)))\r\n\r\n    def createGenesisBlock(self, client):\r\n        transaction = GenesisTransaction(client.publicIP, client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        # this is string json format\r\n        # print(transactionStr)\r\n        # print(transactionStr.__class__)\r\n        # Genereate signature for Transaction\r\n        signature = rsa.sign(transactionStr.encode(), client.privateKey, 'SHA-1')\r\n        genesis_block = Block(0, transactionStr, str(time.time()), \"0\", [client.publicIP,str(signature)])\r\n        genesis_block.hash = genesis_block.computeHash()\r\n        self.saveBlock(genesis_block)\r\n        self.chain.append(genesis_block)\r\n\r\n    def verifyTransaction(self,transaction):\r\n        #TODO verify transactions.\r\n        return True\r\n\r\n    def saveBlock(self, block):\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Creating Blockchain Folder\")\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n        blockFile = open(self.BLOCKCHAIN_PATH + \"\\\\Block\" + str(block.index) + \".json\", \"w\")\r\n        # print(block.__dict__)\r\n        blockFile.write(json.dumps(block.__dict__))\r\n        blockFile.close()\r\n\r\n    def loadTransactions(self):\r\n        filePath = self.TRANSACTION_PATH + \"Transactions.json\"\r\n        if os.path.exists(filePath):\r\n            try:\r\n                file = open(filePath)\r\n                # print(file)\r\n                json_load_group = json.load(file)\r\n                file.close()\r\n            except Exception as e:\r\n                print(\"Error Opening Transaction file :\", e)\r\n            for x in json_load_group:\r\n                transaction = UnconfirmedTransaction(x[\"transaction\"], x[\"signatures\"])\r\n                # print(transaction)\r\n                self.unconfirmed_transactions.append(transaction)\r\n            # print(self.unconfirmed_transactions)\r\n\r\n    def loadBlock(self, blockFiles):\r\n        # print(blockFiles)\r\n        filePath = self.BLOCKCHAIN_PATH + \"\\\\\" + blockFiles\r\n        file = open(filePath)\r\n        # print(file)\r\n        block = json.load(file)\r\n        file.close()\r\n        # # print(block)\r\n        # transaction = json.loads(block[\"transaction\"])\r\n        # # print(transaction)\r\n        # # print(transaction.__class__)\r\n        # # Make transaction here\r\n        # if transaction[\"type\"] == 0:\r\n        #     # print(\"Genesis block\")\r\n        #     transactionObj = GenesisTransaction(transaction[\"ip\"], transaction[\"publicKey\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        blockObj = Block(block[\"index\"], block[\"transaction\"], block[\"timestamp\"], block[\"previous_hash\"],\r\n                         block[\"signatures\"])\r\n        blockObj.hash = block[\"hash\"]\r\n        # elif transaction[\"type\"] == 1:\r\n        #     # print(\"Genesis block\")\r\n        #     # print(transaction)\r\n        #     transactionObj = InviteTransaction(transaction[\"ip\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        #     blockObj = Block(block[\"index\"], transactionStr, block[\"timestamp\"], block[\"previous_hash\"],\r\n        #                      block[\"signatures\"])\r\n        #     blockObj.hash = block[\"hash\"]\r\n\r\n        self.chain.append(blockObj)\r\n        # print(blockObj.__dict__)\r\n\r\n    def addNewTransaction(self, transaction: str):\r\n        newUnconfirmedTransaction = UnconfirmedTransaction(transaction)\r\n        self.unconfirmed_transactions.append(newUnconfirmedTransaction)\r\n        self.saveUnconfirmedTransactions()\r\n\r\n    def updateBlockchain(self, client):\r\n        for peer in self.peers:\r\n            # Dont send to self\r\n            if peer[0] != client.publicIP:\r\n                # For each peer ask their max index of blockchain\r\n                updateBlockchainReq = Networking.UpdateBlockchainRequest(self.groupId)\r\n                res = Networking.sendRequest(peer[0], 6700, dumps(updateBlockchainReq))\r\n                if res is not False:\r\n                    # if the response is bigger than me ask him for his block until we are at the same.\r\n                    if res.answer > self.getLastBlockIndex():\r\n                        print(self.getLastBlockIndex().__class__, res.answer.__class__)\r\n                        while self.getLastBlockIndex() < res.answer:\r\n                            # Get block\r\n                            getBlockReq = Networking.GetBlockRequest(self.groupId, self.getLastBlockIndex() + 1)\r\n                            blockRes = Networking.sendRequest(peer[0], 6700, dumps(getBlockReq))\r\n                            if blockRes is not False:\r\n                                print(f\"Update BC Response:{blockRes}\")\r\n                                # print(blockRes.answer)\r\n                                block = blockRes.answer\r\n                                block: Block\r\n                                print(block.index, block.transaction, block.signatures, block.timestamp,\r\n                                      block.previous_hash, block.hash)\r\n                                newBlock = Block(block.index, block.transaction, block.timestamp, block.previous_hash,\r\n                                                 block.signatures)\r\n                                newBlock.hash = block.hash\r\n                                if self.validateNewBlock(newBlock):\r\n                                    self.saveBlock(newBlock)\r\n                                    self.chain.append(newBlock)\r\n                            else:\r\n                                break\r\n                    else:\r\n                        # print(id(self.peers))\r\n                        peers, bans, admins, owner = self.parseBlockchain()\r\n                        # self.peers = peers\r\n                        # self.groupAdmins = admins\r\n                        # print(id(self.peers))\r\n                        # print(\"Blockchain Updated And Parsed\")\r\n                        # print(\"Up-to-date.\")\r\n                        pass\r\n\r\n        #Update Group Peers And Admins\r\n        peers, bans, admins, owner = self.parseBlockchain()\r\n        for ip in admins:\r\n            inside = False\r\n            for admin in self.groupAdmins:\r\n                if admin[0]==ip:\r\n                    inside = True\r\n            if not inside:\r\n                self.groupAdmins.append([ip])\r\n\r\n\r\n        for ip in peers:\r\n            inside = False\r\n            for peer in self.peers:\r\n                if peer[0]==ip:\r\n                    inside = True\r\n            if not inside:\r\n                self.peers.append([ip])\r\n\r\n\r\n    def getBlockWithIndex(self, index):\r\n        for block in self.chain:\r\n            block: Block\r\n            if block.index == index:\r\n                return block\r\n        return False\r\n\r\n    def validateNewBlock(self, newBlock):\r\n        \"\"\"This function is for new blocks that come from peers returns true if blocks checks out.\"\"\"\r\n        newBlock: Block\r\n\r\n        # If hash ok.\r\n        if newBlock.computeHash() == newBlock.hash:\r\n            # Validation for genesis block\r\n            if newBlock.index == 0:\r\n                if self.getLastBlockIndex() == -1:\r\n                    # No other blocks accept it.\r\n                    return True\r\n                else:\r\n                    return False\r\n            else:\r\n                # Check if new block is made with the same previous block.\r\n                # TODO if not resolve ?\r\n                if newBlock.previous_hash == self.getLastBlock().computeHash():\r\n                    # TODO check if signatures okay.\r\n                    # TODO check timestamp.\r\n                    # TODO check difficulty based on blockchain etc.\r\n                    return True\r\n\r\n    def mine(self, client):\r\n        while True:\r\n            # Update Blockchain.\r\n            self.updateBlockchain(client)\r\n            if not self.unconfirmed_transactions:\r\n                # If No Transaction sleep and check again soon.\r\n                sleep(30)\r\n            else:\r\n                diff = self.getDifficulty()\r\n                print(f\"Blockchain Difficulty :{diff}\")\r\n                print(f\"Unconfirmed Transactions:{len(self.unconfirmed_transactions)}\")\r\n                for transaction in self.unconfirmed_transactions:\r\n                    transaction: UnconfirmedTransaction\r\n                    # For Each Transaction if signatures < difficulty collect transactions\r\n                    if diff > len(transaction.signatures):\r\n                        if not len(transaction.signatures):\r\n                            # No Signatures add my signature\r\n                            signature = rsa.sign(transaction.transaction.encode(), client.privateKey, 'SHA-1')\r\n                            transaction.signatures.append([str(client.publicIP),str(signature)])\r\n                            self.saveUnconfirmedTransactions()\r\n                        else:\r\n                            print(\"TRYING TO MINE FROM PEERS\")\r\n                            for peer in self.peers:\r\n                                if peer[0]!=client.publicIP:\r\n                                    print(f\"Trying to get signatures from :{peer[0]}\")\r\n                                    print(transaction.transaction)\r\n                                    #Send Transaction get signature.\r\n                                    signReq = Networking.GetSignatureRequest(self.groupId,self.getLastBlockIndex(),transaction.transaction)\r\n                                    res = Networking.sendRequest(peer[0], 6700, dumps(signReq))\r\n                                    if res is not False:\r\n                                        if res.answer!=0 and res.answer!=1:\r\n                                            #Verified.\r\n                                            print(f\"Signature:{res.answer},SignBytes:{bytes(res.answer,'utf-8')}\")\r\n                                            # key = rsa.PublicKey.load_pkcs1(self.getRSAKey(peer[0]))\r\n                                            # print(rsa.verify(transaction.transaction, signature, key))\r\n\r\n                                    else:\r\n                                        #Peer Dead Try From Others.\r\n                                        print(\"No Response from\", peer[0])\r\n                                        pass\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                            pass\r\n                    else:\r\n                        # We have the signatures number procede to make block and share.\r\n                        print(f\"Signature {transaction} ready to be made block.\")\r\n                        # Bytes\r\n                        lastBlock = self.getLastBlock()\r\n                        # print(lastBlock)\r\n                        lastBlock: Block\r\n                        print(f\"Last Block Index :{lastBlock.index}\")\r\n                        newBlock = Block(lastBlock.index + 1, transaction.transaction, str(time.time()),\r\n                                         lastBlock.computeHash(), transaction.signatures)\r\n                        newBlock.hash = newBlock.computeHash()\r\n                        self.unconfirmed_transactions.remove(transaction)\r\n                        self.saveUnconfirmedTransactions()\r\n                        self.saveBlock(newBlock)\r\n                        self.chain.append(newBlock)\r\n                sleep(30)\r\n\r\n    def getLastBlock(self) -> Block:\r\n        lastBlockIndex = self.chain[0].index\r\n        # Find last Block and return it\r\n        lastBlock = self.chain[0]\r\n        for block in self.chain:\r\n            # print(block.index)\r\n            if block.index > lastBlockIndex:\r\n                lastBlock = block\r\n                lastBlockIndex = block.index\r\n        return lastBlock\r\n\r\n    def getRSAKey(self,ip):\r\n        \"\"\"Use only with peers in group so key always exists one way or another.\"\"\"\r\n        for block in self.chain:\r\n            block:Block\r\n            transaction = json.loads(block.transaction)\r\n            if transaction[\"type\"] == 0:\r\n                if transaction[\"ip\"]==ip:\r\n                    return transaction[\"publicKey\"]\r\n\r\n            # From Invite\r\n            elif transaction[\"type\"] == 2:\r\n                if transaction[\"ip\"]==ip:\r\n                    return transaction[\"publicKey\"]\r\n\r\n\r\n    def getLastBlockIndex(self):\r\n        if len(self.chain) == 0:\r\n            return -1\r\n        else:\r\n            lastBlockIndex = self.chain[0].index\r\n            # Find last Block and return it\r\n            lastBlock = self.chain[0]\r\n            for block in self.chain:\r\n                # print(block.index)\r\n                if block.index > lastBlockIndex:\r\n                    lastBlock = block\r\n                    lastBlockIndex = block.index\r\n            return lastBlock.index\r\n\r\n    def saveUnconfirmedTransactions(self):\r\n        # print(self.TRANSACTION_PATH)\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Blockchain Folder\")\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n        json_file = open(self.TRANSACTION_PATH + \"Transactions\" + \".json\", \"w\")\r\n        json_file.write((json.dumps([ob.__dict__ for ob in self.unconfirmed_transactions])))\r\n        json_file.close()\r\n\r\n    def isUserAllowed(self, ip):\r\n        for block in self.chain:\r\n            block: Block\r\n            transaction = json.loads(block.transaction)\r\n            # From Create Genesis Block\r\n            if transaction[\"type\"] == 0:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n            # From Invite\r\n            if transaction[\"type\"] == 1:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n        # Didndt find user\r\n        return False\r\n\r\n    def getOwner(self):\r\n        for block in self.chain:\r\n            transaction = json.loads(block.transaction)\r\n            if transaction[\"type\"] == 0:\r\n                return transaction[\"ip\"]\r\n\r\n    def parseBlockchain(self):\r\n        \"\"\"\r\n        Parses Blockchain and returns 5 list of user types.\r\n        Peers that are in the blockchain and allowed.\r\n        Banned peers, Invites ,Admins and, Owner . All are lists.\r\n        \"\"\"\r\n        peers = []\r\n        bans = []\r\n        admins = []\r\n        invites = []\r\n        owner = []\r\n\r\n        for block in self.chain:\r\n            transaction = json.loads(block.transaction)\r\n            #GenesisTransactio\r\n            if transaction[\"type\"] == 0:\r\n                owner.append(transaction[\"ip\"])\r\n                admins.append(transaction[\"ip\"])\r\n                peers.append(transaction[\"ip\"])\r\n\r\n            #InviteTransaction\r\n            elif transaction[\"type\"] == 1:\r\n                invites.append(transaction[\"ip\"])\r\n\r\n            #JoinTransaction\r\n            elif transaction[\"type\"] == 2:\r\n                peers.append(transaction[\"ip\"])\r\n                invites.remove(transaction[\"ip\"])\r\n\r\n            #BanTransaction\r\n            elif transaction[\"type\"] == 3:\r\n                peers.remove(transaction[\"ip\"])\r\n                bans.append(transaction[\"ip\"])\r\n\r\n            # UnbanTransaction\r\n            elif transaction[\"type\"] == 4:\r\n                bans.remove(transaction[\"ip\"])\r\n\r\n                # AddAdminTransaction\r\n            elif transaction[\"type\"] == 5:\r\n                admins.append(transaction[\"ip\"])\r\n\r\n            # RemoveAdminTransaction\r\n            elif transaction[\"type\"] == 6:\r\n                admins.remove(transaction[\"ip\"])\r\n\r\n        # print(f\"Peers:{peers},Bans:{bans},Admins:{admins},Owners:{owner}\")\r\n        return peers, bans, admins, owner\r\n\r\n\r\nimport Networking\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/Blockchain.py b/Blockchain.py
---- a/Blockchain.py	(revision de59e92006cbb426c6bb20267c11c6488949315e)
-+++ b/Blockchain.py	(date 1650894524522)
-@@ -447,8 +447,12 @@
- 
-         for block in self.chain:
-             transaction = json.loads(block.transaction)
-+            print(peers,invites)
-+            print(transaction)
-+
-             #GenesisTransactio
-             if transaction["type"] == 0:
-+
-                 owner.append(transaction["ip"])
-                 admins.append(transaction["ip"])
-                 peers.append(transaction["ip"])
-Index: main.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import json\r\nimport logging\r\nimport threading\r\nfrom pickle import dumps, loads\r\nfrom flask import Flask, render_template, request, redirect\r\n\r\nimport Blockchain\r\nimport Compress\r\nfrom Networking import receiver, sendRequest, JoinRequest, SearchBundleRequest, receiveBundle, GetBundleRequest\r\nfrom Groups import GroupManager, Invite, Group\r\nfrom Client import Client\r\nimport easygui\r\nfrom Bundles import BundleManager\r\nfrom Downloads import DownloadManager\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = False\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    progress = downloadManager.getDownloadProgress()\r\n    return render_template(\"index.html\", groups=groupManager.groups, client=client, progress=progress)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    group = groupManager.getGroupWithName(group)\r\n    groupManager.saveGroup(group)\r\n    # Check if user should see admin panels.\r\n    peers, bans, admins, owner = group.blockchain.parseBlockchain()\r\n    if owner[0] in peers:\r\n        peers.remove(owner[0])\r\n\r\n    if owner[0] in admins:\r\n        admins.remove(owner[0])\r\n\r\n    # Check privs what to show on group page.\r\n    adminPriv = False\r\n    for admin in group.admins:\r\n        if admin[0] == client.publicIP:\r\n            adminPriv = True\r\n\r\n    ownerPriv = False\r\n    if group.blockchain.getOwner() == client.publicIP:\r\n        ownerPriv = True\r\n\r\n    if client.publicIP in admins:\r\n        admins.remove(client.publicIP)\r\n    if client.publicIP in peers:\r\n        peers.remove(client.publicIP)\r\n\r\n    dif = group.blockchain.getDifficulty()\r\n    print(dif)\r\n    groupManager.saveGroup(group)\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group, client=client, adminPriv=adminPriv,\r\n                           ownerPriv=ownerPriv, peers=peers, bans=bans, admins=admins)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    if downloadManager.STATUS:\r\n        downloadManager.STATUS = False\r\n        # downloadManager Off\r\n        print(\"Download Manager Not Active\")\r\n        return \"0\"\r\n    else:\r\n        downloadManager.STATUS = True\r\n        # downloadManager On\r\n        print(\"Download Manager Active\")\r\n        return \"1\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n        # TODO KEY SPECIFIC BLOCKCHAIN\r\n        ip = data[\"ip\"]  # This is string\r\n        transaction = Blockchain.InviteTransaction(ip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        # print(\"Generate Invite for :\", group)\r\n        # print(group)\r\n        invite = group.generateInvite()\r\n        return Compress.compress(invite.toJSON())\r\n\r\n\r\n\r\n@app.route('/deleteBundle', methods=['POST'])\r\ndef deleteBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupId = data[\"groupId\"]\r\n        bundleId = data[\"bundleId\"]\r\n        if groupManager.deleteBundle(groupId, bundleId):\r\n            return \"1\"\r\n        else:\r\n            return \"0\"\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        inviteDecomp = Compress.decompress(invite)\r\n        inviteLoad = json.loads(inviteDecomp)\r\n        invite = Invite(inviteLoad[\"id\"], inviteLoad[\"name\"], inviteLoad[\"timestamp\"], inviteLoad[\"peers\"])\r\n        joinReq = JoinRequest(invite.name, invite.timestamp)\r\n        # print(invite.peers)\r\n        for peer in invite.peers:\r\n            # print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq))\r\n            if res is not False:\r\n                # Response from user with group data.\r\n                group = res.group\r\n                group = Group(group.name, group.admins, group.peers, group.timestamp,\r\n                              blockchainPath=groupManager.DIR_PATH_GROUPS + group.name + \"\\\\Blockchain\", client=client)\r\n                groupManager.addGroup(group)\r\n                # Make Join Transaction.\r\n                transaction = Blockchain.JoinTransaction(client.publicIP,\r\n                                                         client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n                transactionStr = json.dumps(transaction.__dict__)\r\n                group.blockchain.addNewTransaction(transactionStr)\r\n                return \"1\"\r\n        # No responses.\r\n        return \"0\"\r\n\r\n\r\n@app.route('/shareBundle', methods=['POST'])\r\ndef shareBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"bundleName\"]\r\n        desc = data[\"bundleDescription\"]\r\n        groupName = data[\"groupName\"]\r\n        # print(name)\r\n        # print(desc)\r\n        # print(groupName)\r\n        path = easygui.diropenbox(msg=\"Select folder to share as bundle\", title=\"Share Bundle\")\r\n        bundle = bundleManager.createBundle(name, desc, path=path)\r\n        groupManager.addBundle(bundle, groupName)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/selectDownloadLocation', methods=['POST'])\r\ndef selectDownloadLocation():\r\n    if request.method == 'POST':\r\n        path = easygui.diropenbox(msg=\"Select folder to download bundles\", title=\"Select Bundle Download Location\")\r\n        # print(path)\r\n        # Update Download Path in Config\r\n        client.DIR_PATH_DOWNLOADS = path\r\n        client.saveConfig()\r\n        # Return path to browser and update it in modal\r\n        return path\r\n\r\n\r\n@app.route('/searchBundles', methods=['POST'])\r\ndef searchBundles():\r\n    # print(\"Search Bundles Route\")\r\n    if request.method == 'POST':\r\n        data = request.form\r\n\r\n        # Get Keywords from search\r\n        keywords = data[\"searchKeyWords\"].split()\r\n        # print(\"Search for :\",keywords)\r\n\r\n        # Get Group\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n\r\n        searchReq = SearchBundleRequest(group.id, keywords)\r\n        responses = []\r\n        # SEND TO ALL PEERS COLLECT RESPONSES AND PRESENT\r\n        for peer in group.peers:\r\n            res = sendRequest(peer[0], 6700, dumps(searchReq))\r\n            # if other peer is responded.\r\n            if res is not False:\r\n                # print(res)\r\n                responses.append([peer[0], res])\r\n            else:\r\n                print(\"No Response from\", peer[0])\r\n        # Merge all responses to single list\r\n        # for x in responses:\r\n        #     print(\"Response:\",x[0],x[1],x[1].responseBundles)\r\n        # WITH RESPONSES DO STUFF.\r\n        # Respond\r\n        return render_template(\"search.html\", groups=groupManager.groups, group=group, responses=responses)\r\n\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n    if groupManager.createGroup(name, [client.publicIP]):\r\n        # Make First Block In Blockchain Append Admin\r\n        # Type 0 First Created\r\n        group = groupManager.getGroupWithName(name)\r\n        group.blockchain.createGenesisBlock(client)\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n\r\n@app.route('/getBundle', methods=['POST'])\r\ndef getBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        bundleId = data[\"bundleId\"]\r\n        groupId = data[\"groupId\"]\r\n        userIp = data[\"userIp\"]\r\n        # TODO dynamic port on receiver for bundle\r\n        portForBundleReceiver = 6701\r\n        bundleReceiver = threading.Thread(target=receiveBundle,\r\n                                          args=[portForBundleReceiver, client, groupManager, groupId, downloadManager])\r\n        bundleReceiver.start()\r\n        getBundleReq = GetBundleRequest(bundleId, groupId, portForBundleReceiver)\r\n        res = sendRequest(userIp, 6700, dumps(getBundleReq))\r\n        # if other peer is responded.\r\n        if res is not False:\r\n            # Responded decide what to do\r\n            pass\r\n        else:\r\n            # print(\"No Response from\", userIp)\r\n            pass\r\n    return \"1\"\r\n\r\n\r\n@app.route('/quitGroup', methods=['POST'])\r\ndef quitGroup():\r\n    # print('QUIT GROUP REQ')\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        if groupManager.quitGroup(group):\r\n            # True\r\n            return \"0\"\r\n        else:\r\n            # False\r\n            return \"1\"\r\n\r\n\r\n@app.route('/banUser', methods=['POST'])\r\ndef banUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.BanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/unbanUser', methods=['POST'])\r\ndef unbanUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.UnbanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/addAdmin', methods=['POST'])\r\ndef addAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.AddAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/removeAdmin', methods=['POST'])\r\ndef removeAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.RemoveAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    groupManager = GroupManager(client)\r\n    bundleManager = BundleManager()\r\n    downloadManager = DownloadManager(groupManager, client)\r\n    # TODO Networking Thread To Receive From Internet\r\n    receiver = threading.Thread(target=receiver, args=[groupManager])\r\n    receiver.start()\r\n    app.run(host='', port=6969)\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/main.py b/main.py
---- a/main.py	(revision de59e92006cbb426c6bb20267c11c6488949315e)
-+++ b/main.py	(date 1650894524501)
-@@ -57,7 +57,7 @@
-         peers.remove(client.publicIP)
- 
-     dif = group.blockchain.getDifficulty()
--    print(dif)
-+    # print(dif)
-     groupManager.saveGroup(group)
-     return render_template("groups.html", groups=groupManager.groups, group=group, client=client, adminPriv=adminPriv,
-                            ownerPriv=ownerPriv, peers=peers, bans=bans, admins=admins)
-Index: Networking.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import copy\r\nimport json\r\nimport pickle\r\nimport socket\r\nimport threading\r\nfrom socket import *\r\nfrom Bundles import Bundle\r\nimport Client\r\nfrom Groups import GroupManager, Group\r\nimport os\r\nimport hashlib\r\nimport Blockchain\r\n\r\n\r\nclass Request:\r\n    def __init__(self, type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\n\r\n# All Classes extended Request even Response Classes just for type and toJSON method.\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self, name, timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self, group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\n\r\nclass SearchBundleRequest(Request):\r\n    def __init__(self, groupId, keyword):\r\n        super().__init__(2)\r\n        self.groupID = groupId\r\n        self.keywords = keyword\r\n\r\n\r\nclass SearchBundleResponse(Request):\r\n    def __init__(self, responseBundles):\r\n        super().__init__(2)\r\n        self.responseBundles = responseBundles\r\n\r\n\r\nclass GetBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId, portForBundleReceiver):\r\n        super().__init__(3)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.portForBundleReceiver = portForBundleReceiver\r\n\r\n\r\nclass GetBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(3)\r\n        self.answer = answer\r\n\r\n\r\nclass CheckBundleAvailabilityRequest(Request):\r\n    def __init__(self, bundleId, groupId):\r\n        super().__init__(4)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n\r\n\r\nclass CheckBundleAvailabilityResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(4)\r\n        self.answer = answer\r\n\r\n\r\nclass DownloadBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId, file, port):\r\n        super().__init__(5)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.file = file\r\n        self.port = port\r\n\r\n\r\nclass DownloadBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(5)\r\n        self.answer = answer\r\n\r\n\r\nclass UpdateBlockchainRequest(Request):\r\n    def __init__(self, groupId):\r\n        super().__init__(6)\r\n        self.groupId = groupId\r\n\r\n\r\nclass UpdateBlockchainResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(6)\r\n        self.answer = answer\r\n\r\n\r\nclass GetBlockRequest(Request):\r\n    def __init__(self, groupId, blockIndex):\r\n        super().__init__(7)\r\n        self.groupId = groupId\r\n        self.blockIndex = blockIndex\r\n\r\n\r\nclass GetBlockResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(7)\r\n        self.answer = answer\r\n\r\nclass GetSignatureRequest(Request):\r\n    def __init__(self, groupId, lastIndex,transaction):\r\n        super().__init__(8)\r\n        self.groupId = groupId\r\n        self.lastIndex = lastIndex\r\n        self.transaction = transaction\r\n\r\nclass GetSignatureResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(8)\r\n        self.answer = answer\r\n\r\n\r\n\r\ndef requestHandler(data, addr, groupManager: GroupManager):\r\n    req = pickle.loads(data)\r\n    print(f\"Received From {addr[0]}:{addr[1]} {req.__class__.__name__}\")\r\n\r\n    # Response to JoinRequest\r\n    #TODO refactor this.\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name, req.timestamp)\r\n        group = groupManager.getGroupWithName(req.name)\r\n        if group.blockchain.isUserAllowed(addr[0]):\r\n            groupManager.addPeerGroup(req.name, [addr[0]])\r\n            groupCpy = copy.copy(group)\r\n            del groupCpy.bundles\r\n            joinResponse = JoinResponse(groupCpy)\r\n            return pickle.dumps(joinResponse)\r\n        else:\r\n            return False\r\n\r\n    # Response to search req\r\n    elif req.type == 2:\r\n        # Create The Request again for local use\r\n        req = SearchBundleRequest(req.groupID, req.keywords)\r\n        # Get All Bundles User has\r\n        bundlesOfGroup = groupManager.getGroupWithId(req.groupID).bundles\r\n        # Bundles to reply\r\n        responseBundles = []\r\n        # print(responseBundles)\r\n        for bundle in bundlesOfGroup:\r\n            # For each bundle make a single list (bundleKeywords) and search if any of the keywords other user send are in there then send back\r\n            name = bundle.name.split()\r\n            desc = bundle.description.split()\r\n            bundleKeywords = name + desc\r\n            # print(\"Bundle Keywords : \",bundleKeywords)\r\n            # print(\"Request Keywords : \",req.keywords)\r\n            if any(keyword in req.keywords for keyword in bundleKeywords):\r\n                # print(\"HIT\")\r\n                responseBundles.append({\"id\": bundle.id, \"name\": bundle.name, \"description\": bundle.description})\r\n        # Create Response and return it to be used as answer\r\n        # print(responseBundles)\r\n        searchResponse = SearchBundleResponse(responseBundles)\r\n        # print(\"Search Response :\",searchResponse)\r\n        return pickle.dumps(searchResponse)\r\n\r\n    elif req.type == 3:\r\n        req = GetBundleRequest(req.bundleId, req.groupId, req.portForBundleReceiver)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        bundle = group.getBundleWithId(req.bundleId)\r\n        bundleReceiver = threading.Thread(target=sendBundle,\r\n                                          args=[addr, req.portForBundleReceiver, groupManager, group, bundle])\r\n        bundleReceiver.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        # TODO 9/4 ????\r\n        return pickle.dumps(GetBundleResponse(1))\r\n\r\n    elif req.type == 4:\r\n        req = CheckBundleAvailabilityRequest(req.bundleId, req.groupId)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        bundle = group.getBundleWithId(req.bundleId)\r\n        if bundle is False:\r\n            # Not Found\r\n            return pickle.dumps(CheckBundleAvailabilityResponse(0))\r\n        else:\r\n            # Found\r\n            return pickle.dumps(CheckBundleAvailabilityResponse(1))\r\n\r\n    elif req.type == 5:\r\n        # print(\"Received Request To Send File\")\r\n        req = DownloadBundleRequest(req.bundleId, req.groupId, req.file, req.port)\r\n        uploadThread = threading.Thread(target=uploadBundle,\r\n                                        args=[addr, req.port, req.bundleId, req.groupId, req.file, groupManager])\r\n        uploadThread.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        # TODO 9/4 ????\r\n        return pickle.dumps(DownloadBundleResponse(1))\r\n\r\n    elif req.type == 6:\r\n        req = UpdateBlockchainRequest(req.groupId)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        # If i am in group for group that im not in.\r\n        if group is not False:\r\n            if group.blockchain.isUserAllowed(addr[0]):\r\n                # User is ok\r\n                lastBlock = group.blockchain.getLastBlock()\r\n                lastBlock: Blockchain.Block\r\n                lastBlockIndex = lastBlock.index\r\n                return pickle.dumps(UpdateBlockchainResponse(lastBlockIndex))\r\n            else:\r\n                # User not invited not joined, therefore don't answer.\r\n                return False\r\n\r\n    elif req.type == 7:\r\n        req = GetBlockRequest(req.groupId, req.blockIndex)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        block = group.blockchain.getBlockWithIndex(req.blockIndex)\r\n        if block is not False:\r\n            return pickle.dumps(GetBlockResponse(block))\r\n        else:\r\n            return False\r\n\r\n    elif req.type == 8:\r\n        req = GetSignatureRequest(req.groupId, req.lastIndex, req.transaction)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        lastIndex = group.blockchain.getLastBlockIndex()\r\n        #If up to date or more\r\n        if lastIndex==req.lastIndex:\r\n            #Up To date\r\n            if group.blockchain.verifyTransaction(req.transaction):\r\n                #Transaction Ok\r\n                signature = rsa.sign(transactionStr.encode(), group.client.privateKey, 'SHA-1')\r\n                return pickle.dumps(GetSignatureResponse(str(signature.hex())))\r\n            else:\r\n                #Transaction not ok.\r\n                return pickle.dumps(GetSignatureResponse(1))\r\n\r\n        else:\r\n            #Not up to date.\r\n            return pickle.dumps(GetSignatureResponse(0))\r\n\r\n\r\ndef responseHandler(data, addr):\r\n    res = pickle.loads(data)\r\n\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 2:\r\n        res = SearchBundleResponse(res.responseBundles)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 3:\r\n        res = SearchBundleResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 4:\r\n        res = CheckBundleAvailabilityResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 5:\r\n        res = DownloadBundleResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 6:\r\n        res = UpdateBlockchainResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 7:\r\n        res = GetBlockResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n    elif res.type == 8:\r\n        res = GetSignatureResponse(res.answer)\r\n        print(f\"Received from {addr[0]}:{addr[1]} {res.__class__.__name__}\")\r\n        return res\r\n\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        try:\r\n            # RECEIVE AND RESPOND.\r\n            data, addr = sock.recvfrom(65537)\r\n            # data, addr = sock.recvfrom(65507)\r\n            # print(\"Received from :\", addr)\r\n            response = requestHandler(data, addr, groupManager)\r\n            # Request Handler if not want to answer returns False.\r\n            if response is not False:\r\n                sock.sendto(response, addr)\r\n        except Exception as e:\r\n            pass\r\n\r\n\r\ndef sendRequest(address, port, request):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.settimeout(1)\r\n    try:\r\n        clientSocket.sendto(request, (address, port))\r\n        data, addr = clientSocket.recvfrom(65537)\r\n        res = responseHandler(data, addr)\r\n        return res\r\n    # TODO except socket.timeout\r\n    except Exception as exception:\r\n        # print(\"Exception on SendRequest:\", exception)\r\n        return False\r\n\r\n\r\ndef receiveBundle(port, client, groupManager, groupId, downloadManager):\r\n    # print(\"RECEIVING BUNDLE THREAD\")\r\n    bundleBytes = b\"\"\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.bind((\"0.0.0.0\", port))\r\n        # print(\"Bundle Receiver Ready\")\r\n        s.listen()\r\n        conn, addr = s.accept()\r\n        with conn:\r\n            print(f\"Connection From {addr[0]}:{addr[1]} Accepted.\")\r\n            while True:\r\n                data = conn.recv(1024)\r\n                # print(data)\r\n                bundleBytes = bundleBytes + data\r\n                # TODO save Bytes to group and downloads also start downloading.\r\n                if not data:\r\n                    # print(\"Break\")\r\n                    break\r\n            # print(\"Break3\")\r\n    # print(\"Bundle Str\",bundleBytes.decode())\r\n    bundleObj = json.loads(bundleBytes.decode())\r\n    # Fix Bundle Root to be downloaded and location\r\n    client: Client.Client\r\n    bundleObj[\"root\"] = client.DIR_PATH_DOWNLOADS\r\n    bundle = Bundle(bundleObj[\"name\"], bundleObj[\"description\"], bundleObj[\"id\"], bundleObj[\"timestamp\"],\r\n                    bundleObj[\"root\"], bundleObj[\"pieceSize\"], bundleObj[\"files\"])\r\n    group = groupManager.getGroupWithId(groupId)\r\n    groupManager.addBundle(bundle, group.name)\r\n    downloadManager.downloadBundle(bundle, group)\r\n\r\n\r\ndef sendBundle(addr, port, groupManager, group, bundle):\r\n    # print(\"SENDING BUNDLE THREAD\")\r\n    group: Group\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.connect((addr[0], port))\r\n        print(f\"Connected To {addr[0]}:{addr[1]}.\")\r\n        # print(\"SENDING DATA\")\r\n        groupManager: GroupManager\r\n        json_file_name = bundle.name + \".json\"\r\n        bundleDir = groupManager.DIR_PATH_GROUPS + group.name + \"\\\\\" + \"Bundles\" + \"\\\\\" + json_file_name\r\n        print(bundleDir)\r\n        print(json_file_name)\r\n        with open(bundleDir) as f:\r\n            bundleContent = f.read()\r\n            bundleObj = json.loads(bundleContent)\r\n            bundleObj[\"root\"] = \"\"\r\n            bundleStr = json.dumps(bundleObj)\r\n\r\n        s.sendall(bundleStr.encode())\r\n\r\n\r\ndef is_port_in_use(port: int) -> bool:\r\n    import socket\r\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\r\n        return s.connect_ex(('localhost', port)) == 0\r\n\r\n\r\ndef downloadBundle(downloadManager, port, peer, file, bundle, usedPeers, freeFiles):\r\n    pieceList = []\r\n    # Find pieces missing\r\n    for x in bundle.files:\r\n        if x[\"path\"] == file[0]:\r\n            pieceList = x[\"pieces\"]\r\n            break\r\n    # pieceList = [[0, '5920572cf97d3711a77a9b7a3469a5fd03bb2a8a', 0]]\r\n    # print(\"DOWNLOADING BUNDLE THREAD\")\r\n    filePath = bundle.root + f\"\\\\{bundle.name}\" + file[0]\r\n    dir = filePath.rsplit('\\\\', 1)[0]\r\n    # print(dir)\r\n    # Create Directory's that don't exist.\r\n    isExist = os.path.exists(dir)\r\n    if not isExist:\r\n        # Create a new directory because it does not exist\r\n        os.makedirs(dir)\r\n\r\n    if os.path.exists(filePath) is False:\r\n        print(\"Creating File\")\r\n        file = open(filePath, 'x')\r\n        file.close()\r\n\r\n    with open(filePath, 'rb+') as openfileobject:\r\n        with socket(AF_INET, SOCK_STREAM) as s:\r\n            s.bind((\"0.0.0.0\", port))\r\n            # print(\"Bundle Receiver Ready\")\r\n            s.listen()\r\n            conn, addr = s.accept()\r\n            with conn:\r\n                print(f\"Connection From {addr[0]}:{addr[1]} Accepted.\")\r\n                data = conn.recv(1024)\r\n                if data.decode() == \"OK\":\r\n                    # print(\"Received Ok\")\r\n                    for piece in pieceList:\r\n                        if piece[2] == 0:\r\n                            # print(f\"Sending Piece num {piece[0]} \")\r\n                            conn.sendall(str(piece[0]).encode())\r\n                            openfileobject.seek(piece[0] * bundle.pieceSize)\r\n                            data = conn.recv(100000)\r\n                            # print(f\"Received {data}\")\r\n                            if hashlib.sha1(data).hexdigest() == piece[1]:\r\n                                # print(\"HASH OK\")\r\n                                openfileobject.write(data)\r\n                                piece[2] = 1\r\n                                # print(piece)\r\n                            else:\r\n                                pass\r\n                                # print(\"hashes dont match\")\r\n                    # delimmiter for data\r\n                    conn.sendall(\"\uD83E\uDD6D\uD83C\uDF53\uD83C\uDF47\uD83C\uDF49\uD83C\uDF50\uD83E\uDD67\uD83C\uDF4A\uD83C\uDF4D\uD83C\uDF4F\uD83E\uDD51\uD83C\uDF51\uD83C\uDF4C\uD83C\uDF4E\uD83C\uDF50\uD83C\uDF49\uD83C\uDF47\uD83C\uDF53\uD83E\uDD6D\uD83E\uDD5D\uD83C\uDF52\uD83C\uDF45\".encode())\r\n                    usedPeers.remove(peer)\r\n                    downloadManager.saveBundle(bundle)\r\n    # print(f\"Thread Exit {file}\")\r\n\r\n\r\ndef uploadBundle(addr, port, bundleId, groupId, file, groupManager):\r\n    # print(\"SENDING BUNDLE THREAD\")\r\n    group = groupManager.getGroupWithId(groupId)\r\n    bundle = group.getBundleWithId(bundleId)\r\n    with open(bundle.root + file, 'rb') as openfileobject:\r\n        try:\r\n            with socket(AF_INET, SOCK_STREAM) as s:\r\n                s.connect((addr[0], port))\r\n                # print(\"SENDING DATA\")\r\n                s.sendall(\"OK\".encode())\r\n                while True:\r\n                    piece = s.recv(1024)\r\n                    # delimmiter for data\r\n                    if piece == \"\uD83E\uDD6D\uD83C\uDF53\uD83C\uDF47\uD83C\uDF49\uD83C\uDF50\uD83E\uDD67\uD83C\uDF4A\uD83C\uDF4D\uD83C\uDF4F\uD83E\uDD51\uD83C\uDF51\uD83C\uDF4C\uD83C\uDF4E\uD83C\uDF50\uD83C\uDF49\uD83C\uDF47\uD83C\uDF53\uD83E\uDD6D\uD83E\uDD5D\uD83C\uDF52\uD83C\uDF45\".encode():\r\n                        break\r\n                    else:\r\n                        if piece == b'':\r\n                            # print(\"Empty\")\r\n                            pass\r\n                        else:\r\n                            piece = int(piece.decode())\r\n                            # print(f\"Trying to send {piece}\")\r\n                            openfileobject.seek(piece * bundle.pieceSize)\r\n                            readData = openfileobject.read(bundle.pieceSize)\r\n                            s.sendall(readData)\r\n        except ConnectionResetError as exception:\r\n            print(\"Downloader DC\")\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/Networking.py b/Networking.py
---- a/Networking.py	(revision de59e92006cbb426c6bb20267c11c6488949315e)
-+++ b/Networking.py	(date 1650894635864)
-@@ -10,6 +10,7 @@
- import os
- import hashlib
- import Blockchain
-+import rsa
- 
- 
- class Request:
-@@ -236,7 +237,8 @@
-             #Up To date
-             if group.blockchain.verifyTransaction(req.transaction):
-                 #Transaction Ok
--                signature = rsa.sign(transactionStr.encode(), group.client.privateKey, 'SHA-1')
-+                signature = rsa.sign(req.transaction.encode(), group.client.privateKey, 'SHA-1')
-+                print(f"Signature:{signature}")
-                 return pickle.dumps(GetSignatureResponse(str(signature.hex())))
-             else:
-                 #Transaction not ok.
Index: .idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_14_AM_[Changes]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_14_AM_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_14_AM_[Changes]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_24-Apr-22_10_14_AM_[Changes]/shelved.patch	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,21 +0,0 @@
-Index: main.py
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>import json\r\nimport logging\r\nimport threading\r\nfrom pickle import dumps, loads\r\nfrom flask import Flask, render_template, request, redirect\r\n\r\nimport Blockchain\r\nimport Compress\r\nfrom Networking import receiver, sendRequest, JoinRequest, SearchBundleRequest, receiveBundle, GetBundleRequest\r\nfrom Groups import GroupManager, Invite, Group\r\nfrom Client import Client\r\nimport easygui\r\nfrom Bundles import BundleManager\r\nfrom Downloads import DownloadManager\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = False\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    progress = downloadManager.getDownloadProgress()\r\n    return render_template(\"index.html\", groups=groupManager.groups, client=client, progress=progress)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    group = groupManager.getGroupWithName(group)\r\n    # Check if user should see admin panels.\r\n    peers, bans, admins, owner = group.blockchain.parseBlockchain()\r\n    print(peers,admins,bans)\r\n    # Check privs what to show on group page.\r\n    adminPriv = False\r\n    for admin in group.admins:\r\n        if admin[0] == client.publicIP:\r\n            adminPriv = True\r\n\r\n    ownerPriv = False\r\n    if group.blockchain.getOwner() == client.publicIP:\r\n        ownerPriv = True\r\n\r\n\r\n\r\n\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group, client=client, adminPriv=adminPriv,\r\n                           ownerPriv=ownerPriv, peers=peers, bans=bans, admins=admins)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    if downloadManager.STATUS:\r\n        downloadManager.STATUS = False\r\n        # downloadManager Off\r\n        print(\"Download Manager Not Active\")\r\n        return \"0\"\r\n    else:\r\n        downloadManager.STATUS = True\r\n        # downloadManager On\r\n        print(\"Download Manager Active\")\r\n        return \"1\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n        # TODO KEY SPECIFIC BLOCKCHAIN\r\n        ip = data[\"ip\"]  # This is string\r\n        transaction = Blockchain.InviteTransaction(ip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        # print(\"Generate Invite for :\", group)\r\n        # print(group)\r\n        invite = group.generateInvite()\r\n        return Compress.compress(invite.toJSON())\r\n\r\n\r\n\r\n@app.route('/deleteBundle', methods=['POST'])\r\ndef deleteBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupId = data[\"groupId\"]\r\n        bundleId = data[\"bundleId\"]\r\n        if groupManager.deleteBundle(groupId, bundleId):\r\n            return \"1\"\r\n        else:\r\n            return \"0\"\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        inviteDecomp = Compress.decompress(invite)\r\n        inviteLoad = json.loads(inviteDecomp)\r\n        invite = Invite(inviteLoad[\"id\"], inviteLoad[\"name\"], inviteLoad[\"timestamp\"], inviteLoad[\"peers\"])\r\n        joinReq = JoinRequest(invite.name, invite.timestamp)\r\n        print(invite.peers)\r\n        for peer in invite.peers:\r\n            print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq))\r\n            if res is not False:\r\n                # Response from user with group data.\r\n                group = res.group\r\n                group = Group(group.name, group.admins, group.peers, group.timestamp,\r\n                              blockchainPath=groupManager.DIR_PATH_GROUPS + group.name + \"\\\\Blockchain\", client=client)\r\n                groupManager.addGroup(group)\r\n                # Make Join Transaction.\r\n                transaction = Blockchain.JoinTransaction(client.publicIP,\r\n                                                         client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n                transactionStr = json.dumps(transaction.__dict__)\r\n                group.blockchain.addNewTransaction(transactionStr)\r\n                return \"1\"\r\n        # No responses.\r\n        return \"0\"\r\n\r\n\r\n@app.route('/shareBundle', methods=['POST'])\r\ndef shareBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"bundleName\"]\r\n        desc = data[\"bundleDescription\"]\r\n        groupName = data[\"groupName\"]\r\n        print(name)\r\n        print(desc)\r\n        print(groupName)\r\n        path = easygui.diropenbox(msg=\"Select folder to share as bundle\", title=\"Share Bundle\")\r\n        bundle = bundleManager.createBundle(name, desc, path=path)\r\n        groupManager.addBundle(bundle, groupName)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/selectDownloadLocation', methods=['POST'])\r\ndef selectDownloadLocation():\r\n    if request.method == 'POST':\r\n        path = easygui.diropenbox(msg=\"Select folder to download bundles\", title=\"Select Bundle Download Location\")\r\n        print(path)\r\n        # Update Download Path in Config\r\n        client.DIR_PATH_DOWNLOADS = path\r\n        client.saveConfig()\r\n        # Return path to browser and update it in modal\r\n        return path\r\n\r\n\r\n@app.route('/searchBundles', methods=['POST'])\r\ndef searchBundles():\r\n    # print(\"Search Bundles Route\")\r\n    if request.method == 'POST':\r\n        data = request.form\r\n\r\n        # Get Keywords from search\r\n        keywords = data[\"searchKeyWords\"].split()\r\n        # print(\"Search for :\",keywords)\r\n\r\n        # Get Group\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n\r\n        searchReq = SearchBundleRequest(group.id, keywords)\r\n        responses = []\r\n        # SEND TO ALL PEERS COLLECT RESPONSES AND PRESENT\r\n        for peer in group.peers:\r\n            res = sendRequest(peer[0], 6700, dumps(searchReq))\r\n            # if other peer is responded.\r\n            if res is not False:\r\n                # print(res)\r\n                responses.append([peer[0], res])\r\n            else:\r\n                print(\"No Response from\", peer[0])\r\n        # Merge all responses to single list\r\n        # for x in responses:\r\n        #     print(\"Response:\",x[0],x[1],x[1].responseBundles)\r\n        # WITH RESPONSES DO STUFF.\r\n        # Respond\r\n        return render_template(\"search.html\", groups=groupManager.groups, group=group, responses=responses)\r\n\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n    if groupManager.createGroup(name, [client.publicIP]):\r\n        # Make First Block In Blockchain Append Admin\r\n        # Type 0 First Created\r\n        group = groupManager.getGroupWithName(name)\r\n        group.blockchain.createGenesisBlock(client)\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n\r\n@app.route('/getBundle', methods=['POST'])\r\ndef getBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        bundleId = data[\"bundleId\"]\r\n        groupId = data[\"groupId\"]\r\n        userIp = data[\"userIp\"]\r\n        # TODO dynamic port on receiver for bundle\r\n        portForBundleReceiver = 6701\r\n        bundleReceiver = threading.Thread(target=receiveBundle,\r\n                                          args=[portForBundleReceiver, client, groupManager, groupId, downloadManager])\r\n        bundleReceiver.start()\r\n        getBundleReq = GetBundleRequest(bundleId, groupId, portForBundleReceiver)\r\n        res = sendRequest(userIp, 6700, dumps(getBundleReq))\r\n        # if other peer is responded.\r\n        if res is not False:\r\n            # Responded decide what to do\r\n            pass\r\n        else:\r\n            # print(\"No Response from\", userIp)\r\n            pass\r\n    return \"1\"\r\n\r\n\r\n@app.route('/quitGroup', methods=['POST'])\r\ndef quitGroup():\r\n    # print('QUIT GROUP REQ')\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        if groupManager.quitGroup(group):\r\n            # True\r\n            return \"0\"\r\n        else:\r\n            # False\r\n            return \"1\"\r\n\r\n\r\n@app.route('/banUser', methods=['POST'])\r\ndef banUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.BanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/unbanUser', methods=['POST'])\r\ndef unbanUser():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.UnbanTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/addAdmin', methods=['POST'])\r\ndef addAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.AddAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\n@app.route('/removeAdmin', methods=['POST'])\r\ndef removeAdmin():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        userip = data[\"userip\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        transaction = Blockchain.RemoveAdminTransaction(userip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.addNewTransaction(transactionStr)\r\n        return \"0\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    groupManager = GroupManager(client)\r\n    bundleManager = BundleManager()\r\n    downloadManager = DownloadManager(groupManager, client)\r\n    # TODO Networking Thread To Receive From Internet\r\n    receiver = threading.Thread(target=receiver, args=[groupManager])\r\n    receiver.start()\r\n    app.run(host='', port=6969)\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/main.py b/main.py
---- a/main.py	(revision 89f58d86798a008f0ace79236ed5092e42720ff6)
-+++ b/main.py	(date 1650784378666)
-@@ -34,7 +34,10 @@
-     group = groupManager.getGroupWithName(group)
-     # Check if user should see admin panels.
-     peers, bans, admins, owner = group.blockchain.parseBlockchain()
-+
-     print(peers,admins,bans)
-+    # print(group.admins)
-+    # print(group.peers)
-     # Check privs what to show on group page.
-     adminPriv = False
-     for admin in group.admins:
Index: .idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_4_03_PM__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_4_03_PM__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_4_03_PM__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_4_03_PM__Changes_.xml	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
+++ /dev/null	(revision 84361d67f8284c5aadd8af0501266ddb908f93e9)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_21-Apr-22_4_03_PM_[Changes]" date="1650546203310" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_21-Apr-22_4_03_PM_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 21-Apr-22 4:03 PM [Changes]" />
-</changelist>
\ No newline at end of file
