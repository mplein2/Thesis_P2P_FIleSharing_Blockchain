Index: Blockchain.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import math\r\nimport os\r\nimport json\r\nfrom os import listdir\r\nimport rsa\r\nimport time\r\nfrom time import sleep\r\nimport threading\r\nfrom hashlib import sha256\r\nimport copy\r\nfrom pickle import dumps, loads\r\n\r\n\r\nclass Block:\r\n    def __init__(self, index, transaction, timestamp, previous_hash, signatures):\r\n        self.index = index\r\n\r\n        self.transaction = transaction\r\n\r\n        self.timestamp = timestamp\r\n\r\n        self.previous_hash = previous_hash\r\n\r\n        self.signatures = signatures\r\n\r\n    def computeHash(self):\r\n        mycopy = copy.copy(self)\r\n        del mycopy.signatures\r\n        # print(mycopy.__dict__)\r\n        if hasattr(mycopy, 'hash'):\r\n            del mycopy.hash\r\n        block_string = json.dumps(mycopy.__dict__, sort_keys=True)\r\n        return sha256(block_string.encode()).hexdigest()\r\n\r\n\r\nclass UnconfirmedTransaction:\r\n    def __init__(self, transaction, signatures=[]):\r\n        self.transaction = transaction\r\n        self.signatures = signatures\r\n\r\n\r\nclass GenesisTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 0\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass InviteTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 1\r\n        self.ip = ip\r\n\r\n\r\nclass JoinTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 2\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass BanTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 3\r\n        self.ip = ip\r\n\r\n\r\nclass UnbanTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 4\r\n        self.ip = ip\r\n\r\n\r\nclass AddAdminTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 5\r\n        self.ip = ip\r\n\r\n\r\nclass RemoveAdminTransaction:\r\n    def __init__(self, ip):\r\n        self.type = 6\r\n        self.ip = ip\r\n\r\n\r\nclass Blockchain:\r\n    def __init__(self, path, groupPeers, groupAdmins, groupId, client):\r\n        self.BLOCKCHAIN_PATH = path\r\n        self.TRANSACTION_PATH = self.BLOCKCHAIN_PATH + \"\\\\Transactions\\\\\"\r\n        self.unconfirmed_transactions = []\r\n        self.chain = []\r\n        self.peers = groupPeers\r\n        self.groupId = groupId\r\n        self.groupAdmins = groupAdmins\r\n        self.client = client\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n            # Load Unconfirmed Transactions\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n\r\n        self.loadTransactions()\r\n\r\n        # print(self.unconfirmed_transactions)\r\n        # Load Blocks here\r\n        blockFiles = [f for f in listdir(self.BLOCKCHAIN_PATH) if os.path.isfile(os.path.join(self.BLOCKCHAIN_PATH, f))]\r\n        for blockFile in blockFiles:\r\n            self.loadBlock(blockFile)\r\n\r\n        # Start Casual Operations.\r\n        # Thread This.\r\n        miner = threading.Thread(target=self.mine, args=[client])\r\n        miner.start()\r\n        # print(self.unconfirmed_transactions)\r\n        # for block in self.chain:\r\n        #     print(block)\r\n\r\n    def getDifficulty(self):\r\n        # Diffuculty of blockchain will be dependent on the users participating\r\n        # TODO refactor this for join ban unban\r\n        if len(self.peers) == 0:\r\n            return 1\r\n        else:\r\n            peers, bans, admins, owner = self.parseBlockchain()\r\n            return math.floor(math.log2(len(peers)))\r\n\r\n    def createGenesisBlock(self, client):\r\n        transaction = GenesisTransaction(client.publicIP, client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        # this is string json format\r\n        # print(transactionStr)\r\n        # print(transactionStr.__class__)\r\n        # Genereate signature for Transaction\r\n        signature = rsa.sign(transactionStr.encode(), client.privateKey, 'SHA-1')\r\n        genesis_block = Block(0, transactionStr, str(time.time()), \"0\", [str(signature)])\r\n        genesis_block.hash = genesis_block.computeHash()\r\n        self.saveBlock(genesis_block)\r\n        self.chain.append(genesis_block)\r\n\r\n    def saveBlock(self, block):\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Creating Blockchain Folder\")\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n        blockFile = open(self.BLOCKCHAIN_PATH + \"\\\\Block\" + str(block.index) + \".json\", \"w\")\r\n        # print(block.__dict__)\r\n        blockFile.write(json.dumps(block.__dict__))\r\n        blockFile.close()\r\n\r\n    def loadTransactions(self):\r\n        filePath = self.TRANSACTION_PATH + \"Transactions.json\"\r\n        if os.path.exists(filePath):\r\n            try:\r\n                file = open(filePath)\r\n                # print(file)\r\n                json_load_group = json.load(file)\r\n                file.close()\r\n            except Exception as e:\r\n                print(\"Error Opening Transaction file :\", e)\r\n            for x in json_load_group:\r\n                transaction = UnconfirmedTransaction(x[\"transaction\"], x[\"signatures\"])\r\n                # print(transaction)\r\n                self.unconfirmed_transactions.append(transaction)\r\n            # print(self.unconfirmed_transactions)\r\n\r\n    def loadBlock(self, blockFiles):\r\n        # print(blockFiles)\r\n        filePath = self.BLOCKCHAIN_PATH + \"\\\\\" + blockFiles\r\n        file = open(filePath)\r\n        # print(file)\r\n        block = json.load(file)\r\n        file.close()\r\n        # # print(block)\r\n        # transaction = json.loads(block[\"transaction\"])\r\n        # # print(transaction)\r\n        # # print(transaction.__class__)\r\n        # # Make transaction here\r\n        # if transaction[\"type\"] == 0:\r\n        #     # print(\"Genesis block\")\r\n        #     transactionObj = GenesisTransaction(transaction[\"ip\"], transaction[\"publicKey\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        blockObj = Block(block[\"index\"], block[\"transaction\"], block[\"timestamp\"], block[\"previous_hash\"],\r\n                         block[\"signatures\"])\r\n        blockObj.hash = block[\"hash\"]\r\n        # TODO Add all transactions here\r\n\r\n        # elif transaction[\"type\"] == 1:\r\n        #     # print(\"Genesis block\")\r\n        #     # print(transaction)\r\n        #     transactionObj = InviteTransaction(transaction[\"ip\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        #     blockObj = Block(block[\"index\"], transactionStr, block[\"timestamp\"], block[\"previous_hash\"],\r\n        #                      block[\"signatures\"])\r\n        #     blockObj.hash = block[\"hash\"]\r\n\r\n        self.chain.append(blockObj)\r\n        # print(blockObj.__dict__)\r\n\r\n    def addNewTransaction(self, transaction: str):\r\n        newUnconfirmedTransaction = UnconfirmedTransaction(transaction)\r\n        self.unconfirmed_transactions.append(newUnconfirmedTransaction)\r\n        self.saveUnconfirmedTransactions()\r\n\r\n    def updateBlockchain(self, client):\r\n        for peer in self.peers:\r\n            # Dont send to self\r\n            if peer[0] != client.publicIP:\r\n                # For each peer ask their max index of blockchain\r\n                updateBlockchainReq = Networking.UpdateBlockchainRequest(self.groupId)\r\n                res = Networking.sendRequest(peer[0], 6700, dumps(updateBlockchainReq))\r\n                if res is not False:\r\n                    # if the response is bigger than me ask him for his block until we are at the same.\r\n                    if res.answer > self.getLastBlockIndex():\r\n                        print(self.getLastBlockIndex().__class__, res.answer.__class__)\r\n                        while self.getLastBlockIndex() < res.answer:\r\n                            # Get block\r\n                            getBlockReq = Networking.GetBlockRequest(self.groupId, self.getLastBlockIndex() + 1)\r\n                            blockRes = Networking.sendRequest(peer[0], 6700, dumps(getBlockReq))\r\n                            if blockRes is not False:\r\n                                print(f\"Update BC Response:{blockRes}\")\r\n                                # print(blockRes.answer)\r\n                                block = blockRes.answer\r\n                                block: Block\r\n                                print(block.index, block.transaction, block.signatures, block.timestamp,\r\n                                      block.previous_hash, block.hash)\r\n                                newBlock = Block(block.index, block.transaction, block.timestamp, block.previous_hash,\r\n                                                 block.signatures)\r\n                                newBlock.hash = block.hash\r\n                                if self.validateNewBlock(newBlock):\r\n                                    self.saveBlock(newBlock)\r\n                                    self.chain.append(newBlock)\r\n                            else:\r\n                                break\r\n                    else:\r\n                        # print(id(self.peers))\r\n                        peers, bans, admins, owner = self.parseBlockchain()\r\n                        # self.peers = peers\r\n                        # self.groupAdmins = admins\r\n                        # print(id(self.peers))\r\n                        # print(\"Blockchain Updated And Parsed\")\r\n                        # print(\"Up-to-date.\")\r\n                        pass\r\n\r\n        #Update Group Peers And Admins\r\n        peers, bans, admins, owner = self.parseBlockchain()\r\n        for ip in admins:\r\n            inside = False\r\n            for admin in self.groupAdmins:\r\n                if admin[0]==ip:\r\n                    inside = True\r\n            if not inside:\r\n                self.groupAdmins.append([ip])\r\n\r\n\r\n        for ip in peers:\r\n            inside = False\r\n            for peer in self.peers:\r\n                if peer[0]==ip:\r\n                    inside = True\r\n            if not inside:\r\n                self.peers.append([ip])\r\n\r\n\r\n    def getBlockWithIndex(self, index):\r\n        for block in self.chain:\r\n            block: Block\r\n            if block.index == index:\r\n                return block\r\n        return False\r\n\r\n    def validateNewBlock(self, newBlock):\r\n        \"\"\"This function is for new blocks that come from peers returns true if blocks checks out.\"\"\"\r\n        newBlock: Block\r\n\r\n        # If hash ok.\r\n        if newBlock.computeHash() == newBlock.hash:\r\n            # Validation for genesis block\r\n            if newBlock.index == 0:\r\n                if self.getLastBlockIndex() == -1:\r\n                    # No other blocks accept it.\r\n                    return True\r\n                else:\r\n                    return False\r\n            else:\r\n                # Check if new block is made with the same previous block.\r\n                # TODO if not resolve ?\r\n                if newBlock.previous_hash == self.getLastBlock().computeHash():\r\n                    # TODO check if signatures okay.\r\n                    # TODO check timestamp.\r\n                    # TODO check difficulty based on blockchain etc.\r\n                    return True\r\n\r\n    def mine(self, client):\r\n        while True:\r\n            # Update Blockchain.\r\n            self.updateBlockchain(client)\r\n            if not self.unconfirmed_transactions:\r\n                # If No Transaction sleep and check again soon.\r\n                sleep(30)\r\n            else:\r\n                diff = self.getDifficulty()\r\n                print(f\"Blockchain Difficulty :{diff}\")\r\n                print(f\"Unconfirmed Transactions:{len(self.unconfirmed_transactions)}\")\r\n                for transaction in self.unconfirmed_transactions:\r\n                    transaction: UnconfirmedTransaction\r\n                    # For Each Transaction if signatures < difficulty collect transactions\r\n                    if diff > len(transaction.signatures):\r\n                        if not len(transaction.signatures):\r\n                            # No Signatures add my signature\r\n                            signature = rsa.sign(transaction.transaction.encode(), client.privateKey, 'SHA-1')\r\n                            transaction.signatures.append(str(signature))\r\n                            self.saveUnconfirmedTransactions()\r\n                        else:\r\n                            # Get Signatures from other persons.\r\n                            #TODO IMPORTANT.\r\n                            pass\r\n                    else:\r\n                        # We have the signatures number procede to make block and share.\r\n                        print(f\"Signature {transaction} ready to be made block.\")\r\n                        # Bytes\r\n                        lastBlock = self.getLastBlock()\r\n                        print(lastBlock)\r\n                        lastBlock: Block\r\n                        print(f\"Last Block Index :{lastBlock.index}\")\r\n                        newBlock = Block(lastBlock.index + 1, transaction.transaction, str(time.time()),\r\n                                         lastBlock.computeHash(), transaction.signatures)\r\n                        newBlock.hash = newBlock.computeHash()\r\n                        self.unconfirmed_transactions.remove(transaction)\r\n                        self.saveUnconfirmedTransactions()\r\n                        self.saveBlock(newBlock)\r\n                        self.chain.append(newBlock)\r\n                sleep(30)\r\n\r\n    def getLastBlock(self) -> Block:\r\n        lastBlockIndex = self.chain[0].index\r\n        # Find last Block and return it\r\n        lastBlock = self.chain[0]\r\n        for block in self.chain:\r\n            # print(block.index)\r\n            if block.index > lastBlockIndex:\r\n                lastBlock = block\r\n                lastBlockIndex = block.index\r\n        return lastBlock\r\n\r\n    def getLastBlockIndex(self):\r\n        if len(self.chain) == 0:\r\n            return -1\r\n        else:\r\n            lastBlockIndex = self.chain[0].index\r\n            # Find last Block and return it\r\n            lastBlock = self.chain[0]\r\n            for block in self.chain:\r\n                # print(block.index)\r\n                if block.index > lastBlockIndex:\r\n                    lastBlock = block\r\n                    lastBlockIndex = block.index\r\n            return lastBlock.index\r\n\r\n    def saveUnconfirmedTransactions(self):\r\n        # print(self.TRANSACTION_PATH)\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Blockchain Folder\")\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n        json_file = open(self.TRANSACTION_PATH + \"Transactions\" + \".json\", \"w\")\r\n        json_file.write((json.dumps([ob.__dict__ for ob in self.unconfirmed_transactions])))\r\n        json_file.close()\r\n\r\n    def isUserAllowed(self, ip):\r\n        for block in self.chain:\r\n            block: Block\r\n            transaction = json.loads(block.transaction)\r\n            # From Create Genesis Block\r\n            if transaction[\"type\"] == 0:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n            # From Invite\r\n            if transaction[\"type\"] == 1:\r\n                if transaction[\"ip\"] == ip:\r\n                    return True\r\n        # Didndt find user\r\n        return False\r\n\r\n    def getOwner(self):\r\n        for block in self.chain:\r\n            transaction = json.loads(block.transaction)\r\n            if transaction[\"type\"] == 0:\r\n                return transaction[\"ip\"]\r\n\r\n    def parseBlockchain(self):\r\n        \"\"\"\r\n        Parses Blockchain and returns 5 list of user types.\r\n        Peers that are in the blockchain and allowed.\r\n        Banned peers, Invites ,Admins and, Owner . All are lists.\r\n        \"\"\"\r\n        peers = []\r\n        bans = []\r\n        admins = []\r\n        invites = []\r\n        owner = []\r\n\r\n        for block in self.chain:\r\n            transaction = json.loads(block.transaction)\r\n            #GenesisTransactio\r\n            if transaction[\"type\"] == 0:\r\n                owner.append(transaction[\"ip\"])\r\n                admins.append(transaction[\"ip\"])\r\n                peers.append(transaction[\"ip\"])\r\n\r\n            #InviteTransaction\r\n            elif transaction[\"type\"] == 1:\r\n                invites.append(transaction[\"ip\"])\r\n\r\n            #JoinTransaction\r\n            elif transaction[\"type\"] == 2:\r\n                peers.append(transaction[\"ip\"])\r\n                invites.remove(transaction[\"ip\"])\r\n\r\n            #BanTransaction\r\n            elif transaction[\"type\"] == 3:\r\n                peers.remove(transaction[\"ip\"])\r\n                bans.append(transaction[\"ip\"])\r\n\r\n            # UnbanTransaction\r\n            elif transaction[\"type\"] == 4:\r\n                bans.remove(transaction[\"ip\"])\r\n\r\n                # AddAdminTransaction\r\n            elif transaction[\"type\"] == 5:\r\n                admins.append(transaction[\"ip\"])\r\n\r\n            # RemoveAdminTransaction\r\n            elif transaction[\"type\"] == 6:\r\n                admins.remove(transaction[\"ip\"])\r\n\r\n        # print(f\"Peers:{peers},Bans:{bans},Admins:{admins},Owners:{owner}\")\r\n        return peers, bans, admins, owner\r\n\r\n\r\nimport Networking\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Blockchain.py b/Blockchain.py
--- a/Blockchain.py	(revision d5d09b0699efe693ad225bc36ba9b6f59bdb84ae)
+++ b/Blockchain.py	(date 1650890195294)
@@ -405,8 +405,12 @@
 
         for block in self.chain:
             transaction = json.loads(block.transaction)
+            print(peers,invites)
+            print(transaction)
+
             #GenesisTransactio
             if transaction["type"] == 0:
+
                 owner.append(transaction["ip"])
                 admins.append(transaction["ip"])
                 peers.append(transaction["ip"])
@@ -418,7 +422,7 @@
             #JoinTransaction
             elif transaction["type"] == 2:
                 peers.append(transaction["ip"])
-                invites.remove(transaction["ip"])
+                                invites.remove(transaction["ip"])
 
             #BanTransaction
             elif transaction["type"] == 3:
