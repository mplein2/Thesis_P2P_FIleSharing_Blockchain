Index: Networking.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import socket\r\nfrom socket import *\r\nimport pickle\r\nimport copy\r\nimport Groups\r\nfrom threading import Thread\r\nfrom Groups import Group\r\nimport threading\r\n\r\n\r\nclass Request:\r\n    def __init__(self, type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self, name, timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self, group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\n\r\nclass SearchBundleRequest(Request):\r\n    def __init__(self, groupId, keyword):\r\n        super().__init__(2)\r\n        self.groupID = groupId\r\n        self.keywords = keyword\r\n\r\n\r\nclass SearchBundleResponse(Request):\r\n    def __init__(self, responseBundles):\r\n        super().__init__(2)\r\n        self.responseBundles = responseBundles\r\n\r\n\r\nclass GetBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId, portForBundleReceiver):\r\n        super().__init__(3)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.portForBundleReceiver = portForBundleReceiver\r\n\r\n\r\nclass GetBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(3)\r\n        self.answer = answer\r\n\r\n\r\ndef requestHandler(data, addr, groupManager: Groups.GroupManager):\r\n    req = pickle.loads(data)\r\n    # Response to JoinRequest\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name, req.timestamp)\r\n        # TODO If this is allowed add peer and respond\r\n        # TODO Peer Port\r\n        groupManager.addPeerGroup(req.name, [addr[0]])\r\n        group = groupManager.getGroup(req.name)\r\n        groupCpy = copy.copy(group)\r\n        del groupCpy.bundles\r\n        joinResponse = JoinResponse(groupCpy)\r\n        return pickle.dumps(joinResponse)\r\n\r\n    # Response to search req\r\n    elif req.type == 2:\r\n        # Create The Request again for local use\r\n        req = SearchBundleRequest(req.groupID, req.keywords)\r\n        # Get All Bundles User has\r\n        bundlesOfGroup = groupManager.getGroupWithID(req.groupID).bundles\r\n        # Bundles to reply\r\n        responseBundles = []\r\n        print(responseBundles)\r\n        for bundle in bundlesOfGroup:\r\n            # For each bundle make a single list (bundleKeywords) and search if any of the keywords other user send are in there then send back\r\n            name = bundle.name.split()\r\n            desc = bundle.description.split()\r\n            bundleKeywords = name + desc\r\n            # print(\"Bundle Keywords : \",bundleKeywords)\r\n            # print(\"Request Keywords : \",req.keywords)\r\n            if any(keyword in req.keywords for keyword in bundleKeywords):\r\n                # print(\"HIT\")\r\n                responseBundles.append({\"id\": bundle.id, \"name\": bundle.name, \"description\": bundle.description})\r\n        # Create Response and return it to be used as answer\r\n        # print(responseBundles)\r\n        searchResponse = SearchBundleResponse(responseBundles)\r\n        # print(\"Search Response :\",searchResponse)\r\n        return pickle.dumps(searchResponse)\r\n\r\n    elif req.type == 3:\r\n        req = GetBundleRequest(req.bundleId, req.groupId, req.portForBundleReceiver)\r\n        bundle = groupManager.getGroupWithID(req.groupId).getBundleWithId(req.bundleId)\r\n        bundleReceiver = threading.Thread(target=sendBundle, args=[addr, req.portForBundleReceiver, bundle])\r\n        bundleReceiver.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        return pickle.dumps(GetBundleResponse(1))\r\n\r\n\r\ndef responseHandler(data, groupManager):\r\n    res = pickle.loads(data)\r\n\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        return res\r\n\r\n    elif res.type == 2:\r\n        res = SearchBundleResponse(res.responseBundles)\r\n        return res\r\n\r\n    elif res.type == 3:\r\n        res = SearchBundleResponse(res.answer)\r\n        return res\r\n\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        # RECEIVE AND RESPOND.\r\n        data, addr = sock.recvfrom(65537)\r\n        # data, addr = sock.recvfrom(65507)\r\n        print(\"Received from :\", addr, \" data:\", data)\r\n        response = requestHandler(data, addr, groupManager)\r\n        sock.sendto(response, addr)\r\n\r\n\r\ndef sendRequest(address, port, request, groupManager):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.settimeout(1)\r\n    try:\r\n        clientSocket.sendto(request, (address, port))\r\n        data, addr = clientSocket.recvfrom(65537)\r\n        # data, addr = clientSocket.recvfrom(65507)\r\n        res = responseHandler(data, groupManager)\r\n        return res\r\n    # TODO except socket.timeout\r\n    # TODO for better exception handling fix later.\r\n    except Exception as exception:\r\n        print(\"Exception on SendRequest:\", exception)\r\n        return False\r\n\r\n\r\ndef receiveBundle(port):\r\n    print(\"RECEIVING BUNDLE THREAD\")\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.bind((\"0.0.0.0\", port))\r\n        print(\"Bundle Receiver Ready\")\r\n        s.listen()\r\n        conn, addr = s.accept()\r\n        with conn:\r\n            print(f\"Connected by {addr}\")\r\n            while True:\r\n                data = conn.recv(1024)\r\n                if not data:\r\n                    break\r\n                conn.sendall(data)\r\n\r\n\r\ndef sendBundle(addr, port, bundle):\r\n    print(\"SENDING BUNDLE THREAD\")\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.connect((addr[0], port))\r\n        print(\"SENDING DATA\")\r\n        s.send(b\"Hello, world\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Networking.py b/Networking.py
--- a/Networking.py	(revision a9f57153969459f60cc7b838b51ac0466479d04d)
+++ b/Networking.py	(date 1648820627744)
@@ -163,9 +163,15 @@
             print(f"Connected by {addr}")
             while True:
                 data = conn.recv(1024)
+                print(data)
                 if not data:
+                    # print("Break")
                     break
-                conn.sendall(data)
+#                print("Break2")
+#             print("Break3")
+#       print("Break4")
+#   print("Break5")
+
 
 
 def sendBundle(addr, port, bundle):
