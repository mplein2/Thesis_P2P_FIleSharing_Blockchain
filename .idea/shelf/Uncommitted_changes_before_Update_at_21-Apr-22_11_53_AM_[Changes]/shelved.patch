Index: Blockchain.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\r\nimport json\r\nfrom os import listdir\r\nimport rsa\r\nimport time\r\nfrom time import sleep\r\nimport threading\r\nfrom hashlib import sha256\r\nimport copy\r\nfrom pickle import dumps, loads\r\n\r\n\r\n\r\nclass Block:\r\n    def __init__(self, index, transaction, timestamp, previous_hash, signatures):\r\n        self.index = index\r\n\r\n        self.transaction = transaction\r\n\r\n        self.timestamp = timestamp\r\n\r\n        self.previous_hash = previous_hash\r\n\r\n        self.signatures = signatures\r\n\r\n    def compute_hash(self):\r\n        mycopy = copy.copy(self)\r\n        del mycopy.signatures\r\n        # print(mycopy.__dict__)\r\n        if hasattr(mycopy, 'hash'):\r\n            del mycopy.hash\r\n        block_string = json.dumps(mycopy.__dict__, sort_keys=True)\r\n        return sha256(block_string.encode()).hexdigest()\r\n\r\nclass UnconfirmedTransaction:\r\n    def __init__(self,transaction,signatures=[]):\r\n        self.transaction = transaction\r\n        self.signatures = signatures\r\n\r\n\r\nclass GenesisTransaction:\r\n    def __init__(self, ip, publicKey):\r\n        # Type of Transaction\r\n        self.type = 0\r\n        self.ip = ip\r\n        self.publicKey = publicKey\r\n\r\n\r\nclass InviteTransaction:\r\n    def __init__(self,ip):\r\n        self.type = 1\r\n        self.ip = ip\r\n\r\n\r\nclass Blockchain:\r\n    def __init__(self, path, groupPeers,groupId):\r\n        self.BLOCKCHAIN_PATH = path\r\n        self.TRANSACTION_PATH = self.BLOCKCHAIN_PATH + \"\\\\Transactions\\\\\"\r\n        self.unconfirmed_transactions = []\r\n        self.chain = []\r\n        self.peers = groupPeers\r\n        self.groupId = groupId\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n            # Load Unconfirmed Transactions\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # If Path dosent Exist Create it\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n\r\n\r\n        self.loadTransactions()\r\n\r\n        # print(self.unconfirmed_transactions)\r\n        # Load Blocks here\r\n        blockFiles = [f for f in listdir(self.BLOCKCHAIN_PATH) if os.path.isfile(os.path.join(self.BLOCKCHAIN_PATH, f))]\r\n        for blockFile in blockFiles:\r\n            self.loadBlock(blockFile)\r\n\r\n        # Start Casual Operations.\r\n        # Thread This.\r\n        miner = threading.Thread(target=self.mine, args=[])\r\n        miner.start()\r\n        # print(self.unconfirmed_transactions)\r\n        # for block in self.chain:\r\n        #     print(block)\r\n\r\n    def getDifficulty(self):\r\n        # Diffuculty of blockchain will be dependent on the users participating\r\n        # TODO refactor this for join ban unban\r\n        if len(self.peers) == 0:\r\n            return 1\r\n        else:\r\n            return len(self.peers)\r\n\r\n    def create_genesis_block(self, client):\r\n        transaction = GenesisTransaction(client.publicIP, client.publicKey.save_pkcs1(format='PEM').decode(\"utf-8\"))\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        # this is string json format\r\n        # print(transactionStr)\r\n        # print(transactionStr.__class__)\r\n        # Genereate signature for Transaction\r\n\r\n        signature = rsa.sign(transactionStr.encode(), client.privateKey, 'SHA-1')\r\n\r\n        # Bytes\r\n        # print(signature)\r\n        # print(signature.__class__)\r\n\r\n        genesis_block = Block(0, transactionStr, str(time.time()), \"0\", [str(signature)])\r\n        genesis_block.hash = genesis_block.compute_hash()\r\n        self.saveBlock(genesis_block)\r\n        self.chain.append(genesis_block)\r\n\r\n    def saveBlock(self, block):\r\n        if not os.path.exists(self.BLOCKCHAIN_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Creating Blockchain Folder\")\r\n            os.makedirs(self.BLOCKCHAIN_PATH)\r\n        blockFile = open(self.BLOCKCHAIN_PATH + \"\\\\Block\" + str(block.index) + \".json\", \"w\")\r\n        # print(block.__dict__)\r\n        blockFile.write(json.dumps(block.__dict__))\r\n        blockFile.close()\r\n\r\n    def loadTransactions(self):\r\n        filePath = self.TRANSACTION_PATH + \"Transactions.json\"\r\n        if os.path.exists(filePath):\r\n            try:\r\n                file = open(filePath)\r\n                # print(file)\r\n                json_load_group = json.load(file)\r\n                file.close()\r\n            except Exception as e:\r\n                print(\"Error Opening Transaction file :\", e)\r\n            for x in json_load_group:\r\n                transaction = UnconfirmedTransaction(x[\"transaction\"], x[\"signatures\"])\r\n                # print(transaction)\r\n                self.unconfirmed_transactions.append(transaction)\r\n            # print(self.unconfirmed_transactions)\r\n\r\n    def loadBlock(self, blockFiles):\r\n        # print(blockFiles)\r\n        filePath = self.BLOCKCHAIN_PATH + \"\\\\\" + blockFiles\r\n        file = open(filePath)\r\n        # print(file)\r\n        block = json.load(file)\r\n        file.close()\r\n        # # print(block)\r\n        # transaction = json.loads(block[\"transaction\"])\r\n        # # print(transaction)\r\n        # # print(transaction.__class__)\r\n        # # Make transaction here\r\n        # if transaction[\"type\"] == 0:\r\n        #     # print(\"Genesis block\")\r\n        #     transactionObj = GenesisTransaction(transaction[\"ip\"], transaction[\"publicKey\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        blockObj = Block(block[\"index\"], block[\"transaction\"], block[\"timestamp\"], block[\"previous_hash\"],\r\n                             block[\"signatures\"])\r\n        blockObj.hash = block[\"hash\"]\r\n        #TODO Add all transactions here\r\n\r\n        # elif transaction[\"type\"] == 1:\r\n        #     # print(\"Genesis block\")\r\n        #     # print(transaction)\r\n        #     transactionObj = InviteTransaction(transaction[\"ip\"])\r\n        #     transactionStr = json.dumps(transactionObj.__dict__)\r\n        #     blockObj = Block(block[\"index\"], transactionStr, block[\"timestamp\"], block[\"previous_hash\"],\r\n        #                      block[\"signatures\"])\r\n        #     blockObj.hash = block[\"hash\"]\r\n\r\n        self.chain.append(blockObj)\r\n            # print(blockObj.__dict__)\r\n\r\n    def add_new_transaction(self, transaction : str):\r\n        newUnconfirmedTransaction = UnconfirmedTransaction(transaction)\r\n        self.unconfirmed_transactions.append(newUnconfirmedTransaction)\r\n        self.save_unconfirmed_transactions()\r\n\r\n    def updateBlockchain(self):\r\n        responses = []\r\n        for peer in self.peers:\r\n            # print(\"Peer to ask for update:\",peer)\r\n            updateBlockchainReq = Networking.UpdateBlockchainRequest(self.groupId)\r\n            res = Networking.sendRequest(peer[0], 6700, dumps(updateBlockchainReq))\r\n            print(res)\r\n            if res is not False:\r\n                 responses.append(res)\r\n        if len(responses):\r\n            for x in res:\r\n                print(x.answer)\r\n            #Someone answered.\r\n            # update from responded peers until you have max blockchain thing .\r\n\r\n    def mine(self):\r\n        #Load my public key.\r\n        keyLoc = self.BLOCKCHAIN_PATH+\"..\\\\..\\\\..\\\\PRIVATEKEY.json\"\r\n        # print(f\"key location = {keyLoc}\")\r\n        f = open(keyLoc, \"rb\")\r\n        data = f.read()\r\n        privateKey = rsa.PrivateKey.load_pkcs1(data)\r\n        # print(publicKey)\r\n        f.close()\r\n        while True:\r\n                #Update Blockchain.\r\n                self.updateBlockchain()\r\n\r\n                if not self.unconfirmed_transactions:\r\n                    #If No Transaction sleep and check again soon.\r\n                    sleep(30)\r\n                else:\r\n                    diff = self.getDifficulty()\r\n                    print(f\"Blockchain Difficulty :{diff}\")\r\n                    print(f\"Unconfirmed Transactions:{len(self.unconfirmed_transactions)}\")\r\n                    for transaction in self.unconfirmed_transactions:\r\n                        transaction :UnconfirmedTransaction\r\n                        #For Each Transaction if signatures < difficulty collect transactions\r\n                        if diff>len(transaction.signatures):\r\n                            if not len(transaction.signatures):\r\n                                # No Signatures add my signature\r\n                                signature = rsa.sign(transaction.transaction.encode(),privateKey, 'SHA-1')\r\n                                transaction.signatures.append(str(signature))\r\n                                self.save_unconfirmed_transactions()\r\n                            else:\r\n                                #Get Signatures from other persons.\r\n                                pass\r\n                        else:\r\n                            #We have the signatures number procede to make block and share.\r\n                            print(f\"Signature {transaction} ready to be made block.\")\r\n                            # Bytes\r\n                            lastBlock = self.getLastBlock()\r\n                            print(lastBlock)\r\n                            lastBlock : Block\r\n                            print(f\"Last Block Index :{lastBlock.index}\")\r\n                            newBlock = Block(lastBlock.index+1, transaction.transaction, str(time.time()), lastBlock.compute_hash(),transaction.signatures)\r\n                            newBlock.hash = newBlock.compute_hash()\r\n                            self.unconfirmed_transactions.remove(transaction)\r\n                            self.save_unconfirmed_transactions()\r\n                            self.saveBlock(newBlock)\r\n                            self.chain.append(newBlock)\r\n                    sleep(30)\r\n\r\n    def getLastBlock(self):\r\n        lastBlockIndex = self.chain[0].index\r\n        #Find last Block and return it\r\n        lastBlock = self.chain[0]\r\n        for block in self.chain:\r\n            print(block.index)\r\n            if block.index > lastBlockIndex:\r\n                lastBlock = block\r\n                lastBlockIndex = block.index\r\n        return lastBlock\r\n\r\n\r\n    def save_unconfirmed_transactions(self):\r\n        # print(self.TRANSACTION_PATH)\r\n        if not os.path.exists(self.TRANSACTION_PATH):\r\n            # Create a new directory because it does not exist\r\n            # print(\"Blockchain Folder\")\r\n            os.makedirs(self.TRANSACTION_PATH)\r\n        json_file = open(self.TRANSACTION_PATH + \"Transactions\"+ \".json\", \"w\")\r\n        json_file.write((json.dumps([ob.__dict__ for ob in self.unconfirmed_transactions])))\r\n        json_file.close()\r\n\r\n    def isUserAllowed(self,ip):\r\n        for block in self.chain:\r\n            block : Block\r\n            transaction = json.loads(block.transaction)\r\n            if transaction[\"type\"]==1:\r\n                if transaction[\"ip\"]==ip:\r\n                    return True\r\n        return False\r\n\r\n\r\n\r\nimport Networking
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Blockchain.py b/Blockchain.py
--- a/Blockchain.py	(revision 7083ac7d2a09f8bc9830d05546c2e696de7a9374)
+++ b/Blockchain.py	(date 1650530012494)
@@ -193,7 +193,7 @@
 
     def mine(self):
         #Load my public key.
-        keyLoc = self.BLOCKCHAIN_PATH+"..\\..\\..\\PRIVATEKEY.json"
+        keyLoc = self.BLOCKCHAIN_PATH+"\\..\\..\\..\\PRIVATEKEY.json"
         # print(f"key location = {keyLoc}")
         f = open(keyLoc, "rb")
         data = f.read()
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import json\r\nimport logging\r\nimport threading\r\nfrom pickle import dumps, loads\r\nfrom flask import Flask, render_template, request, redirect\r\n\r\nimport Blockchain\r\nimport Compress\r\nfrom Networking import receiver, sendRequest, JoinRequest,SearchBundleRequest,receiveBundle,GetBundleRequest\r\nfrom Groups import GroupManager, Invite,Group\r\nfrom Client import Client\r\nimport easygui\r\nfrom Bundles import BundleManager\r\nfrom Downloads import DownloadManager\r\n\r\napp = Flask(__name__)\r\n\r\n# This Disables Logging\r\napp.logger.disabled = False\r\nlog = logging.getLogger('werkzeug')\r\nlog.disabled = False\r\n\r\n\r\n# Routes\r\n@app.route(\"/\")\r\ndef index():\r\n    progress = downloadManager.getDownloadProgress()\r\n    return render_template(\"index.html\", groups=groupManager.groups,client=client,progress=progress)\r\n\r\n\r\n@app.route(\"/groups\", methods=['GET'])\r\ndef groups():\r\n    group = request.args.get('group')\r\n    group = groupManager.getGroupWithName(group)\r\n    return render_template(\"groups.html\", groups=groupManager.groups, group=group)\r\n\r\n\r\n@app.route('/start', methods=['POST', 'GET'])\r\ndef start():\r\n    print(\"Start Worked\")\r\n    if downloadManager.STATUS:\r\n        downloadManager.STATUS = False\r\n        #downloadManager Off\r\n        print(\"Download Manager Not Active\")\r\n        return \"0\"\r\n    else:\r\n        downloadManager.STATUS = True\r\n        #downloadManager On\r\n        print(\"Download Manager Active\")\r\n        return \"1\"\r\n\r\n\r\n@app.route('/generateInvite', methods=['POST'])\r\ndef generateInvite():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n        # TODO KEY SPECIFIC BLOCKCHAIN\r\n        ip = data[\"ip\"] #This is string\r\n        transaction = Blockchain.InviteTransaction(ip)\r\n        transactionStr = json.dumps(transaction.__dict__)\r\n        group.blockchain.add_new_transaction(transactionStr)\r\n        # print(\"Generate Invite for :\", group)\r\n        # print(group)\r\n        invite = group.generateInvite()\r\n        return Compress.compress(invite.toJSON())\r\n\r\n@app.route('/deleteBundle', methods=['POST'])\r\ndef deleteBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupId = data[\"groupId\"]\r\n        bundleId = data[\"bundleId\"]\r\n        if groupManager.deleteBundle(groupId,bundleId):\r\n            return \"1\"\r\n        else:\r\n            return \"0\"\r\n\r\n\r\n@app.route('/joinGroup', methods=['POST'])\r\ndef joinGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        invite = data[\"invite\"]\r\n        inviteDecomp = Compress.decompress(invite)\r\n        inviteLoad = json.loads(inviteDecomp)\r\n        invite = Invite(inviteLoad[\"id\"],inviteLoad[\"name\"], inviteLoad[\"timestamp\"], inviteLoad[\"peers\"])\r\n        joinReq = JoinRequest(invite.name, invite.timestamp)\r\n        print(invite.peers)\r\n        for peer in invite.peers:\r\n            print(peer[0])\r\n            res = sendRequest(peer[0], 6700, dumps(joinReq))\r\n            if res is not False:\r\n                group = res.group\r\n                group = Group(group.name,group.admins,group.peers,group.timestamp,blockchainPath=groupManager.DIR_PATH_GROUPS+group.name+\"\\\\Blockchain\")\r\n                groupManager.addGroup(group)\r\n        #Make thread to update blockhain and get up to date.\r\n        #TODO\r\n        return \"1\"\r\n\r\n\r\n@app.route('/shareBundle', methods=['POST'])\r\ndef shareBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"bundleName\"]\r\n        desc = data[\"bundleDescription\"]\r\n        groupName = data[\"groupName\"]\r\n        print(name)\r\n        print(desc)\r\n        print(groupName)\r\n        path = easygui.diropenbox(msg=\"Select folder to share as bundle\", title=\"Share Bundle\")\r\n        bundle = bundleManager.createBundle(name,desc,path=path)\r\n        groupManager.addBundle(bundle,groupName)\r\n        return \"0\"\r\n\r\n@app.route('/selectDownloadLocation', methods=['POST'])\r\ndef selectDownloadLocation():\r\n    if request.method == 'POST':\r\n        path = easygui.diropenbox(msg=\"Select folder to download bundles\", title=\"Select Bundle Download Location\")\r\n        print(path)\r\n        #Update Download Path in Config\r\n        client.DIR_PATH_DOWNLOADS=path\r\n        client.saveConfig()\r\n        #Return path to browser and update it in modal\r\n        return path\r\n\r\n@app.route('/searchBundles', methods=['POST'])\r\ndef searchBundles():\r\n    # print(\"Search Bundles Route\")\r\n    if request.method == 'POST':\r\n        data = request.form\r\n\r\n        #Get Keywords from search\r\n        keywords = data[\"searchKeyWords\"].split()\r\n        # print(\"Search for :\",keywords)\r\n\r\n        #Get Group\r\n        group = data[\"group\"]\r\n        group = groupManager.getGroupWithName(group)\r\n\r\n        searchReq = SearchBundleRequest(group.id,keywords)\r\n        responses = []\r\n        # SEND TO ALL PEERS COLLECT RESPONSES AND PRESENT\r\n        for peer in group.peers:\r\n            res = sendRequest(peer[0], 6700, dumps(searchReq))\r\n            #if other peer is responded.\r\n            if res is not False:\r\n                # print(res)\r\n                responses.append([peer[0],res])\r\n            else:\r\n                print(\"No Response from\",peer[0])\r\n        #Merge all responses to single list\r\n        # for x in responses:\r\n        #     print(\"Response:\",x[0],x[1],x[1].responseBundles)\r\n        #WITH RESPONSES DO STUFF.\r\n        #Respond\r\n        return render_template(\"search.html\", groups=groupManager.groups, group=group , responses = responses)\r\n\r\n@app.route('/createGroup', methods=['POST'])\r\ndef createGroup():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        name = data[\"name\"]\r\n    if groupManager.createGroup(name, [client.publicIP]):\r\n        #Make First Block In Blockchain Append Admin\r\n        #Type 0 First Created\r\n        group = groupManager.getGroupWithName(name)\r\n        group.blockchain.create_genesis_block(client)\r\n        # True\r\n        return \"0\"\r\n    else:\r\n        # False\r\n        return \"1\"\r\n\r\n@app.route('/getBundle', methods=['POST'])\r\ndef getBundle():\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        bundleId = data[\"bundleId\"]\r\n        groupId = data[\"groupId\"]\r\n        userIp = data[\"userIp\"]\r\n        #TODO dynamic port on receiver for bundle\r\n        portForBundleReceiver = 6701\r\n        bundleReceiver = threading.Thread(target=receiveBundle, args=[portForBundleReceiver,client,groupManager,groupId,downloadManager])\r\n        bundleReceiver.start()\r\n        getBundleReq = GetBundleRequest(bundleId,groupId,portForBundleReceiver)\r\n        res = sendRequest(userIp, 6700, dumps(getBundleReq))\r\n        # if other peer is responded.\r\n        if res is not False:\r\n            #Responded decide what to do\r\n            pass\r\n        else:\r\n            # print(\"No Response from\", userIp)\r\n            pass\r\n    return \"1\"\r\n\r\n\r\n@app.route('/quitGroup', methods=['POST'])\r\ndef quitGroup():\r\n    print('QUIT GROUP REQ')\r\n    if request.method == 'POST':\r\n        data = request.form\r\n        groupid = data[\"group\"]\r\n        group = groupManager.getGroupWithId(groupid)\r\n        if groupManager.quitGroup(group):\r\n            # True\r\n            return \"0\"\r\n        else:\r\n            # False\r\n            return \"1\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    client = Client()\r\n    groupManager = GroupManager()\r\n    bundleManager = BundleManager()\r\n    downloadManager = DownloadManager(groupManager,client)\r\n    #TODO Networking Thread To Receive From Internet\r\n    receiver = threading.Thread(target=receiver, args=[groupManager])\r\n    receiver.start()\r\n    app.run(host='', port=6969)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 7083ac7d2a09f8bc9830d05546c2e696de7a9374)
+++ b/main.py	(date 1650530212954)
@@ -199,7 +199,7 @@
 
 @app.route('/quitGroup', methods=['POST'])
 def quitGroup():
-    print('QUIT GROUP REQ')
+    # print('QUIT GROUP REQ')
     if request.method == 'POST':
         data = request.form
         groupid = data["group"]
Index: Groups.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from time import time\r\nimport os\r\nfrom os import listdir\r\nfrom os.path import isfile, join\r\nimport json\r\nfrom typing import Type\r\nimport shutil\r\nimport hashlib\r\nfrom Blockchain import Blockchain\r\nimport Blockchain\r\nfrom Bundles import Bundle\r\nimport copy\r\n\r\n\r\nclass Invite:\r\n    def __init__(self, id, name, timestamp, peers):\r\n        self.id = id\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n        self.peers = peers\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\n\r\nclass Group:\r\n    def __init__(self, name, admin, peers, timestamp, blockchainPath,id=None):\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n        self.admins = admin\r\n        self.peers = peers\r\n\r\n        self.bundles = []\r\n        if id is None:\r\n            self.id = hashlib.sha256((name + str(timestamp)).encode('utf-8')).hexdigest()\r\n        else:\r\n            self.id = id\r\n\r\n        self.blockchain = Blockchain.Blockchain(blockchainPath,self.peers,self.id)\r\n\r\n    def generateInvite(self):\r\n        invite = Invite(self.id, self.name, self.timestamp, self.peers)\r\n        return invite\r\n\r\n\r\n    def removeBundle(self,bundle):\r\n        self.bundles.remove(bundle)\r\n        return True\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\n    def getBundleWithId(self, bundleid):\r\n        group: Bundle\r\n        for bundle in self.bundles:\r\n            # print(\"trying to match\",bundle.id)\r\n            if bundle.id == bundleid:\r\n                return bundle\r\n        # If Nothing Proked return in for loop return false for not having the bundle .\r\n        return False\r\n\r\nclass GroupManager:\r\n\r\n    def __init__(self):\r\n        self.groups = []\r\n        self.DIR_PATH_GROUPS = '%s\\\\TorrentApp\\\\Groups\\\\' % os.environ['APPDATA']\r\n        if not os.path.exists(self.DIR_PATH_GROUPS):\r\n            # Create a new directory because it does not exist\r\n            print(\"Gonna Create Group Folder\")\r\n            os.makedirs(self.DIR_PATH_GROUPS)\r\n        # Load Groups\r\n        self.loadGroups()\r\n        print(\"GroupManager Initialized\")\r\n\r\n    def deleteBundle(self,group,bundle):\r\n        group = self.getGroupWithId(group)\r\n        bundle = group.getBundleWithId(bundle)\r\n        group.removeBundle(bundle)\r\n        os.remove(self.DIR_PATH_GROUPS + group.name+\"\\\\Bundles\\\\\"+bundle.name+\".json\")\r\n        return True\r\n\r\n\r\n    def addGroup(self, group):\r\n        self.saveGroup(group)\r\n        self.groups.append(group)\r\n\r\n    def removeGroup(self, group):\r\n        self.groups.remove(group)\r\n        print(self.groups)\r\n\r\n    def getGroupWithName(self, name):\r\n        group: Group\r\n        for group in self.groups:\r\n            if group.name == name:\r\n                return group\r\n\r\n    def getGroupWithId(self, id):\r\n        group: Group\r\n        for group in self.groups:\r\n            if group.id == id:\r\n                return group\r\n\r\n    def addPeerGroup(self, name, peer):\r\n        group: Group\r\n        for group in self.groups:\r\n            if group.name == name:\r\n                if peer not in group.peers:\r\n                    group.peers.append(peer)\r\n                    self.saveGroup(group)\r\n                    return\r\n\r\n    def createGroup(self, name, admin):\r\n        timeNow = time()\r\n        newGroup = Group(name, [admin, ], [admin, ], timeNow,blockchainPath=self.DIR_PATH_GROUPS+name+\"\\\\Blockchain\")\r\n        self.saveGroup(newGroup)\r\n        self.groups.append(newGroup)\r\n        return True\r\n\r\n    def quitGroup(self, group):\r\n        group : Group\r\n        shutil.rmtree(self.DIR_PATH_GROUPS + group.name)\r\n        self.removeGroup(group)\r\n        return True\r\n\r\n    def saveGroup(self, group: Group):\r\n        # Create JSON file\r\n        json_file_name = group.name + \".json\"\r\n        if not os.path.exists(self.DIR_PATH_GROUPS + group.name):\r\n            # Create a new directory because it does not exist\r\n            print(\"Gonna Create Group Folder\")\r\n            os.makedirs(self.DIR_PATH_GROUPS + group.name)\r\n        json_file = open(self.DIR_PATH_GROUPS + group.name + '\\\\' + json_file_name, \"w\")\r\n        saveCopy = copy.copy(group)\r\n        del saveCopy.bundles\r\n        del saveCopy.blockchain\r\n        json_file.write(saveCopy.toJSON())\r\n        json_file.close()\r\n\r\n    def loadGroup(self, groupName):\r\n        try:\r\n            file = open(self.DIR_PATH_GROUPS + groupName + \"\\\\\" + groupName + \".json\")\r\n            json_load_group = json.load(file)\r\n            file.close()\r\n        except:\r\n            print(\"Error Opening Group file :\", groupName)\r\n\r\n        group = Group(json_load_group[\"name\"], json_load_group[\"admins\"],\r\n                      json_load_group[\"peers\"], json_load_group[\"timestamp\"],self.DIR_PATH_GROUPS + groupName + \"\\\\\" + \"Blockchain\\\\\", json_load_group[\"id\"])\r\n\r\n        # Load Bundles of Each group.\r\n        groupBundlePath = self.DIR_PATH_GROUPS + groupName + \"\\\\\" + \"Bundles\\\\\"\r\n        # Make the folder if it dosent exist .\r\n        if not os.path.exists(groupBundlePath):\r\n            os.makedirs(groupBundlePath)\r\n        else:\r\n            # if exists search all the files\r\n            bundles = [f for f in listdir(groupBundlePath) if isfile(join(groupBundlePath, f))]\r\n            for bundle in bundles:\r\n                pathForBundleFile = join(groupBundlePath, bundle)\r\n                with open(pathForBundleFile) as json_file:\r\n                    data = json.load(json_file)\r\n                    #    def __init__(self,name,desc,root,pieceSize=49152,files=[],path=None):\r\n                    bundleObj = Bundle(data[\"name\"], data[\"description\"], data[\"id\"], data[\"timestamp\"], data[\"root\"],\r\n                                       data[\"pieceSize\"], data[\"files\"])\r\n                    group.bundles.append(bundleObj)\r\n\r\n\r\n\r\n        self.groups.append(group)\r\n\r\n    def loadGroups(self):\r\n        groups = [group for group in listdir(self.DIR_PATH_GROUPS)]\r\n        for group in groups:\r\n            self.loadGroup(group)\r\n\r\n    def addBundle(self, bundle, group):\r\n        if not os.path.exists(self.DIR_PATH_GROUPS + group + \"\\\\\" + \"Bundles\"):\r\n            # Create a new directory because it does not exist\r\n            print(\"Creating Group Folder\")\r\n            os.makedirs(self.DIR_PATH_GROUPS + group + \"\\\\\" + \"Bundles\")\r\n        json_file_name = bundle.name + \".json\"\r\n        json_file = open(self.DIR_PATH_GROUPS + group + \"\\\\\" + \"Bundles\" + \"\\\\\" + json_file_name, \"w\")\r\n        json_file.write(json.dumps(bundle.toJSON()))\r\n        json_file.close()\r\n        self.getGroupWithName(group).bundles.append(bundle)\r\n        # print(\"Added Bundle\")\r\n        # print(self.DIR_PATH_GROUPS + group + \"\\\\\" + \"Bundles\")\r\n        # print(self.DIR_PATH_GROUPS + group + \"\\\\\" + \"Bundles\" + \"\\\\\" + json_file_name)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Groups.py b/Groups.py
--- a/Groups.py	(revision 7083ac7d2a09f8bc9830d05546c2e696de7a9374)
+++ b/Groups.py	(date 1650530142770)
@@ -93,12 +93,16 @@
         for group in self.groups:
             if group.name == name:
                 return group
+        #Group not found
+        return False
 
     def getGroupWithId(self, id):
         group: Group
         for group in self.groups:
             if group.id == id:
                 return group
+        #Group not found
+        return False
 
     def addPeerGroup(self, name, peer):
         group: Group
Index: Networking.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import copy\r\nimport json\r\nimport pickle\r\nimport socket\r\nimport threading\r\nfrom socket import *\r\nfrom Bundles import Bundle\r\nimport Client\r\nfrom Groups import GroupManager, Group\r\nimport os\r\nimport hashlib\r\nimport Blockchain\r\n\r\n\r\nclass Request:\r\n    def __init__(self, type):\r\n        self.type = type\r\n\r\n    def toJSON(self):\r\n        return json.dumps(self.__dict__)\r\n\r\n\r\n# All Classes extended Request even Response Classes just for type and toJSON method.\r\n\r\nclass JoinRequest(Request):\r\n    def __init__(self, name, timestamp):\r\n        super().__init__(1)\r\n        self.name = name\r\n        self.timestamp = timestamp\r\n\r\n\r\nclass JoinResponse(Request):\r\n    def __init__(self, group):\r\n        super().__init__(1)\r\n        self.group = group\r\n\r\n\r\nclass SearchBundleRequest(Request):\r\n    def __init__(self, groupId, keyword):\r\n        super().__init__(2)\r\n        self.groupID = groupId\r\n        self.keywords = keyword\r\n\r\n\r\nclass SearchBundleResponse(Request):\r\n    def __init__(self, responseBundles):\r\n        super().__init__(2)\r\n        self.responseBundles = responseBundles\r\n\r\n\r\nclass GetBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId, portForBundleReceiver):\r\n        super().__init__(3)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.portForBundleReceiver = portForBundleReceiver\r\n\r\n\r\nclass GetBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(3)\r\n        self.answer = answer\r\n\r\n\r\nclass CheckBundleAvailabilityRequest(Request):\r\n    def __init__(self, bundleId, groupId):\r\n        super().__init__(4)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n\r\n\r\nclass CheckBundleAvailabilityResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(4)\r\n        self.answer = answer\r\n\r\n\r\nclass DownloadBundleRequest(Request):\r\n    def __init__(self, bundleId, groupId, file, port):\r\n        super().__init__(5)\r\n        self.bundleId = bundleId\r\n        self.groupId = groupId\r\n        self.file = file\r\n        self.port = port\r\n\r\n\r\nclass DownloadBundleResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(5)\r\n        self.answer = answer\r\n\r\nclass UpdateBlockchainRequest(Request):\r\n    def __init__(self, groupId):\r\n        super().__init__(6)\r\n        self.groupId = groupId\r\n\r\n\r\nclass UpdateBlockchainResponse(Request):\r\n    def __init__(self, answer):\r\n        super().__init__(6)\r\n        self.answer = answer\r\n\r\ndef requestHandler(data, addr, groupManager: GroupManager):\r\n    req = pickle.loads(data)\r\n    print(f\"Received From {addr[0]}:{addr[1]} {req.__class__.__name__}\")\r\n\r\n    # Response to JoinRequest\r\n    if req.type == 1:\r\n        req = JoinRequest(req.name, req.timestamp)\r\n        group = groupManager.getGroupWithName(req.name)\r\n        if group.blockchain.isUserAllowed(addr[0]):\r\n            groupManager.addPeerGroup(req.name, [addr[0]])\r\n            groupCpy = copy.copy(group)\r\n            del groupCpy.bundles\r\n            joinResponse = JoinResponse(groupCpy)\r\n            return pickle.dumps(joinResponse)\r\n        else:\r\n            return False\r\n\r\n    # Response to search req\r\n    elif req.type == 2:\r\n        # Create The Request again for local use\r\n        req = SearchBundleRequest(req.groupID, req.keywords)\r\n        # Get All Bundles User has\r\n        bundlesOfGroup = groupManager.getGroupWithId(req.groupID).bundles\r\n        # Bundles to reply\r\n        responseBundles = []\r\n        # print(responseBundles)\r\n        for bundle in bundlesOfGroup:\r\n            # For each bundle make a single list (bundleKeywords) and search if any of the keywords other user send are in there then send back\r\n            name = bundle.name.split()\r\n            desc = bundle.description.split()\r\n            bundleKeywords = name + desc\r\n            # print(\"Bundle Keywords : \",bundleKeywords)\r\n            # print(\"Request Keywords : \",req.keywords)\r\n            if any(keyword in req.keywords for keyword in bundleKeywords):\r\n                # print(\"HIT\")\r\n                responseBundles.append({\"id\": bundle.id, \"name\": bundle.name, \"description\": bundle.description})\r\n        # Create Response and return it to be used as answer\r\n        # print(responseBundles)\r\n        searchResponse = SearchBundleResponse(responseBundles)\r\n        # print(\"Search Response :\",searchResponse)\r\n        return pickle.dumps(searchResponse)\r\n\r\n    elif req.type == 3:\r\n        req = GetBundleRequest(req.bundleId, req.groupId, req.portForBundleReceiver)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        bundle = group.getBundleWithId(req.bundleId)\r\n        bundleReceiver = threading.Thread(target=sendBundle,\r\n                                          args=[addr, req.portForBundleReceiver, groupManager, group, bundle])\r\n        bundleReceiver.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        # TODO 9/4 ????\r\n        return pickle.dumps(GetBundleResponse(1))\r\n\r\n    elif req.type == 4:\r\n        req = CheckBundleAvailabilityRequest(req.bundleId, req.groupId)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        bundle = group.getBundleWithId(req.bundleId)\r\n        if bundle is False:\r\n            # Not Found\r\n            return pickle.dumps(CheckBundleAvailabilityResponse(0))\r\n        else:\r\n            # Found\r\n            return pickle.dumps(CheckBundleAvailabilityResponse(1))\r\n\r\n    elif req.type == 5:\r\n        # print(\"Received Request To Send File\")\r\n        req = DownloadBundleRequest(req.bundleId, req.groupId, req.file, req.port)\r\n        uploadThread = threading.Thread(target=uploadBundle,\r\n                                        args=[addr, req.port, req.bundleId, req.groupId, req.file, groupManager])\r\n        uploadThread.start()\r\n        # TODO refactor use it to determine if user ok to send bundle\r\n        # TODO 9/4 ????\r\n        return pickle.dumps(DownloadBundleResponse(1))\r\n\r\n    elif req.type == 6:\r\n        req = UpdateBlockchainRequest(req.groupId)\r\n        group = groupManager.getGroupWithId(req.groupId)\r\n        if group.blockchain.isUserAllowed(addr[0]):\r\n            #User is ok\r\n            lastBlock = group.blockchain.getLastBlock()\r\n            lastBlock : Blockchain.Block\r\n            lastBlockIndex = lastBlock.index\r\n            return pickle.dumps(UpdateBlockchainResponse(lastBlockIndex))\r\n        else:\r\n            #User not invited not joined, therefore don't answer.\r\n            return False\r\n\r\ndef responseHandler(data):\r\n    res = pickle.loads(data)\r\n\r\n    if res.type == 1:\r\n        res = JoinResponse(res.group)\r\n        return res\r\n\r\n    elif res.type == 2:\r\n        res = SearchBundleResponse(res.responseBundles)\r\n        return res\r\n\r\n    elif res.type == 3:\r\n        res = SearchBundleResponse(res.answer)\r\n        return res\r\n\r\n    elif res.type == 4:\r\n        res = CheckBundleAvailabilityResponse(res.answer)\r\n        return res\r\n\r\n    elif res.type == 5:\r\n        res = DownloadBundleResponse(res.answer)\r\n        return res\r\n\r\n    elif res.type == 6:\r\n        res = UpdateBlockchainResponse(res.answer)\r\n        return res\r\n\r\n\r\ndef receiver(groupManager):\r\n    UDP_IP = '0.0.0.0'\r\n    UDP_PORT = 6700\r\n    sock = socket(AF_INET, SOCK_DGRAM)\r\n    sock.bind((UDP_IP, UDP_PORT))\r\n    print(\"Listening on \", UDP_IP, \":\", UDP_PORT)\r\n    while True:\r\n        # RECEIVE AND RESPOND.\r\n        data, addr = sock.recvfrom(65537)\r\n        # data, addr = sock.recvfrom(65507)\r\n        # print(\"Received from :\", addr)\r\n        response = requestHandler(data, addr, groupManager)\r\n        #Request Handler if not want to answer returns False.\r\n        if response is not False:\r\n            sock.sendto(response, addr)\r\n\r\n\r\ndef sendRequest(address, port, request):\r\n    # Create a socket for sending files\r\n    clientSocket = socket(AF_INET, SOCK_DGRAM)\r\n    clientSocket.settimeout(1)\r\n    try:\r\n        clientSocket.sendto(request, (address, port))\r\n        data, addr = clientSocket.recvfrom(65537)\r\n        # data, addr = clientSocket.recvfrom(65507)\r\n        res = responseHandler(data)\r\n        return res\r\n    # TODO except socket.timeout\r\n    except Exception as exception:\r\n        # print(\"Exception on SendRequest:\", exception)\r\n        return False\r\n\r\n\r\ndef receiveBundle(port, client, groupManager, groupId, downloadManager):\r\n    # print(\"RECEIVING BUNDLE THREAD\")\r\n    bundleBytes = b\"\"\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.bind((\"0.0.0.0\", port))\r\n        # print(\"Bundle Receiver Ready\")\r\n        s.listen()\r\n        conn, addr = s.accept()\r\n        with conn:\r\n            print(f\"Connection From {addr[0]}:{addr[1]} Accepted.\")\r\n            while True:\r\n                data = conn.recv(1024)\r\n                # print(data)\r\n                bundleBytes = bundleBytes + data\r\n                # TODO save Bytes to group and downloads also start downloading.\r\n                if not data:\r\n                    # print(\"Break\")\r\n                    break\r\n            # print(\"Break3\")\r\n    # print(\"Bundle Str\",bundleBytes.decode())\r\n    bundleObj = json.loads(bundleBytes.decode())\r\n    # Fix Bundle Root to be downloaded and location\r\n    client: Client.Client\r\n    bundleObj[\"root\"] = client.DIR_PATH_DOWNLOADS\r\n    bundle = Bundle(bundleObj[\"name\"], bundleObj[\"description\"], bundleObj[\"id\"], bundleObj[\"timestamp\"],\r\n                    bundleObj[\"root\"], bundleObj[\"pieceSize\"], bundleObj[\"files\"])\r\n    group = groupManager.getGroupWithId(groupId)\r\n    groupManager.addBundle(bundle, group.name)\r\n    downloadManager.downloadBundle(bundle, group)\r\n\r\n\r\ndef sendBundle(addr, port, groupManager, group, bundle):\r\n    # print(\"SENDING BUNDLE THREAD\")\r\n    group: Group\r\n    with socket(AF_INET, SOCK_STREAM) as s:\r\n        s.connect((addr[0], port))\r\n        print(f\"Connected To {addr[0]}:{addr[1]}.\")\r\n        # print(\"SENDING DATA\")\r\n        groupManager: GroupManager\r\n        json_file_name = bundle.name + \".json\"\r\n        bundleDir = groupManager.DIR_PATH_GROUPS + group.name + \"\\\\\" + \"Bundles\" + \"\\\\\" + json_file_name\r\n        print(bundleDir)\r\n        print(json_file_name)\r\n        with open(bundleDir) as f:\r\n            bundleContent = f.read()\r\n            bundleObj = json.loads(bundleContent)\r\n            bundleObj[\"root\"] = \"\"\r\n            bundleStr = json.dumps(bundleObj)\r\n\r\n        s.sendall(bundleStr.encode())\r\n\r\n\r\ndef is_port_in_use(port: int) -> bool:\r\n    import socket\r\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\r\n        return s.connect_ex(('localhost', port)) == 0\r\n\r\n\r\ndef downloadBundle(downloadManager , port, peer, file, bundle, usedPeers, freeFiles):\r\n    bundle: BundleToDownload\r\n    pieceList = []\r\n    # Find pieces missing\r\n    for x in bundle.files:\r\n        if x[\"path\"] == file[0]:\r\n            pieceList = x[\"pieces\"]\r\n            break\r\n    # pieceList = [[0, '5920572cf97d3711a77a9b7a3469a5fd03bb2a8a', 0]]\r\n    # print(\"DOWNLOADING BUNDLE THREAD\")\r\n    filePath = bundle.root +f\"\\\\{bundle.name}\"+ file[0]\r\n    dir = filePath.rsplit('\\\\', 1)[0]\r\n    # print(dir)\r\n    #Create Directory's that don't exist.\r\n    isExist = os.path.exists(dir)\r\n    if not isExist:\r\n        # Create a new directory because it does not exist\r\n        os.makedirs(dir)\r\n\r\n    if os.path.exists(filePath) is False:\r\n        print(\"Creating File\")\r\n        file = open(filePath, 'x')\r\n        file.close()\r\n\r\n\r\n    with open(filePath, 'rb+') as openfileobject:\r\n        with socket(AF_INET, SOCK_STREAM) as s:\r\n            s.bind((\"0.0.0.0\", port))\r\n            # print(\"Bundle Receiver Ready\")\r\n            s.listen()\r\n            conn, addr = s.accept()\r\n            with conn:\r\n                print(f\"Connection From {addr[0]}:{addr[1]} Accepted.\")\r\n                data = conn.recv(1024)\r\n                if data.decode() == \"OK\":\r\n                    # print(\"Received Ok\")\r\n                    for piece in pieceList:\r\n                        if piece[2] == 0:\r\n                            # print(f\"Sending Piece num {piece[0]} \")\r\n                            conn.sendall(str(piece[0]).encode())\r\n                            openfileobject.seek(piece[0]*bundle.pieceSize)\r\n                            data = conn.recv(100000)\r\n                            # print(f\"Received {data}\")\r\n                            if hashlib.sha1(data).hexdigest() == piece[1]:\r\n                                # print(\"HASH OK\")\r\n                                openfileobject.write(data)\r\n                                piece[2]=1\r\n                                # print(piece)\r\n                            else:\r\n                                pass\r\n                                # print(\"hashes dont match\")\r\n                    # delimmiter for data\r\n                    conn.sendall(\"\uD83E\uDD6D\uD83C\uDF53\uD83C\uDF47\uD83C\uDF49\uD83C\uDF50\uD83E\uDD67\uD83C\uDF4A\uD83C\uDF4D\uD83C\uDF4F\uD83E\uDD51\uD83C\uDF51\uD83C\uDF4C\uD83C\uDF4E\uD83C\uDF50\uD83C\uDF49\uD83C\uDF47\uD83C\uDF53\uD83E\uDD6D\uD83E\uDD5D\uD83C\uDF52\uD83C\uDF45\".encode())\r\n                    usedPeers.remove(peer)\r\n                    downloadManager.saveBundle(bundle)\r\n    # print(f\"Thread Exit {file}\")\r\n\r\n\r\n\r\ndef uploadBundle(addr, port, bundleId, groupId, file, groupManager):\r\n    # print(\"SENDING BUNDLE THREAD\")\r\n    group = groupManager.getGroupWithId(groupId)\r\n    bundle = group.getBundleWithId(bundleId)\r\n    with open(bundle.root + file, 'rb') as openfileobject:\r\n        try:\r\n            with socket(AF_INET, SOCK_STREAM) as s:\r\n                s.connect((addr[0], port))\r\n                # print(\"SENDING DATA\")\r\n                s.sendall(\"OK\".encode())\r\n                while True:\r\n                    piece = s.recv(1024)\r\n                    #delimmiter for data\r\n                    if piece == \"\uD83E\uDD6D\uD83C\uDF53\uD83C\uDF47\uD83C\uDF49\uD83C\uDF50\uD83E\uDD67\uD83C\uDF4A\uD83C\uDF4D\uD83C\uDF4F\uD83E\uDD51\uD83C\uDF51\uD83C\uDF4C\uD83C\uDF4E\uD83C\uDF50\uD83C\uDF49\uD83C\uDF47\uD83C\uDF53\uD83E\uDD6D\uD83E\uDD5D\uD83C\uDF52\uD83C\uDF45\".encode():\r\n                        break\r\n                    else:\r\n                        if piece == b'':\r\n                            # print(\"Empty\")\r\n                            pass\r\n                        else:\r\n                            piece = int(piece.decode())\r\n                            # print(f\"Trying to send {piece}\")\r\n                            openfileobject.seek(piece * bundle.pieceSize)\r\n                            readData = openfileobject.read(bundle.pieceSize)\r\n                            s.sendall(readData)\r\n        except ConnectionResetError as exception:\r\n            print(\"Downloader DC\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Networking.py b/Networking.py
--- a/Networking.py	(revision 7083ac7d2a09f8bc9830d05546c2e696de7a9374)
+++ b/Networking.py	(date 1650530163744)
@@ -177,15 +177,16 @@
     elif req.type == 6:
         req = UpdateBlockchainRequest(req.groupId)
         group = groupManager.getGroupWithId(req.groupId)
-        if group.blockchain.isUserAllowed(addr[0]):
-            #User is ok
-            lastBlock = group.blockchain.getLastBlock()
-            lastBlock : Blockchain.Block
-            lastBlockIndex = lastBlock.index
-            return pickle.dumps(UpdateBlockchainResponse(lastBlockIndex))
-        else:
-            #User not invited not joined, therefore don't answer.
-            return False
+        if group is not False:
+            if group.blockchain.isUserAllowed(addr[0]):
+                #User is ok
+                lastBlock = group.blockchain.getLastBlock()
+                lastBlock : Blockchain.Block
+                lastBlockIndex = lastBlock.index
+                return pickle.dumps(UpdateBlockchainResponse(lastBlockIndex))
+            else:
+                #User not invited not joined, therefore don't answer.
+                return False
 
 def responseHandler(data):
     res = pickle.loads(data)
